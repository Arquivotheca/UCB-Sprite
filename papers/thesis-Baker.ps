%!
%%BoundingBox: (atend)
%%Pages: (atend)
%%DocumentFonts: (atend)
%%EndComments
%
% FrameMaker PostScript Prolog 3.0, for use with FrameMaker 3.0
% Copyright (c) 1986,87,89,90,91 by Frame Technology Corporation.
% All rights reserved.
%
% Known Problems:
%	Due to bugs in Transcript, the 'PS-Adobe-' is omitted from line 1
/FMversion (3.0) def 
% Set up Color vs. Black-and-White
	/FMPrintInColor systemdict /colorimage known
		systemdict /currentcolortransfer known or def
% Uncomment this line to force b&w on color printer
%   /FMPrintInColor false def
/FrameDict 195 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} def
	} if
/FMVERSION {
	FMversion ne {
		/Times-Roman findfont 18 scalefont setfont
		100 100 moveto
		(FrameMaker version does not match postscript_prolog!)
		dup =
		show showpage
		} if
	} def 
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/organgle FMLOCAL
	/orgfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne dup {setmanualfeed} if
	/manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	/yscale exch def
	/xscale exch def
	currenttransfer cvlit /orgxfer exch def
	currentscreen cvlit /orgproc exch def
	/organgle exch def /orgfreq exch def
	setpapername 
	manualfeed {true} {papersize} ifelse 
	{manualpapersize} {false} ifelse 
	{desperatepapersize} if
	end 
	} def 
	/pagesave FMLOCAL
	/orgmatrix FMLOCAL
	/landscape FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch neg translate pop 
		}
		{pop pop}
		ifelse
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
	} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin
	array /fillvals exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fy translate 
	rotate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	} bind def
/FMENDEPSF {
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	/FMdicttop countdictstack 1 add def 
	statusdict begin stopped end 
	countdictstack -1 FMdicttop {pop end} for 
	} def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped pop 
		end
		} if
	} def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
/freq dpi 18.75 div 8 div round dup 0 eq {pop 1} if 8 mul dpi exch div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setpattern {
	 /bwidth  exch def
	 /bpside  exch def
	 /bstring exch def
	 /onbits 0 def  /offbits 0 def
	 freq sangle landscape {90 add} if 
		{/y exch def
		 /x exch def
		 /xindex x 1 add 2 div bpside mul cvi def
		 /yindex y 1 add 2 div bpside mul cvi def
		 bstring yindex bwidth mul xindex 8 idiv add get
		 1 7 xindex 8 mod sub bitshift and 0 ne
		 {/onbits  onbits  1 add def 1}
		 {/offbits offbits 1 add def 0}
		 ifelse
		}
		setscreen
	 {} settransfer
	 offbits offbits onbits add div FMsetgray
	/graymode false def
	} bind def
/grayness {
	FMsetgray
	graymode not {
		/graymode true def
		orgxfer cvx settransfer
		orgfreq organgle orgproc cvx setscreen
		} if
	} bind def
	/HUE FMLOCAL
	/SAT FMLOCAL
	/BRIGHT FMLOCAL
	/Colors FMLOCAL
FMPrintInColor 
	
	{
	/HUE 0 def
	/SAT 0 def
	/BRIGHT 0 def
	% array of arrays Hue and Sat values for the separations [HUE BRIGHT]
	/Colors   
	[[0    0  ]    % black
	 [0    0  ]    % white
	 [0.00 1.0]    % red
	 [0.37 1.0]    % green
	 [0.60 1.0]    % blue
	 [0.50 1.0]    % cyan
	 [0.83 1.0]    % magenta
	 [0.16 1.0]    % comment / yellow
	 ] def
      
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	/K { 
		Colors exch get dup
		0 get /HUE exch store 
		1 get /BRIGHT exch store
		  HUE 0 eq BRIGHT 0 eq and
			{1.0 SAT sub setgray}
			{HUE SAT BRIGHT sethsbcolor} 
		  ifelse
		} def
	/FMsetgray { 
		/SAT exch 1.0 exch sub store 
		  HUE 0 eq BRIGHT 0 eq and
			{1.0 SAT sub setgray}
			{HUE SAT BRIGHT sethsbcolor} 
		  ifelse
		} bind def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	/FMsetgray {setgray} bind def
	/K { 
		pop
		} def
	}
ifelse
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setpattern} 
	{grayness}
	ifelse
	} bind def
/V { 
	gsave eofill grestore
	} bind def
/N { 
	stroke
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
	/rad FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	newpath
	x1 y1 rad add moveto
	x1 y2 x2 y2 rad arcto
	x2 y2 x2 y1 rad arcto
	x2 y1 x1 y1 rad arcto
	x1 y1 x1 y2 rad arcto
	closepath
	16 {pop} repeat
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath fill
	grestore
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	stroke
	grestore
	} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 4 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
	dup 
	8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
	/r exch def
	/d exch def
	gsave
	translate rotate scale /h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	translate rotate scale /h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
	/proc1 FMLOCAL
	/proc2 FMLOCAL
	/newproc FMLOCAL
/Fmcc {
    /proc2 exch cvlit def
    /proc1 exch cvlit def
    /newproc proc1 length proc2 length add array def
    newproc 0 proc1 putinterval
    newproc proc1 length proc2 putinterval
    newproc cvx
} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch Fmcc settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	translate rotate scale /h exch def /w exch def
	/bitmapsave save def 
	colorsetup
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} {is} {is} true 3 colorimage 
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	translate rotate scale /h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	colorsetup
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} {is} {is} true 3 colorimage
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        
        /is w string def
        
        ws 0 w getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {ip} {gip} {bip} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        
        /is w string def
        
        ws 0 w getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {ip gip bip w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
        translate rotate scale /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
%%EndProlog
%%BeginSetup
(3.0) FMVERSION
1 1 612 792 0 1 18 FMDOCUMENT
0 0 /Times-Bold FMFONTDEFINE
1 0 /Times-Roman FMFONTDEFINE
2 0 /Times-Italic FMFONTDEFINE
3 1 /Symbol FMFONTDEFINE
4 0 /Courier-Bold FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 .1 FMFILL
2 .3 FMFILL
3 .5 FMFILL
4 .7 FMFILL
5 .9 FMFILL
6 .97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 .9 FMFILL
18 .7 FMFILL
19 .5 FMFILL
20 .3 FMFILL
21 .1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "1" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
0 14 Q
0 X
0 K
(Fast Crash Recovery in Distributed File Systems) 170.04 682.67 T
1 12 Q
(by) 309 646 T
(Mary Louise Gray Baker) 254.88 618 T
(A.B. \050University of California at Berkeley\051 1984) 198.08 562 T
(M.S. \050University of California at Berkeley\051 1988) 197.75 546 T
(A dissertation submitted in partial satisfaction of the requirements for) 147.94 490 T
(the degree of) 283.7 474 T
(Doctor of Philosophy) 263.36 446 T
(in) 310.33 418 T
(Computer Science) 270.86 390 T
(in the) 301.51 362 T
(GRADUA) 254.55 334 T
(TE DIVISION) 304.51 334 T
(of the) 301.18 306 T
(UNIVERSITY of CALIFORNIA at BERKELEY) 196.08 278 T
(Committee in char) 144 226 T
(ge:) 233.06 226 T
(Professor John Ousterhout, Chair) 194.4 198 T
(Professor Randy Katz) 194.4 180 T
(Professor Rainer Sachs) 194.4 162 T
(1994) 303.01 116 T
FMENDPAGE
%%EndPage: "1" 2
%%Page: "2" 2
612 792 0 FMBEGINPAGE
0 14 Q
0 X
0 K
(Fast Crash Recovery in Distributed File Systems) 179.04 494.67 T
1 11 Q
(Copyright \251 1994) 283.81 452.67 T
(by) 318.51 429.67 T
(Mary Louise Gray Baker) 268.93 406.67 T
(All rights reserved) 283.11 383.67 T
FMENDPAGE
%%EndPage: "2" 3
%%Page: "3" 3
612 792 0 FMBEGINPAGE
0 18 Q
0 X
0 K
(Abstract) 290.53 708 T
(Fast Crash Recovery in Distributed File Systems) 137.62 660 T
1 11 Q
(by) 318.51 622.67 T
(Mary Louise Gray Baker) 268.93 605.67 T
(Doctor of Philosophy in Computer Science) 229.25 586.67 T
(University of California at Berkeley) 244.67 567.67 T
(Professor John Ousterhout, Chair) 250.76 548.67 T
-0.06 (This thesis presents) 118.8 500.67 P
2 F
-0.06 (fast crash r) 207.42 500.67 P
-0.06 (ecovery) 256.94 500.67 P
1 F
-0.06 (: a simple, ef) 291.1 500.67 P
-0.06 (\336cient, and inexpensive method for increas-) 347.47 500.67 P
-0.03 (ing availability in distributed systems. In fast crash recovery we assume that critical resources will) 108 487.67 P
0.28 (fail, and we do not attempt to mask the failures with redundant hardware or software. Instead, we) 108 474.67 P
0.05 (design the system to recover so quickly that there is little downtime. This approach is intended for) 108 461.67 P
1.68 (environments than can tolerate occasional failures and cannot af) 108 448.67 P
1.68 (ford the cost and overhead of) 403.16 448.67 P
(redundant resources.) 108 435.67 T
0.26 (In particular) 118.8 410.67 P
0.26 (, I focus on fast recovery of distributed state. An example of distributed state is the) 172.62 410.67 P
1.8 (\336le caching information maintained by servers in most modern \336le systems. This information) 108 397.67 P
0.69 (describes the state of \336le caches on client workstations. After a crash, a server must recover this) 108 384.67 P
1.17 (information in order to guarantee the consistency of the caches. Unfortunately) 108 371.67 P
1.17 (, distributed state) 462.27 371.67 P
0.68 (recovery can be slow and complex. The techniques I have developed reduce state recovery from) 108 358.67 P
(several minutes to under six seconds for a Sprite \336le server [Ouster88] with 40 clients.) 108 345.67 T
0.24 (This thesis evaluates three distributed state recovery techniques based on their speed, complex-) 118.8 320.67 P
0.15 (ity) 108 307.67 P
0.15 (, and performance overhead. In) 118.89 307.67 P
2 F
0.15 (client-driven r) 259.68 307.67 P
0.15 (ecovery) 322.59 307.67 P
1 F
0.15 ( clients send their state information to the) 356.74 307.67 P
0.08 (server after a crash. The server uses this information to regenerate its copy of the distributed state.) 108 294.67 P
2 F
1.68 (Server) 108 281.67 P
1.68 (-driven r) 136.46 281.67 P
1.68 (ecovery) 176.47 281.67 P
1 F
1.68 ( is a modi\336cation of client-driven recovery that is faster and eliminates) 210.63 281.67 P
0.69 (cache inconsistencies that can arise during client-driven recovery) 108 268.67 P
0.69 (. The fastest technique is) 398.61 268.67 P
2 F
0.69 (trans-) 513.75 268.67 P
0.25 (par) 108 255.67 P
0.25 (ent r) 122.85 255.67 P
0.25 (ecovery) 143.14 255.67 P
1 F
0.25 (, so-called because client workstations do not communicate with the server during) 176.59 255.67 P
0 (recovery) 108 242.67 P
0 (. Instead, the server stores its distributed state in a protected area of its own main memory) 145.72 242.67 P
0.6 (called the) 108 229.67 P
2 F
0.6 (r) 154.35 229.67 P
0.6 (ecovery box) 158.21 229.67 P
1 F
0.6 (. The interface to the recovery box helps detect and prevent corruption of) 211.58 229.67 P
(this state information.) 108 216.67 T
0.45 (T) 118.8 191.67 P
0.45 (o achieve fast overall recovery times, we must also recover other parts of the system quickly) 124.74 191.67 P
0.45 (.) 537.25 191.67 P
0.63 (For example, we can eliminate a lengthy \336le system consistency check by using a log-structured) 108 178.67 P
-0.15 (\336le system that recovers in seconds [Rosenb91]. By combining the improvements described in this) 108 165.67 P
0.55 (thesis, a Sprite \336le server can reboot in under 30 seconds. This is two orders of magnitude faster) 108 152.67 P
(than most modern \336le systems recover) 108 139.67 T
(.) 276.75 139.67 T
0.24 (In addition to evaluating distributed state recovery techniques, this thesis presents some overall) 118.8 114.67 P
(guidelines for designing distributed systems that will recover quickly from crashes.) 108 101.67 T
FMENDPAGE
%%EndPage: "3" 4
%%Page: "iv" 4
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(iv) 283.33 55 T
0 18 Q
(Dedication) 246.52 708 T
1 11 Q
(T) 82.8 652.67 T
(o F) 88.74 652.67 T
(. F) 102.21 652.67 T
(. and the others) 112.93 652.67 T
3 F
(-) 182.81 652.67 T
1 F
( I wish you were here.) 188.84 652.67 T
FMENDPAGE
%%EndPage: "iv" 5
%%Page: "v" 5
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(v) 321 55 T
0 18 Q
(T) 255.79 708 T
(able of Contents) 266.13 708 T
0 12 Q
(CHAPTER 1. Introduction) 108 652 T
1 F
(.........................................................................................) 251.86 652 T
(1) 519.6 652 T
1 11 Q
(1.1.) 129.6 632.67 T
(Measurement Environment and Applicability) 165.6 632.67 T
(......................................................) 368.04 632.67 T
( 3) 517.36 632.67 T
(1.2.) 129.6 619.67 T
(Outline of Dissertation) 165.6 619.67 T
(..........................................................................................) 269.17 619.67 T
( 3) 517.36 619.67 T
(1.3.) 129.6 606.67 T
(Contributions) 165.6 606.67 T
(........................................................................................................) 230.71 606.67 T
( 5) 517.36 606.67 T
0 12 Q
(CHAPTER 1. Background) 108 581 T
1 F
(..........................................................................................) 248.86 581 T
(6) 519.6 581 T
1 11 Q
(1.1.) 129.6 561.67 T
(The Distributed Cache State Recovery Problem) 165.6 561.67 T
(..................................................) 379.03 561.67 T
( 6) 517.36 561.67 T
(1.1.1.) 129.6 548.67 T
(NFS) 172.8 548.67 T
(....................................................................................................................) 197.75 548.67 T
( 7) 517.36 548.67 T
(1.1.2.) 129.6 535.67 T
(Client Caching in Sprite) 172.8 535.67 T
(.....................................................................................) 282.9 535.67 T
( 8) 517.36 535.67 T
(1.1.3.) 129.6 522.67 T
(Sprite\325s Cache Consistency Policy) 172.8 522.67 T
(....................................................................) 329.59 522.67 T
( 9) 517.36 522.67 T
(1.1.4.) 129.6 509.67 T
(Sprite\325s Distributed Cache State Recovery Problem) 172.8 509.67 T
(.......................................) 403.75 509.67 T
( 14) 511.87 509.67 T
(1.1.5.) 129.6 496.67 T
(Spritely NFS) 172.8 496.67 T
(.....................................................................................................) 233.46 496.67 T
( 15) 511.87 496.67 T
(1.1.6.) 129.6 483.67 T
(DEcorum) 172.8 483.67 T
(..........................................................................................................) 219.73 483.67 T
( 16) 511.87 483.67 T
(1.1.7.) 129.6 470.67 T
(Echo) 172.8 470.67 T
(.................................................................................................................) 200.5 470.67 T
( 17) 511.87 470.67 T
(1.2.) 129.6 457.67 T
(Providing High Availability) 165.6 457.67 T
(...............................................................................) 293.88 457.67 T
( 19) 511.87 457.67 T
(1.2.1.) 129.6 444.67 T
(Error Repair) 172.8 444.67 T
(.....................................................................................................) 233.46 444.67 T
( 20) 511.87 444.67 T
1 12 Q
(1.2.1.1.) 129.6 431 T
(Integrity S2) 180 431 T
(.........................................................................................) 242.87 431 T
( 20) 510.61 431 T
(1.2.1.2.) 129.6 417 T
(5ESS) 180 417 T
(....................................................................................................) 209.88 417 T
( 21) 510.61 417 T
1 11 Q
(1.2.2.) 129.6 403.67 T
(Redundancy for Masking Faults) 172.8 403.67 T
(......................................................................) 318.6 403.67 T
( 21) 511.87 403.67 T
1 12 Q
(1.2.2.1.) 129.6 390 T
(Tandem NonStop Systems) 180 390 T
(..................................................................) 311.83 390 T
( 22) 510.61 390 T
(1.2.2.2.) 129.6 376 T
(TARGON/32) 180 376 T
(.......................................................................................) 248.86 376 T
( 23) 510.61 376 T
(1.2.2.3.) 129.6 362 T
(Stratus) 180 362 T
(.................................................................................................) 218.88 362 T
( 25) 510.61 362 T
(1.2.2.4.) 129.6 348 T
(Zebra) 180 348 T
(...................................................................................................) 212.88 348 T
( 25) 510.61 348 T
(1.2.2.5.) 129.6 334 T
(ISIS) 180 334 T
(.....................................................................................................) 206.89 334 T
( 27) 510.61 334 T
1 11 Q
(1.2.3.) 129.6 320.67 T
(Transactional Systems) 172.8 320.67 T
(.....................................................................................) 277.4 320.67 T
( 27) 511.87 320.67 T
1 12 Q
(1.2.3.1.) 129.6 307 T
(LOCUS) 180 307 T
(...............................................................................................) 224.88 307 T
( 28) 510.61 307 T
(1.2.3.2.) 129.6 293 T
(QuickSilver) 180 293 T
(.........................................................................................) 242.87 293 T
( 29) 510.61 293 T
1 11 Q
(1.3.) 129.6 279.67 T
(Recovery Using State Information Stored in Main Memory) 165.6 279.67 T
(.............................) 431.21 279.67 T
( 29) 511.87 279.67 T
(1.3.1.) 129.6 266.67 T
(Phoenix) 172.8 266.67 T
(............................................................................................................) 214.23 266.67 T
( 31) 511.87 266.67 T
(1.3.2.) 129.6 253.67 T
(Harp) 172.8 253.67 T
(..................................................................................................................) 197.75 253.67 T
( 31) 511.87 253.67 T
(1.4.) 129.6 240.67 T
(Summary) 165.6 240.67 T
(.............................................................................................................) 211.49 240.67 T
( 31) 511.87 240.67 T
0 12 Q
(CHAPTER 3. Client-Driven Recovery) 108 215 T
1 F
(....................................................................) 308.83 215 T
(34) 513.61 215 T
1 11 Q
(3.1.) 129.6 195.67 T
(How Client-Driven Recovery Works) 165.6 195.67 T
(.................................................................) 332.34 195.67 T
( 35) 511.87 195.67 T
(3.1.1.) 129.6 182.67 T
(Detecting Server Crashes and Reboots) 172.8 182.67 T
(............................................................) 346.07 182.67 T
( 35) 511.87 182.67 T
(3.1.2.) 129.6 169.67 T
(Client State Recovery) 172.8 169.67 T
(......................................................................................) 274.66 169.67 T
( 36) 511.87 169.67 T
(3.1.3.) 129.6 156.67 T
(Restarting Hung Client Processes) 172.8 156.67 T
(....................................................................) 324.1 156.67 T
( 38) 511.87 156.67 T
(3.1.4.) 129.6 143.67 T
(File System State Recovery on the Server) 172.8 143.67 T
(.......................................................) 359.8 143.67 T
( 39) 511.87 143.67 T
(3.2.) 129.6 130.67 T
(Client Cache and File System State) 165.6 130.67 T
(....................................................................) 324.1 130.67 T
( 40) 511.87 130.67 T
(3.3.) 129.6 117.67 T
(Measurement Setup) 165.6 117.67 T
(............................................................................................) 258.18 117.67 T
( 42) 511.87 117.67 T
(3.4.) 129.6 104.67 T
(Sources of and Solutions to File Server Contention) 165.6 104.67 T
(...........................................) 392.76 104.67 T
( 44) 511.87 104.67 T
(3.4.1.) 129.6 91.67 T
(Server Contention) 172.8 91.67 T
(............................................................................................) 258.18 91.67 T
( 45) 511.87 91.67 T
FMENDPAGE
%%EndPage: "v" 6
%%Page: "vi" 6
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(vi) 283.33 55 T
1 11 Q
(3.4.2.) 93.6 712.67 T
(Solving the Contention Problem) 136.8 712.67 T
(......................................................................) 282.9 712.67 T
( 45) 475.87 712.67 T
(3.4.3.) 93.6 699.67 T
(Synchronized Client Recovery Requests) 136.8 699.67 T
(.........................................................) 318.6 699.67 T
( 49) 475.87 699.67 T
(3.4.4.) 93.6 686.67 T
(Staggering Client Recovery Requests) 136.8 686.67 T
(..............................................................) 304.87 686.67 T
( 51) 475.87 686.67 T
(3.5.) 93.6 673.67 T
(Other Performance Problems and Solutions) 129.6 673.67 T
(.......................................................) 324.1 673.67 T
( 52) 475.87 673.67 T
(3.5.1.) 93.6 660.67 T
(Eliminating Unnecessary State Recovery) 136.8 660.67 T
(........................................................) 321.35 660.67 T
( 54) 475.87 660.67 T
(3.5.2.) 93.6 647.67 T
(Batching Reopens) 136.8 647.67 T
(............................................................................................) 222.47 647.67 T
( 55) 475.87 647.67 T
(3.5.3.) 93.6 634.67 T
(Basic Client-Driven Recovery Performance) 136.8 634.67 T
(....................................................) 332.34 634.67 T
( 55) 475.87 634.67 T
(3.6.) 93.6 621.67 T
(Other Client-Driven Recovery Problems) 129.6 621.67 T
(............................................................) 310.36 621.67 T
( 56) 475.87 621.67 T
(3.6.1.) 93.6 608.67 T
(Cache Consistency Violations) 136.8 608.67 T
(.........................................................................) 274.66 608.67 T
( 56) 475.87 608.67 T
(3.6.2.) 93.6 595.67 T
(Waiting for Clients to Contact the Server) 136.8 595.67 T
(........................................................) 321.35 595.67 T
( 56) 475.87 595.67 T
(3.7.) 93.6 582.67 T
(Summary) 129.6 582.67 T
(.............................................................................................................) 175.78 582.67 T
( 56) 475.87 582.67 T
0 12 Q
(CHAPTER 4. Server-Driven Recovery) 72 557 T
1 F
(....................................................................) 272.85 557 T
(57) 477.61 557 T
1 11 Q
(4.1.) 93.6 537.67 T
(Design and Implementation) 129.6 537.67 T
(................................................................................) 255.43 537.67 T
( 58) 475.87 537.67 T
(4.1.1.) 93.6 524.67 T
(Performance Impact of Client List Updates) 136.8 524.67 T
(.....................................................) 329.59 524.67 T
( 58) 475.87 524.67 T
(4.1.2.) 93.6 511.67 T
(Maintaining and Recovering From the Client List) 136.8 511.67 T
(..........................................) 359.8 511.67 T
( 59) 475.87 511.67 T
(4.1.3.) 93.6 498.67 T
(List Format and Atomic Update) 136.8 498.67 T
(.......................................................................) 280.15 498.67 T
( 61) 475.87 498.67 T
(4.2.) 93.6 485.67 T
(Problems with Server-Driven Recovery) 129.6 485.67 T
(.............................................................) 307.62 485.67 T
( 63) 475.87 485.67 T
(4.2.1.) 93.6 472.67 T
(Special-Purpose Recovery Code) 136.8 472.67 T
(......................................................................) 282.9 472.67 T
( 63) 475.87 472.67 T
(4.2.2.) 93.6 459.67 T
(The Slow-Client Problem) 136.8 459.67 T
(.................................................................................) 252.69 459.67 T
( 63) 475.87 459.67 T
(4.2.3.) 93.6 446.67 T
(The Too-Many-Clients Problem) 136.8 446.67 T
(......................................................................) 282.9 446.67 T
( 64) 475.87 446.67 T
(4.2.4.) 93.6 433.67 T
(Synchronization and Locking) 136.8 433.67 T
(..........................................................................) 271.91 433.67 T
( 64) 475.87 433.67 T
(4.2.5.) 93.6 420.67 T
(Robustness Versus Simplicity) 136.8 420.67 T
(..........................................................................) 271.91 420.67 T
( 67) 475.87 420.67 T
(4.3.) 93.6 407.67 T
(Results and Measurements) 129.6 407.67 T
(.................................................................................) 252.69 407.67 T
( 68) 475.87 407.67 T
(4.4.) 93.6 394.67 T
(Summary) 129.6 394.67 T
(.............................................................................................................) 175.78 394.67 T
( 73) 475.87 394.67 T
0 12 Q
(CHAPTER 5. Transparent Recovery) 72 369 T
1 F
(......................................................................) 266.85 369 T
(74) 477.61 369 T
1 11 Q
(5.1.) 93.6 349.67 T
(Motivation for the Recovery Box) 129.6 349.67 T
(.......................................................................) 280.15 349.67 T
( 75) 475.87 349.67 T
(5.1.1.) 93.6 336.67 T
(Storing Distributed State) 136.8 336.67 T
(..................................................................................) 249.94 336.67 T
( 76) 475.87 336.67 T
1 12 Q
(5.1.1.1.) 93.6 323 T
(Disk Storage) 144 323 T
(........................................................................................) 209.88 323 T
( 76) 474.61 323 T
(5.1.1.2.) 93.6 309 T
(Backup Machine Storage) 144 309 T
(....................................................................) 269.85 309 T
( 77) 474.61 309 T
1 11 Q
(5.1.2.) 93.6 295.67 T
(Error Statistics) 136.8 295.67 T
(..................................................................................................) 205.99 295.67 T
( 78) 475.87 295.67 T
(5.1.3.) 93.6 282.67 T
(Write Protection) 136.8 282.67 T
(...............................................................................................) 214.23 282.67 T
( 82) 475.87 282.67 T
(5.2.) 93.6 269.67 T
(Design and Implementation) 129.6 269.67 T
(................................................................................) 255.43 269.67 T
( 83) 475.87 269.67 T
(5.2.1.) 93.6 256.67 T
(Interface) 136.8 256.67 T
(...........................................................................................................) 181.27 256.67 T
( 83) 475.87 256.67 T
(5.2.2.) 93.6 243.67 T
(Recovery Box Structure) 136.8 243.67 T
(...................................................................................) 247.19 243.67 T
( 85) 475.87 243.67 T
(5.2.3.) 93.6 230.67 T
(Implementation Shortcomings) 136.8 230.67 T
(.........................................................................) 274.66 230.67 T
( 89) 475.87 230.67 T
(5.3.) 93.6 217.67 T
(How Sprite Uses the Recovery Box) 129.6 217.67 T
(...................................................................) 291.14 217.67 T
( 90) 475.87 217.67 T
(5.4.) 93.6 204.67 T
(Results and Measurements) 129.6 204.67 T
(.................................................................................) 252.69 204.67 T
( 92) 475.87 204.67 T
(5.4.1.) 93.6 191.67 T
(Recovery Times) 136.8 191.67 T
(...............................................................................................) 214.23 191.67 T
( 92) 475.87 191.67 T
(5.4.2.) 93.6 178.67 T
(File System Overhead) 136.8 178.67 T
(......................................................................................) 238.95 178.67 T
( 94) 475.87 178.67 T
(5.5.) 93.6 165.67 T
(Disadvantages of Transparent Recovery) 129.6 165.67 T
(............................................................) 310.36 165.67 T
( 96) 475.87 165.67 T
(5.6.) 93.6 152.67 T
(File System Trends and Their Implications) 129.6 152.67 T
(........................................................) 321.35 152.67 T
( 99) 475.87 152.67 T
(5.6.1.) 93.6 139.67 T
(Logging Asynchronous Directory Operations) 136.8 139.67 T
(...............................................) 340.58 139.67 T
( 100) 470.37 139.67 T
(5.6.2.) 93.6 126.67 T
(Stateful File Servers) 136.8 126.67 T
(.......................................................................................) 230.71 126.67 T
( 101) 470.37 126.67 T
(5.7.) 93.6 113.67 T
(Applicability to Other Systems) 129.6 113.67 T
(.........................................................................) 269.17 113.67 T
( 101) 470.37 113.67 T
(5.8.) 93.6 100.67 T
(Application Use of Recovery Box) 129.6 100.67 T
(....................................................................) 282.9 100.67 T
( 101) 470.37 100.67 T
(5.8.1.) 93.6 87.67 T
(How POSTGRES Uses the Recovery Box) 136.8 87.67 T
(....................................................) 326.84 87.67 T
( 102) 470.37 87.67 T
FMENDPAGE
%%EndPage: "vi" 7
%%Page: "vii" 7
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(vii) 317.67 55 T
1 11 Q
(5.8.2.) 129.6 712.67 T
(POSTGRES Performance with the Recovery Box) 172.8 712.67 T
(........................................) 395.51 712.67 T
( 103) 506.37 712.67 T
(5.9.) 129.6 699.67 T
(Summary) 165.6 699.67 T
(...........................................................................................................) 211.49 699.67 T
( 104) 506.37 699.67 T
0 12 Q
(CHAPTER 6. Other Fast Reboot Techniques) 108 674 T
1 F
(.......................................................) 341.81 674 T
(105) 507.61 674 T
1 11 Q
(6.1.) 129.6 654.67 T
(Reusing Text and Initialized Data) 165.6 654.67 T
(....................................................................) 318.6 654.67 T
( 105) 506.37 654.67 T
(6.2.) 129.6 641.67 T
(Using Pre-Computed Values) 165.6 641.67 T
(............................................................................) 296.63 641.67 T
( 107) 506.37 641.67 T
(6.3.) 129.6 628.67 T
(Using LFS) 165.6 628.67 T
(.........................................................................................................) 216.98 628.67 T
( 108) 506.37 628.67 T
(6.4.) 129.6 615.67 T
(Recovering Distributed State) 165.6 615.67 T
(............................................................................) 296.63 615.67 T
( 109) 506.37 615.67 T
(6.5.) 129.6 602.67 T
(Delaying Daemon Start-Up) 165.6 602.67 T
(..............................................................................) 291.14 602.67 T
( 110) 506.37 602.67 T
(6.6.) 129.6 589.67 T
(Further Improving Reboot Times) 165.6 589.67 T
(.....................................................................) 315.86 589.67 T
( 110) 506.37 589.67 T
(6.7.) 129.6 576.67 T
(Summary) 165.6 576.67 T
(...........................................................................................................) 211.49 576.67 T
( 110) 506.37 576.67 T
0 12 Q
(CHAPTER 7. Designing for Fast Crash Recovery) 108 551 T
1 F
(...............................................) 365.8 551 T
(111) 507.61 551 T
1 11 Q
(7.1.) 129.6 531.67 T
(Recovery Stress) 165.6 531.67 T
(................................................................................................) 241.7 531.67 T
( 111) 506.37 531.67 T
(7.2.) 129.6 518.67 T
(Start-Up Overhead) 165.6 518.67 T
(............................................................................................) 252.69 518.67 T
( 112) 506.37 518.67 T
(7.3.) 129.6 505.67 T
(Using Main Memory) 165.6 505.67 T
(........................................................................................) 263.67 505.67 T
( 112) 506.37 505.67 T
(7.4.) 129.6 492.67 T
(Maintaining Correct Distributed State Information) 165.6 492.67 T
(..........................................) 390.02 492.67 T
( 112) 506.37 492.67 T
(7.4.1.) 129.6 479.67 T
(Managing State Recovery With More State) 172.8 479.67 T
(..................................................) 368.04 479.67 T
( 113) 506.37 479.67 T
(7.4.2.) 129.6 466.67 T
(Careful Bookkeeping) 172.8 466.67 T
(.....................................................................................) 271.91 466.67 T
( 113) 506.37 466.67 T
(7.4.3.) 129.6 453.67 T
(Tools for Debugging Distributed State) 172.8 453.67 T
(..........................................................) 346.07 453.67 T
( 114) 506.37 453.67 T
(7.4.4.) 129.6 440.67 T
(Isolating State Changes) 172.8 440.67 T
(..................................................................................) 280.15 440.67 T
( 114) 506.37 440.67 T
(7.5.) 129.6 427.67 T
(Debugging Recovery Code) 165.6 427.67 T
(...............................................................................) 288.39 427.67 T
( 115) 506.37 427.67 T
(7.6.) 129.6 414.67 T
(Summary) 165.6 414.67 T
(...........................................................................................................) 211.49 414.67 T
( 115) 506.37 414.67 T
0 12 Q
(CHAPTER 8. Conclusion) 108 389 T
1 F
(........................................................................................) 242.87 389 T
(117) 507.61 389 T
1 11 Q
(8.1.) 129.6 369.67 T
(Results) 165.6 369.67 T
(..............................................................................................................) 203.25 369.67 T
( 117) 506.37 369.67 T
(8.2.) 129.6 356.67 T
(Future Work) 165.6 356.67 T
(......................................................................................................) 225.22 356.67 T
( 119) 506.37 356.67 T
(8.2.1.) 129.6 343.67 T
(Other Metrics for Comparing State Recovery Techniques) 172.8 343.67 T
(............................) 428.47 343.67 T
( 119) 506.37 343.67 T
(8.2.2.) 129.6 330.67 T
(Long-Term Evaluation of the Recovery Box) 172.8 330.67 T
(.................................................) 370.79 330.67 T
( 119) 506.37 330.67 T
(8.2.3.) 129.6 317.67 T
(Long-Term Evaluation of Fast Recovery) 172.8 317.67 T
(......................................................) 357.06 317.67 T
( 119) 506.37 317.67 T
(8.2.4.) 129.6 304.67 T
(Evaluation of Complexity) 172.8 304.67 T
(..............................................................................) 291.14 304.67 T
( 119) 506.37 304.67 T
(8.2.5.) 129.6 291.67 T
(Side-Effects of Fast Recovery) 172.8 291.67 T
(.......................................................................) 310.36 291.67 T
( 120) 506.37 291.67 T
(8.2.6.) 129.6 278.67 T
(Improved Crash Diagnostics) 172.8 278.67 T
(..........................................................................) 302.12 278.67 T
( 120) 506.37 278.67 T
(8.2.7.) 129.6 265.67 T
(Using the Recovery Box for Applications) 172.8 265.67 T
(.....................................................) 359.8 265.67 T
( 120) 506.37 265.67 T
(8.2.8.) 129.6 252.67 T
(Fast Application Page-In) 172.8 252.67 T
(................................................................................) 285.64 252.67 T
( 121) 506.37 252.67 T
(8.3.) 129.6 239.67 T
(Final Comments) 165.6 239.67 T
(................................................................................................) 241.7 239.67 T
( 121) 506.37 239.67 T
FMENDPAGE
%%EndPage: "vii" 8
%%Page: "viii" 8
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(viii) 281.15 55 T
0 18 Q
(List of Figur) 232.2 708 T
(es) 328.82 708 T
1 11 Q
(Figure 2-1.) 93.6 652.67 T
(Client-server distributed \336le system.) 162 652.67 T
(...........................................................) 324.1 652.67 T
( 7) 488.56 652.67 T
(Figure 2-2.) 93.6 637.67 T
(Sequential and concurrent write-sharing.) 162 637.67 T
(..................................................) 343.32 637.67 T
( 10) 483.07 637.67 T
(Figure 2-3.) 93.6 622.67 T
(Sprite cache consistency call-backs.) 162 622.67 T
(..........................................................) 321.35 622.67 T
( 12) 483.07 622.67 T
(Figure 2-4.) 93.6 607.67 T
(The Echo system.) 162 607.67 T
(.......................................................................................) 241.7 607.67 T
( 18) 483.07 607.67 T
(Figure 2-5.) 93.6 592.67 T
(T) 162 592.67 T
(ARGON system architecture.) 167.83 592.67 T
(..................................................................) 299.38 592.67 T
( 24) 483.07 592.67 T
(Figure 2-6.) 93.6 577.67 T
(File striping and parity blocks in Zebra.) 162 577.67 T
(....................................................) 337.83 577.67 T
( 26) 483.07 577.67 T
(Figure 2-7.) 93.6 562.67 T
(Comparison of fault-tolerant and fast recovery approaches.) 162 562.67 T
(.....................) 422.97 562.67 T
( 33) 483.07 562.67 T
(Figure 3-1.) 93.6 547.67 T
(Client-driven recovery in Sprite.) 162 547.67 T
(................................................................) 304.87 547.67 T
( 37) 483.07 547.67 T
(Figure 3-2.) 93.6 532.67 T
(The system after recovery) 162 532.67 T
(.) 275.69 532.67 T
(.........................................................................) 280.15 532.67 T
( 38) 483.07 532.67 T
(Figure 3-3.) 93.6 517.67 T
(Recovery storm in Sprite.) 162 517.67 T
(..........................................................................) 277.4 517.67 T
( 46) 483.07 517.67 T
(Figure 3-4.) 93.6 502.67 T
(Recovery storm behavior) 162 502.67 T
(.) 272.46 502.67 T
(..........................................................................) 277.4 502.67 T
( 47) 483.07 502.67 T
(Figure 3-5.) 93.6 487.67 T
(Recovery with server NACKs.) 162 487.67 T
(..................................................................) 299.38 487.67 T
( 49) 483.07 487.67 T
(Figure 3-6.) 93.6 472.67 T
(Recovery storm in testbed setup.) 162 472.67 T
(...............................................................) 307.62 472.67 T
( 50) 483.07 472.67 T
(Figure 3-7.) 93.6 457.67 T
(Recovery with NACKS in testbed setup.) 162 457.67 T
(...................................................) 340.58 457.67 T
( 51) 483.07 457.67 T
(Figure 3-8.) 93.6 442.67 T
(Synchronization of client recovery) 162 442.67 T
(.) 313.53 442.67 T
(...........................................................) 318.6 442.67 T
( 52) 483.07 442.67 T
(Figure 3-9.) 93.6 427.67 T
(How client recovery becomes synchronized.) 162 427.67 T
(.............................................) 357.06 427.67 T
( 53) 483.07 427.67 T
(Figure 3-10.) 93.6 412.67 T
(Staggered client recovery) 162 412.67 T
(.) 273.55 412.67 T
(..........................................................................) 277.4 412.67 T
( 54) 483.07 412.67 T
(Figure 4-1.) 93.6 397.67 T
(User) 162 397.67 T
(-level daemon updates active client list.) 182.52 397.67 T
(.............................................) 357.06 397.67 T
( 60) 483.07 397.67 T
(Figure 4-2.) 93.6 382.67 T
(The kernel uses the active client list for recovery) 162 382.67 T
(.) 375.46 382.67 T
(.....................................) 379.03 382.67 T
( 61) 483.07 382.67 T
(Figure 4-3.) 93.6 367.67 T
(Client list format.) 162 367.67 T
(.......................................................................................) 241.7 367.67 T
( 62) 483.07 367.67 T
(Figure 4-4.) 93.6 352.67 T
(Server) 162 352.67 T
(-driven state recovery by number of clients.) 190.46 352.67 T
(...................................) 384.52 352.67 T
( 69) 483.07 352.67 T
(Figure 4-5.) 93.6 337.67 T
(Disk utilization during server) 162 337.67 T
(-driven state recovery) 290.86 337.67 T
(.) 385.93 337.67 T
(.................................) 390.02 337.67 T
( 70) 483.07 337.67 T
(Figure 4-6.) 93.6 322.67 T
(CPU utilization during server) 162 322.67 T
(-driven state recovery) 291.47 322.67 T
(.) 386.55 322.67 T
(.................................) 390.02 322.67 T
( 71) 483.07 322.67 T
(Figure 5-1.) 93.6 307.67 T
(Percentage of random addressing errors.) 162 307.67 T
(...................................................) 340.58 307.67 T
( 82) 483.07 307.67 T
(Figure 5-2.) 93.6 292.67 T
(Layout of recovery box in memory) 162 292.67 T
(.) 315.37 292.67 T
(...........................................................) 318.6 292.67 T
( 86) 483.07 292.67 T
(Figure 5-3.) 93.6 277.67 T
(Contents of type array) 162 277.67 T
(.) 259.23 277.67 T
(...............................................................................) 263.67 277.67 T
( 87) 483.07 277.67 T
(Figure 5-4.) 93.6 262.67 T
(Contents of item information array) 162 262.67 T
(.) 314.47 262.67 T
(...........................................................) 318.6 262.67 T
( 88) 483.07 262.67 T
(Figure 5-5.) 93.6 247.67 T
(T) 162 247.67 T
(ransparent recovery by number of clients.) 168.33 247.67 T
(...............................................) 351.56 247.67 T
( 93) 483.07 247.67 T
(Figure 5-6.) 93.6 232.67 T
(Disk utilization during transparent recovery) 162 232.67 T
(.) 353.51 232.67 T
(.............................................) 357.06 232.67 T
( 94) 483.07 232.67 T
(Figure 5-7.) 93.6 217.67 T
(CPU utilization during transparent recovery) 162 217.67 T
(.) 354.13 217.67 T
(.............................................) 357.06 217.67 T
( 95) 483.07 217.67 T
FMENDPAGE
%%EndPage: "viii" 9
%%Page: "ix" 9
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(ix) 319.33 55 T
0 18 Q
(List of T) 271.77 708 T
(ables) 336.09 708 T
1 11 Q
(T) 129.6 652.67 T
(able 2-1.) 135.54 652.67 T
(Stale data errors.) 198 652.67 T
(........................................................................................) 274.66 652.67 T
( 13) 519.07 652.67 T
(T) 129.6 637.67 T
(able 2-2.) 135.54 637.67 T
(Consistency action frequency) 198 637.67 T
(.) 327.27 637.67 T
(...................................................................) 332.34 637.67 T
( 14) 519.07 637.67 T
(T) 129.6 622.67 T
(able 3-1.) 135.54 622.67 T
(State information sent from clients to the server for recovery) 198 622.67 T
(.) 463.65 622.67 T
(..................) 466.92 622.67 T
( 39) 519.07 622.67 T
(T) 129.6 607.67 T
(able 3-2.) 135.54 607.67 T
(Amount of state information on clients.) 198 607.67 T
(....................................................) 373.54 607.67 T
( 41) 519.07 607.67 T
(T) 129.6 592.67 T
(able 3-3.) 135.54 592.67 T
(Status of \336le I/O handles on Sprite clients) 198 592.67 T
(.................................................) 381.77 592.67 T
( 41) 519.07 592.67 T
(T) 129.6 577.67 T
(able 3-4.) 135.54 577.67 T
(Amount of \336le sharing on clients.) 198 577.67 T
(..............................................................) 346.07 577.67 T
( 42) 519.07 577.67 T
(T) 129.6 562.67 T
(able 3-5.) 135.54 562.67 T
(Basic testbed recovery state setup.) 198 562.67 T
(............................................................) 351.56 562.67 T
( 44) 519.07 562.67 T
(T) 129.6 547.67 T
(able 4-1.) 135.54 547.67 T
(List of blocked RPCs.) 198 547.67 T
(................................................................................) 296.63 547.67 T
( 65) 519.07 547.67 T
(T) 129.6 532.67 T
(able 4-2.) 135.54 532.67 T
(List of Unblocked RPCs.) 198 532.67 T
(...........................................................................) 310.36 532.67 T
( 66) 519.07 532.67 T
(T) 129.6 517.67 T
(able 4-3.) 135.54 517.67 T
(Other server) 198 517.67 T
(-driven state recovery tests.) 252.38 517.67 T
(....................................................) 373.54 517.67 T
( 72) 519.07 517.67 T
(T) 129.6 502.67 T
(able 5-1.) 135.54 502.67 T
(Distribution of outage types.) 198 502.67 T
(......................................................................) 324.1 502.67 T
( 79) 519.07 502.67 T
(T) 129.6 487.67 T
(able 5-2.) 135.54 487.67 T
(Software error type distributions.) 198 487.67 T
(..............................................................) 346.07 487.67 T
( 80) 519.07 487.67 T
(T) 129.6 472.67 T
(able 5-3.) 135.54 472.67 T
(Data corrupted by addressing errors.) 198 472.67 T
(.........................................................) 359.8 472.67 T
( 81) 519.07 472.67 T
(T) 129.6 457.67 T
(able 5-4.) 135.54 457.67 T
(Recovery box operations.) 198 457.67 T
(..........................................................................) 313.11 457.67 T
( 84) 519.07 457.67 T
(T) 129.6 442.67 T
(able 5-5.) 135.54 442.67 T
(Components of distributed cache state items.) 198 442.67 T
(............................................) 395.51 442.67 T
( 91) 519.07 442.67 T
(T) 129.6 427.67 T
(able 5-6.) 135.54 427.67 T
(T) 198 427.67 T
(ransparent recovery time and component times.) 204.33 427.67 T
(.....................................) 414.73 427.67 T
( 96) 519.07 427.67 T
(T) 129.6 412.67 T
(able 5-7.) 135.54 412.67 T
(Sprite recovery box performance.) 198 412.67 T
(..............................................................) 346.07 412.67 T
( 97) 519.07 412.67 T
(T) 129.6 397.67 T
(able 5-8.) 135.54 397.67 T
(POSTGRES recovery box performance.) 198 397.67 T
(.................................................) 376.28 397.67 T
( 104) 513.57 397.67 T
(T) 129.6 382.67 T
(able 6-1.) 135.54 382.67 T
(Server reboot steps and timings.) 198 382.67 T
(..............................................................) 340.58 382.67 T
( 106) 513.57 382.67 T
(T) 129.6 367.67 T
(able 6-2.) 135.54 367.67 T
(Size and initialization times for Sprite kernel segments.) 198 367.67 T
(.........................) 442.2 367.67 T
( 107) 513.57 367.67 T
(T) 129.6 352.67 T
(able 7-1.) 135.54 352.67 T
(Fast crash recovery design techniques.) 198 352.67 T
(.....................................................) 368.04 352.67 T
( 1) 513.98 352.67 T
(16) 521.81 352.67 T
(T) 129.6 337.67 T
(able 8-1.) 135.54 337.67 T
(Evaluation of distributed state recovery techniques.) 198 337.67 T
(................................) 425.72 337.67 T
( 1) 513.98 337.67 T
(18) 521.81 337.67 T
FMENDPAGE
%%EndPage: "ix" 10
%%Page: "x" 10
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(x) 285 55 T
72 666 504 720 C
72 666 504 720 R
7 X
0 K
V
72 693 504 693 2 L
0.5 H
2 Z
0 X
N
0 0 612 792 C
72 594 504 648 C
72 594 504 648 R
7 X
0 K
V
72 603 504 603 2 L
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 18 Q
0 X
0 K
(Acknowledgments) 144 654 T
1 11 Q
0.93 (During my years in graduate school many people have given me their support, guidance, and) 82.8 519.67 P
0.92 (friendship. Foremost among these people is my advisor) 72 506.67 P
0.92 (, John Ousterhout. He has taught me the) 321.5 506.67 P
0.73 (value of good design, hard work, and clear thinking. He applies his great creative and analytical) 72 493.67 P
0.55 (skills with patience, encouragement, generosity) 72 480.67 P
0.55 (, and an outrageous sense of humor) 282.17 480.67 P
0.55 (. I am exceed-) 440.14 480.67 P
(ingly lucky to have had such a conscientious and inspirational advisor) 72 467.67 T
(.) 378.98 467.67 T
-0.16 (I would also like to thank the other readers of this thesis, Randy Katz and Rainer Sachs, for their) 82.8 442.67 P
-0.07 (detailed and thoughtful comments. My interactions with Randy Katz in his classes and through his) 72 429.67 P
2.77 (RAID project have always been very rewarding. His enthusiastic and practical approach to) 72 416.67 P
0.05 (research is contagious. I have been fortunate to take courses from Rainer Sachs in both the mathe-) 72 403.67 P
-0.23 (matics and physics departments. W) 72 390.67 P
-0.23 (ithout his knowing it, his excellent teaching was responsible for) 225.95 390.67 P
(my decision to come to Berkeley) 72 377.67 T
(.) 216.23 377.67 T
-0.26 (The other professors involved with the RAID project deserve my special thanks: T) 82.8 352.67 P
-0.26 (om Anderson,) 442.01 352.67 P
0.49 (Dave Patterson, and Mike Stonebraker) 72 339.67 P
0.49 (. They have been tireless with their help and advice. I also) 243.28 339.67 P
(thank Alan Smith for his careful answers to several technical questions.) 72 326.67 T
-0.13 (T) 82.8 301.67 P
-0.13 (erry Lessard-Smith, Bob Miller) 88.74 301.67 P
-0.13 (, Kathryn Crabtree, and Heather Brown have all saved me from) 226.45 301.67 P
1.56 (numerous disasters with quick, cheerful, and expert help. I can\325) 72 288.67 P
1.56 (t imagine what I\325ll do without) 364.68 288.67 P
(them.) 72 275.67 T
-0.19 (The inhabitants of 477 Evans have been a joy to work with. Antony Ng, Ari Juels, Fred Douglis,) 82.8 250.67 P
0.18 (Ken Shirrif) 72 237.67 P
0.18 (f, and John Hartman ener) 121.71 237.67 P
0.18 (getically debated subjects ranging from the state of the world) 233.59 237.67 P
0.93 (to the perfect chocolate. Ken\325) 72 224.67 P
0.93 (s 1 AM conference hot tub cookies have justi\336ably become world) 205.4 224.67 P
0.1 (famous, and John has answered endless technical questions with wisdom and patience. I owe a lot) 72 211.67 P
0.25 (to him, including such terms from his sparkling dialect as \322bonehead\323 and \322a few beers short of a) 72 198.67 P
(six-pack.\323) 72 185.67 T
0.59 (I also owe a lar) 82.8 160.67 P
0.59 (ge debt to the other members of the Sprite project: Brent W) 152.08 160.67 P
0.59 (elch, Mike Nelson,) 419.21 160.67 P
0.37 (Fred Douglis, Andrew Cherenson, Adam de Boor) 72 147.67 P
0.37 (, Mendel Rosenblum, Bob Bruce, Mike Kupfer) 292.27 147.67 P
0.37 (,) 501.25 147.67 P
0.87 (John Hartman, Ken Shirrif) 72 134.67 P
0.87 (f, Geof) 191.58 134.67 P
0.87 (f V) 223.36 134.67 P
0.87 (oelker) 237.15 134.67 P
0.87 (, and Jim Mott-Smith. W) 264.16 134.67 P
0.87 (ithout them, Sprite wouldn\325) 377.07 134.67 P
0.87 (t) 500.95 134.67 P
0.3 (exist. Brent W) 72 121.67 P
0.3 (elch was particularly generous with his time and ideas as I began working on crash) 135.5 121.67 P
1.16 (recovery) 72 108.67 P
1.16 (. Mendel Rosenblum is a wonderful friend and mentor as well as a gifted researcher) 109.72 108.67 P
1.16 (. I) 493.68 108.67 P
(have learned a great deal from him and will continue to do so.) 72 95.67 T
FMENDPAGE
%%EndPage: "x" 11
%%Page: "xi" 11
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(xi) 319.33 55 T
1 11 Q
0.71 (Many researchers in industry and at other universities have helped me along the way) 118.8 712.67 P
0.71 (. I would) 499.22 712.67 P
0.15 (especially like to thank Mark W) 108 699.67 P
0.15 (eiser) 249.15 699.67 P
0.15 (, Jef) 269.45 699.67 P
0.15 (f Mogul, Dan Siewiorek, Anita Bor) 287.7 699.67 P
0.15 (g, Satya, Mike Kazar) 444.19 699.67 P
0.15 (,) 537.25 699.67 P
0.63 (T) 108 686.67 P
0.63 (im Mann, Ken Keller) 114.33 686.67 P
0.63 (, Barbara Liskov) 209.75 686.67 P
0.63 (, Greg Nelson, Brian Pawlowski, and Alex W) 283.82 686.67 P
0.63 (olf for their) 488.1 686.67 P
0.28 (contributions to my work and their encouragement. Many thanks to Dan for presenting me with a) 108 673.67 P
(copy of his in\336nitely useful book!) 108 660.67 T
0.4 (My parents and sister continue to of) 118.8 635.67 P
0.4 (fer unconditional love and support. Their combined under-) 279.06 635.67 P
0.8 (standing of art, music, writing, science, and engineering is truly impressive. No matter what my) 108 622.67 P
1.03 (question, they always point me in the right direction. They have also kindly kept to themselves) 108 609.67 P
0.64 (their astonishment that after years of studying computer science I still can\325) 108 596.67 P
0.64 (t help much when the) 442.85 596.67 P
-0.22 (Macintosh does something weird. I\325d also like to thank my grandmother) 108 583.67 P
-0.22 (, the rest of my family) 423.03 583.67 P
-0.22 (, and) 518.86 583.67 P
(my husband\325) 108 570.67 T
(s family for their determined and noisy rooting section!) 164.46 570.67 T
-0.19 (There are many others who have made these years a pleasure. Annette, Kaz and Sara W) 118.8 545.67 P
-0.19 (egmuller) 500.94 545.67 P
2.01 (have often lifted my spirits. Ann Drapeau, Marti Hearst, David Bacon, Mark Sullivan, Dixie) 108 532.67 P
1.34 (Baker) 108 519.67 P
1.34 (, Nick and Mindy Lai, Dave Hitz, Eric Allman, and Greg Couch all steadfastly provided) 133.8 519.67 P
-0.12 (good cheer) 108 506.67 P
-0.12 (. Marti Hearst answered many writing questions. Mark Sullivan bravely used the recov-) 155.78 506.67 P
0.64 (ery box implementation described in this thesis and gave me valuable feedback. Mar) 108 493.67 P
0.64 (go Seltzer) 487.39 493.67 P
0.64 (\325) 532.67 493.67 P
0.64 (s) 535.73 493.67 P
0.25 (awesome ener) 108 480.67 P
0.25 (gies have been immeasurable on both technical and confectionery projects. She is a) 170.59 480.67 P
0.24 (superior researcher) 108 467.67 P
0.24 (, teacher) 191.68 467.67 P
0.24 (, and chef, and also a devoted friend. Her con\336dence in me was some-) 228.7 467.67 P
-0.18 (times the only thing that kept me going. I have bene\336tted from Keith Bostic\325) 108 454.67 P
-0.18 (s technical know-how) 441.92 454.67 P
-0.18 (,) 537.25 454.67 P
1 (while his friendship and \322informative\323 mailings have given me a whole new perspective on the) 108 441.67 P
0.27 (world. T) 108 428.67 P
0.27 (o the folks at Hillegass house: thanks for many fun times, including mud in Ferndale and) 145.34 428.67 P
(our delicious Maglite barley wine.) 108 415.67 T
0.49 (Life here at Berkeley has been much improved by various other resources: Denis Kelly\325) 118.8 390.67 P
0.49 (s wine) 511.13 390.67 P
0.92 (tastings, T) 108 377.67 P
0.92 (ilden Park, the UC Botanical Gardens, the \336re trail, Akira Miike\325) 154.31 377.67 P
0.92 (s fabulous banquets,) 448.76 377.67 P
(the Nefeli Caf) 108 364.67 T
(f\217, MST3K, T) 170.04 364.67 T
(alk Soup, and V) 231.52 364.67 T
(illa-Lobos\325 Bachianas Brasileiras 2 and 5.) 301.66 364.67 T
-0.26 (Finally) 118.8 339.67 P
-0.26 (, I owe everything to my husband, W) 149.22 339.67 P
-0.26 (endell Baker) 309.77 339.67 P
-0.26 (. No matter how busy he is with his own) 364.74 339.67 P
0.95 (work, he always takes the time to listen, console, encourage, advise, and cook dinner) 108 326.67 P
0.95 (. He never) 492.64 326.67 P
-0.08 (seems to realize that he gives all and expects nothing in return. I hope I can begin to be as support-) 108 313.67 P
(ive of him as he has been of me.) 108 300.67 T
0.17 (This research has been funded by ARP) 118.8 275.67 P
0.17 (A grant N00600-93-C-2481, the California MICRO Pro-) 289.67 275.67 P
(gram, NFS grant CCR-89-00029, and NASA/DARP) 108 262.67 T
(A grant NAG2-591.) 337.39 262.67 T
FMENDPAGE
%%EndPage: "xi" 12
%%Page: "1" 12
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 285 55 T
72 666 504 720 C
72 666 504 720 R
7 X
0 K
V
72 693 504 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
72 594 504 648 C
72 594 504 648 R
7 X
0 K
V
72 603 504 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(1) 108 638 T
0 18 Q
(Intr) 144 654 T
(oduction) 174.65 654 T
1 11 Q
0.48 (Over the last ten years, networks of personal computers and workstations have replaced stand-) 82.8 519.67 P
0 (alone timesharing systems in most computing environments. Faster) 72 506.67 P
0 (, less expensive processors and) 367.6 506.67 P
-0.07 (improved network technology make distributed systems more cost-ef) 72 493.67 P
-0.07 (fective and \337exible than their) 375.52 493.67 P
0.32 (centralized predecessors. As an or) 72 480.67 P
0.32 (ganization grows, it is easier to add capacity gradually to a net-) 222.86 480.67 P
(work of computers than it is to a stand-alone system.) 72 467.67 T
0.77 (This change in technology has required a corresponding improvement in the performance and) 82.8 442.67 P
0.71 (behavior of operating systems designed for distributed environments. Early network \336le systems) 72 429.67 P
0.94 (were slow) 72 416.67 P
0.94 (, often because they lacked tools to manage and to take advantage of their distributed) 117.07 416.67 P
-0.26 (resources. For example, Sun\325) 72 403.67 P
-0.26 (s Network File System, NFS [Sandbe85], is slower than more modern) 199.05 403.67 P
0.98 (systems, because its \336le servers do not keep distributed state that describes how client worksta-) 72 390.67 P
0.55 (tions use their \336les. In contrast, modern distributed systems incorporate techniques for managing) 72 377.67 P
1.71 (distributed resources ef) 72 364.67 P
1.71 (\336ciently and transparently) 177.74 364.67 P
1.71 (.) 295.18 364.67 P
2 F
1.71 (Distributed state) 302.39 364.67 P
1 F
1.71 ( is a key management tool.) 377.65 364.67 P
-0.15 (Servers and clients keep information about the state of the distributed system and use this informa-) 72 351.67 P
(tion to control sharing of their resources.) 72 338.67 T
1.98 (Distributed state improves system performance and behavior) 82.8 313.67 P
1.98 (, because it makes information) 361.52 313.67 P
-0.06 (available locally to hosts in the network. This reduces their need to retrieve data from central serv-) 72 300.67 P
-0.27 (ers. For example, client workstations cache \336les in their main memories so they can access the \336les) 72 287.67 P
1.14 (quickly without re-reading them from a \336le server) 72 274.67 P
1.14 (. These cached \336les are a form of distributed) 299.34 274.67 P
0.13 (state, because the \336les\325 ultimate storage is actually on the server) 72 261.67 P
0.13 (. In turn, most modern \336le servers) 354.31 261.67 P
0.2 (keep distributed cache state that describes which clients are caching their \336les. They use this state) 72 248.67 P
(to guarantee coherence among the client \336le caches.) 72 235.67 T
0.89 (Unfortunately) 82.8 210.67 P
0.89 (, distributed state also makes crash recovery slower and more complex. When a) 143.72 210.67 P
0.1 (central resource such as a \336le server crashes, it loses the state information kept in its volatile main) 72 197.67 P
0.58 (memory) 72 184.67 P
0.58 (. If this information is necessary for correct system behavior) 107.9 184.67 P
0.58 (, the server must reconstruct) 377.51 184.67 P
0.39 (its distributed state before it continues to service client requests. For example, to guarantee cache) 72 171.67 P
0.76 (consistency after a failure, the server must reconstruct its distributed cache state. Reconstructing) 72 158.67 P
0.69 (distributed state often requires the server to communicate with each of its clients while handling) 72 145.67 P
1.43 (increased disk I/O and processing loads. State recovery can be one of the most inef) 72 132.67 P
1.43 (\336cient and) 456.49 132.67 P
(stressful of system tasks and reduces system availability by increasing downtime.) 72 119.67 T
FMENDPAGE
%%EndPage: "1" 13
%%Page: "2" 13
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(2) 321 55 T
1 11 Q
0.56 (This dissertation focuses on) 118.8 712.67 P
2 F
0.56 (distributed state r) 246.15 712.67 P
0.56 (ecovery) 325.01 712.67 P
1 F
0.56 (, particularly cache and \336le system state.) 358.45 712.67 P
0.05 (T) 108 699.67 P
0.05 (o provide higher system availability and manage distributed state more reliably we need ef) 113.94 699.67 P
0.05 (\336cient) 512.53 699.67 P
0.01 (and well-understood state recovery) 108 686.67 P
0.01 (. The dissertation evaluates three techniques for recovering dis-) 261.38 686.67 P
-0.06 (tributed cache and \336le system state. The primary goal is to increase recovery speed, but I also con-) 108 673.67 P
0.04 (sider the reliability) 108 660.67 P
0.04 (, cost, and complexity of the recovery techniques. W) 190.36 660.67 P
0.04 (ith good state management) 421.8 660.67 P
0.02 (and fast recovery techniques, high-performance) 108 647.67 P
2 F
0.02 (stateful) 320.45 647.67 P
1 F
0.02 ( systems \050systems that keep state\051 can pro-) 352.8 647.67 P
(vide availability as high as or better than that of lower) 108 634.67 T
(-performance) 345.17 634.67 T
2 F
(stateless) 407.09 634.67 T
1 F
( systems.) 444.32 634.67 T
2.12 (By combining fast state recovery with other fast recovery techniques, we can signi\336cantly) 118.8 609.67 P
0.25 (improve overall recovery times. In particular) 108 596.67 P
0.25 (, a disk storage manager such as LFS \050the Log-struc-) 305.89 596.67 P
-0.02 (tured File System\051 [Rosenb91] can recover the consistency of the \336le system on disk in only a few) 108 583.67 P
0.71 (seconds. This contrasts with traditional UNIX \336le systems that require tens of minutes to ensure) 108 570.67 P
-0.12 (\336le system consistency after a failure. By combining fast state recovery) 108 557.67 P
-0.12 (, LFS, and other fast recov-) 420.07 557.67 P
0.84 (ery techniques, the Sprite Distributed File System [Ouster88] recovers from crashes in under 30) 108 544.67 P
(seconds.) 108 531.67 T
0.37 (The faster a system recovers, the more available it is. In the limit, as recovery time approaches) 118.8 506.67 P
-0 (zero, a system with fast crash recovery is indistinguishable from a system that never crashes at all.) 108 493.67 P
0.12 (I believe we can design systems to recover from the majority of failures so quickly that the down-) 108 480.67 P
2.23 (time is hardly noticed. Therefore, this dissertation also explores optimizing the entire failure) 108 467.67 P
0.33 (recovery sequence and proposes) 108 454.67 P
2 F
0.33 ( fast crash r) 250.85 454.67 P
0.33 (ecovery) 304.24 454.67 P
1 F
0.33 ( as a new low-cost solution for increasing the) 338.4 454.67 P
1.06 (availability of servers in high-performance, locally-distributed \336le systems. The goal of the fast) 108 441.67 P
-0.24 (crash recovery approach is to increase availability overall, by recovering quickly from the majority) 108 428.67 P
(of failures.) 108 415.67 T
0.96 (Fast crash recovery contrasts with the traditional approach to providing high availability) 118.8 390.67 P
0.96 (. The) 516.46 390.67 P
0.63 (traditional approach uses) 108 377.67 P
2 F
0.63 (fault-tolerant techniques) 222.48 377.67 P
1 F
0.63 ( to provide non-stop availability and very high) 331.44 377.67 P
-0.16 (reliability \050no loss or corruption of data\051. T) 108 364.67 P
-0.16 (o meet such requirements, fault-tolerant computing sys-) 295.31 364.67 P
1.63 (tems mask failures or prevent crashes entirely) 108 351.67 P
1.63 (, usually with redundant hardware and software.) 318.46 351.67 P
3.24 (Unfortunately) 108 338.67 P
3.24 (, redundant hardware and software is expensive, and managing the replicated) 168.92 338.67 P
0.73 (resources can be slow and complex. In contrast, fast crash recovery is inexpensive, since it does) 108 325.67 P
0.1 (not require redundant hardware. It is faster during normal system operation, since it does not need) 108 312.67 P
0.24 (to manage replicated resources beyond those required for normal system operation. And it is sim-) 108 299.67 P
0.7 (pler) 108 286.67 P
0.7 (, since it does not attempt to mask or prevent failures; it only attempts to recover the system) 124.64 286.67 P
(very quickly) 108 273.67 T
(.) 162.51 273.67 T
0.66 (Fast crash recovery is thus a viable technique for providing high availability in some environ-) 118.8 248.67 P
-0.07 (ments, but not in others. It is appropriate for or) 108 235.67 P
-0.07 (ganizations that can tolerate occasional failures, but) 313.12 235.67 P
0.06 (demand high-performance, low-cost computing systems. An example of such a system is the typi-) 108 222.67 P
0.39 (cal network of UNIX workstations found in many engineering or) 108 209.67 P
0.39 (ganizations \050the of) 397.24 209.67 P
0.39 (\336ce/engineer-) 479.6 209.67 P
5 (ing computing environment\051. However) 108 196.67 P
5 (, fast crash recovery alone is not appropriate in) 294.05 196.67 P
2.16 (environments that cannot tolerate any downtime. Examples of such environments are on-line) 108 183.67 P
2.46 (transaction processing systems and or) 108 170.67 P
2.46 (ganizations with life-critical applications. These groups) 283.62 170.67 P
0.91 (require fault tolerance and are willing to pay vast amounts of money for systems that guarantee) 108 157.67 P
0.55 (non-stop availability) 108 144.67 P
0.55 (. In these environments, the fast recovery approach is insuf) 198.48 144.67 P
0.55 (\336cient, because it) 462.3 144.67 P
0.67 (cannot completely eliminate downtime after a failure, and it can only provide fast recovery after) 108 131.67 P
0.56 (the majority of crashes. If a failure results from serious damage to a critical piece of hardware, a) 108 118.67 P
1.52 (system using only fast crash recovery \050no redundant hardware\051 will not be available until that) 108 105.67 P
2.98 (hardware is \336xed or replaced. Fortunately) 108 92.67 P
2.98 (, such permanent hardware failures are becoming) 305.84 92.67 P
FMENDPAGE
%%EndPage: "2" 14
%%Page: "3" 14
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(3) 285 55 T
1 11 Q
0.7 (uncommon, as explained in chapter 2, and the faster we make crash recovery) 72 712.67 P
0.7 (, the more environ-) 417.7 712.67 P
(ments will \336nd it an appropriate solution for providing higher availability) 72 699.67 T
(.) 394.15 699.67 T
0 14 Q
(1.1. Measur) 72 666.67 T
(ement Envir) 142.09 666.67 T
(onment and Applicability) 216.07 666.67 T
1 11 Q
0.31 (I have implemented the fast recovery techniques evaluated in this dissertation in the Sprite dis-) 82.8 640.67 P
-0.08 (tributed \336le system. Our Sprite system consists of a cluster of about 20 SP) 72 627.67 P
-0.08 (ARCstation-1, SP) 395.82 627.67 P
-0.08 (ARCs-) 473.48 627.67 P
0.62 (tation-2, DECstation 3100 and DECstation 5000 workstations, almost all diskless and with 24 to) 72 614.67 P
0.55 (32 megabytes of main memory apiece. At its lar) 72 601.67 P
0.55 (gest, the system included 40 client workstations.) 287.68 601.67 P
-0.03 (The cluster has a number of \336le servers, but most of the traf) 72 588.67 P
-0.03 (\336c is handled by a Sun-4/280 with 128) 334.2 588.67 P
-0.11 (megabytes of memory and \336ve to six gigabytes of disk space. All of the workstations in the cluster) 72 575.67 P
-0.25 (run the Sprite network operating system. Sprite is lar) 72 562.67 P
-0.25 (gely UNIX-compatible, and most of the appli-) 302 562.67 P
-0.12 (cations running on the cluster are standard UNIX applications. In addition, Sprite provides process) 72 549.67 P
(migration [Dougli91] which allows users to of) 72 536.67 T
(f-load jobs easily to idle machines in the cluster) 275.64 536.67 T
(.) 484.98 536.67 T
-0.01 (The Sprite user community has included operating systems researchers, architecture researchers) 82.8 511.67 P
1.46 (working on the design and simulation of new I/O subsystems, a group of students and faculty) 72 498.67 P
0.33 (working on VLSI circuit design and parallel processing, administrators, and graphics researchers.) 72 485.67 P
0.65 (At various points in the project, our Sprite system simultaneously supported 40 day-to-day users) 72 472.67 P
-0.09 (and more than 40 occasional users. It is still the day-to-day computing system for me, for the other) 72 459.67 P
0.15 (members of my research group, and for various other students in the department. The broad set of) 72 446.67 P
0.19 (users and wide variety of applications run on Sprite make it a good system for evaluating \336le sys-) 72 433.67 P
(tem research. Any problems with crash recovery are bound to be reported, loudly and indignantly) 72 420.67 T
(.) 499.67 420.67 T
0.62 (Sprite provided part of the motivation for this thesis, along with the necessary \336le system fea-) 82.8 395.67 P
0.09 (tures \050such as \336le caching on client workstations for high performance\051, but the results of this the-) 72 382.67 P
0.43 (sis are more widely applicable. Long recovery times are a problem for many distributed systems,) 72 369.67 P
-0 (not just Sprite. Many of the techniques described in the thesis, such as reuse of kernel text and ini-) 72 356.67 P
0.58 (tialized data, are applicable to the majority of systems. The techniques for recovering distributed) 72 343.67 P
-0.22 (cache state are applicable to current and future \336le systems [Kazar90][Mann93] that cache \336le data) 72 330.67 P
0.89 (on clients. In addition, caching is not the only source of distributed state information. The tech-) 72 317.67 P
1.92 (niques described here are applicable to other varieties of state information such as name and) 72 304.67 P
1.19 (address translation data for network name services and client/server connection information for) 72 291.67 P
-0.19 (distributed databases. Finally) 72 278.67 P
-0.19 (, frequent server reboots are a problem for many systems, and not just) 199.37 278.67 P
0.79 (Sprite. Measurements from Internet sites [Long91] indicate that UNIX machines fail on average) 72 265.67 P
(once every two weeks.) 72 252.67 T
0 14 Q
(1.2. Outline of Dissertation) 72 219.67 T
1 11 Q
(This section outlines the thesis and lists its overall results by chapter) 82.8 193.67 T
(.) 382.78 193.67 T
0.6 (The next chapter of this dissertation gives more motivation and background. First, it describes) 82.8 168.67 P
0.24 (the distributed cache state recovery problem in more detail. It explains how Sprite client worksta-) 72 155.67 P
0.02 (tions achieve higher \336le system performance by caching \336le data, and how the \336le server uses dis-) 72 142.67 P
1.65 (tributed state information to guarantee cache consistency between the clients. Because the \336le) 72 129.67 P
-0.08 (server keeps this distributed cache state in data structures in its volatile memory) 72 116.67 P
-0.08 (, the state informa-) 421.24 116.67 P
-0.15 (tion is lost on the server if the server crashes. As the server returns to service after a failure, it must) 72 103.67 P
-0.23 (recover this information to continue to guarantee cache consistency) 72 90.67 P
-0.23 (. The next section of the second) 365.97 90.67 P
FMENDPAGE
%%EndPage: "3" 15
%%Page: "4" 15
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(4) 321 55 T
1 11 Q
-0.26 (chapter describes a variety of highly-available and fault-tolerant systems to give further motivation) 108 712.67 P
-0.25 (for the fast recovery approach to high availability) 108 699.67 P
-0.25 (. The last section lists other systems that use main) 323.1 699.67 P
(memory to store data across failures, a mechanism described in chapter 5 of this thesis.) 108 686.67 T
0.13 (Chapters 3 through 5 describe and evaluate three dif) 118.8 661.67 P
0.13 (ferent techniques for recovering distributed) 349.09 661.67 P
0.52 (state. Chapter 3 covers the \336rst technique, called) 108 648.67 P
2 F
0.52 (client-driven r) 328.2 648.67 P
0.52 (ecovery) 391.47 648.67 P
1 F
0.52 (. In this form of recovery) 424.91 648.67 P
0.52 (,) 537.25 648.67 P
0.83 (\336rst designed and implemented by Brent W) 108 635.67 P
0.83 (elch [W) 303.76 635.67 P
0.83 (elch90], client workstations of the \336le server) 338.8 635.67 P
0.16 (keep track of which of the server) 108 622.67 P
0.16 (\325) 253.94 622.67 P
0.16 (s \336les and other objects they have cached or opened. When they) 256.99 622.67 P
-0 (detect that the \336le server has crashed and rebooted, the clients send their state information through) 108 609.67 P
1.22 (to the \336le server) 108 596.67 P
1.22 (. The server uses this information to reconstruct the main-memory copy of the) 182.14 596.67 P
0.18 (state information it needs to ensure cache consistency between the clients. Although this recovery) 108 583.67 P
0.1 (technique is the least complex one for Sprite, it also has three disadvantages. First, it leads to con-) 108 570.67 P
0.56 (gestion on the \336le server) 108 557.67 P
0.56 (. This congestion exposed \337aws in Sprite\325) 217.63 557.67 P
0.56 (s communication protocol that) 404.37 557.67 P
-0.18 (allowed cache state recovery to become unstable, sometimes taking ten or \336fteen minutes to \336nish.) 108 544.67 P
0.54 (Second, even with a variety of improvements to prevent instability and server congestion, client-) 108 531.67 P
0.12 (driven recovery is still the slowest state recovery technique, requiring an average of 21 seconds to) 108 518.67 P
0.13 (recover the distributed cache state on a SP) 108 505.67 P
0.13 (ARCstation-2 server with ten clients. The server spends) 293.74 505.67 P
-0.04 (much of this time idle, waiting for clients to send it their state information. \050Note that these are the) 108 492.67 P
0.93 (times to recover just the distributed state. Overall recovery takes longer) 108 479.67 P
0.93 (, as described below) 430.82 479.67 P
0.93 (.\051 A) 521.99 479.67 P
0.2 (third important problem with client-driven recovery is that it permits cache consistency violations) 108 466.67 P
(for a short time during and after the server recovers.) 108 453.67 T
-0.25 (The second recovery technique, evaluated in chapter 4, is) 118.8 428.67 P
2 F
-0.25 (server) 371.26 428.67 P
-0.25 (-driven r) 398.49 428.67 P
-0.25 (ecovery) 436.58 428.67 P
1 F
-0.25 (. This technique) 470.02 428.67 P
-0.25 (is faster than client-driven recovery) 108 415.67 P
-0.25 (, requiring about two seconds for a SP) 262.5 415.67 P
-0.25 (ARCstation-2 server with) 427.59 415.67 P
0.57 (ten clients, and scaling linearly to about six seconds for a server with 40 clients. Disk I/O on the) 108 402.67 P
0.07 (\336le server is the limiting performance factor for server) 108 389.67 P
0.07 (-driven recovery) 347.53 389.67 P
0.07 (. This technique also elimi-) 419.79 389.67 P
0.23 (nates the problems with cache inconsistencies after the server recovers. In server) 108 376.67 P
0.23 (-driven recovery) 464.83 376.67 P
0.23 (,) 537.25 376.67 P
-0.03 (the server keeps a list in stable storage of clients that have opened or cached its \336les. For recovery) 108 363.67 P
-0.03 (,) 537.25 363.67 P
0.19 (the server contacts the clients on its list for information about these \336les. When contacted, the cli-) 108 350.67 P
0.16 (ents send the server their state information. The server then rebuilds its volatile data structures for) 108 337.67 P
-0.2 (the distributed cache and other \336le system state in the same manner used by client-driven recovery) 108 324.67 P
-0.2 (.) 537.25 324.67 P
0.43 (The dif) 108 311.67 P
0.43 (ference between server) 140.27 311.67 P
0.43 (-driven and client-driven recovery is that the server has a complete) 242.18 311.67 P
1.27 (list of the clients it must contact and therefore knows when the recovery process is done. This) 108 298.67 P
0.2 (means it need not wait to see if further clients contact it, and it can hold of) 108 285.67 P
0.2 (f granting new services) 437.19 285.67 P
0.18 (to clients until all clients have recovered. W) 108 272.67 P
0.18 (ith this advantage the server avoids cache consistency) 302.27 272.67 P
-0.1 (violations and can better control recovery) 108 259.67 P
-0.1 (. This chapter also describes problems with server) 289.53 259.67 P
-0.1 (-driven) 508.27 259.67 P
0.39 (recovery) 108 246.67 P
0.39 (, including server dependence on clients for good recovery speed and increased synchro-) 145.72 246.67 P
0.88 (nization complexity in the kernel. Despite these problems, server) 108 233.67 P
0.88 (-driven recovery is likely to be) 400.43 233.67 P
(the technique of choice for many systems.) 108 220.67 T
0.15 (Chapter 5 evaluates the third, and fastest, technique used for recovering distributed state,) 118.8 195.67 P
2 F
0.15 (trans-) 513.75 195.67 P
0.43 (par) 108 182.67 P
0.43 (ent r) 122.85 182.67 P
0.43 (ecovery) 143.33 182.67 P
1 F
0.43 (. This form of recovery requires about 1.5 seconds for ten clients, scaling linearly) 176.77 182.67 P
0.51 (to a little over \336ve seconds for 40 clients. Server disk I/O is still the limiting performance factor) 108 169.67 P
0.51 (,) 537.25 169.67 P
1.33 (but transparent recovery introduces new possibilities for reducing the amount of I/O. I call the) 108 156.67 P
2.09 (technique) 108 143.67 P
2 F
2.09 (transpar) 155.55 143.67 P
2.09 (ent) 192.99 143.67 P
1 F
2.09 (, because it requires no communication between the clients and the \336le) 206.42 143.67 P
0.53 (server for recovery) 108 130.67 P
0.53 (. T) 191.91 130.67 P
0.53 (o avoid gathering the distributed cache state from clients after a failure, the) 203.87 130.67 P
-0.13 (server preserves its state information across failures. However) 108 117.67 P
-0.13 (, the state information is updated too) 379.98 117.67 P
-0.21 (frequently during normal operation for the server to maintain it on disk. I have therefore developed) 108 104.67 P
1.07 (a mechanism called the) 108 91.67 P
2 F
1.07 (r) 217.85 91.67 P
1.07 (ecovery box) 221.72 91.67 P
1 F
1.07 (, that allows the server to store the state information in its) 275.56 91.67 P
FMENDPAGE
%%EndPage: "4" 16
%%Page: "5" 16
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(5) 285 55 T
1 11 Q
0.32 (main memory and treat that main memory as if it were stable storage. The server can then update) 72 712.67 P
0.32 (the information at main memory speeds, while preserving the information in that area of memory) 72 699.67 P
0.48 (across failures. The recovery box itself provides no extra protection against power failures, but it) 72 686.67 P
0.11 (detects and prevents stray memory writes that could corrupt the data preserved there. This chapter) 72 673.67 P
-0.15 (includes details on the design and implementation of the recovery box and its applicability to other) 72 660.67 P
0.66 (systems and programs. The recovery box technique is useful outside of cache state recovery) 72 647.67 P
0.66 (, but) 483.81 647.67 P
(transparent recovery can be hard to retro\336t into existing systems.) 72 634.67 T
0.56 (Chapter 6 covers other requirements for fast recovery) 82.8 609.67 P
0.56 (. Besides recovering its distributed cache) 321.2 609.67 P
0.57 (state, a \336le server goes through a number of other steps to reboot after a crash. This chapter lists) 72 596.67 P
0.53 (these steps and how I\325ve improved the performance of each, often with the help of others\325 work.) 72 583.67 P
0.05 (W) 72 570.67 P
0.05 (ith transparent recovery and the other improvements listed in this chapter) 81.93 570.67 P
0.05 (, it now takes under 29) 403.64 570.67 P
0.23 (seconds overall to boot a SP) 72 557.67 P
0.23 (ARCstation-2 \336le server with 40 clients. This is two orders of magni-) 196.33 557.67 P
(tude faster than most distributed \336le systems.) 72 544.67 T
0.34 (Chapter 7 gives some advice on designing systems to recover quickly from crashes. In particu-) 82.8 519.67 P
0.98 (lar) 72 506.67 P
0.98 (, the design should include fast recovery from the beginning, because it can be harder to add) 83.15 506.67 P
1.04 (after the rest of the system has been worked out. A second point is that designers should avoid) 72 493.67 P
0.5 (start-up overhead. A common design trade-of) 72 480.67 P
0.5 (f is to do some extra start-up processing if it means) 274.44 480.67 P
0.27 (the system will perform better during normal operation. This is usually the right trade-of) 72 467.67 P
0.27 (f, but the) 464.09 467.67 P
1.48 (start-up processing adds up quickly and can result in slow recovery) 72 454.67 P
1.48 (. T) 381.39 454.67 P
1.48 (echniques that use main) 394.3 454.67 P
0.41 (memory for storing system state, such as the recovery box, make it possible to have good overall) 72 441.67 P
-0.17 (performance and faster recovery times. A third point is that designers should build tools to manage) 72 428.67 P
0.4 (and debug distributed state, to make sure it is kept consistent. Finally) 72 415.67 P
0.4 (, recovery of the state infor-) 379.35 415.67 P
(mation will be much easier if updates to it are easy to locate and isolate in the code.) 72 402.67 T
0.57 (The concluding chapter gives a side-by-side comparison of the distributed state recovery tech-) 82.8 377.67 P
1.08 (niques and sums up the results of the thesis. Recovery is one of the most dif) 72 364.67 P
1.08 (\336cult and stressful) 421.27 364.67 P
1.19 (activities a system must perform. I hope this dissertation will encourage designers to pay more) 72 351.67 P
(attention to recovery as a part of system design.) 72 338.67 T
0 14 Q
(1.3. Contributions) 72 305.67 T
1 11 Q
(In summary) 82.8 279.67 T
(, the main contributions of this thesis are) 134.88 279.67 T
4 12 Q
(\245) 72 260 T
1 F
(The comparison of three distributed state recovery techniques.) 85.75 260 T
4 F
(\245) 72 240 T
1 F
(The evaluation of fast recovery as a low-cost solution for providing high availability) 85.75 240 T
(.) 490.02 240 T
4 F
(\245) 72 220 T
1 F
-0.16 (The evaluation of the recovery box as a mechanism for treating main memory as stable) 85.75 220 P
(storage across system failures.) 85.75 206 T
4 F
(\245) 72 186 T
1 F
(A guide for designing systems that recover quickly) 85.75 186 T
(.) 329.8 186 T
FMENDPAGE
%%EndPage: "5" 17
%%Page: "6" 17
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(6) 321 55 T
108 666 540 720 C
108 666 540 720 R
7 X
0 K
V
108 693 540 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
108 594 540 648 C
108 594 540 648 R
7 X
0 K
V
108 603 540 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(1) 144 638 T
0 18 Q
(Backgr) 180 654 T
(ound) 235.64 654 T
1 11 Q
1.54 (This chapter gives more background and motivation for the distributed cache state recovery) 118.8 519.67 P
1.18 (problem and for the fast recovery approach to high availability) 108 506.67 P
1.18 (. The \336rst section of the chapter) 393.46 506.67 P
0.98 (describes distributed \336le systems that must recover distributed cache state after a failure. It \336rst) 108 493.67 P
-0.23 (details the distributed cache state recovery problem in the context of Sprite and then lists other sys-) 108 480.67 P
-0.24 (tems with similar recovery problems. The second section describes some of the many highly-avail-) 108 467.67 P
-0.07 (able systems and contrasts their methods to the fast recovery approach. The third section describes) 108 454.67 P
0.37 (systems that store state information in main memory for fast crash recovery) 108 441.67 P
0.37 (, as does the recovery) 443.64 441.67 P
(box, described in chapter 5.) 108 428.67 T
0 14 Q
(1.1. The Distributed Cache State Recovery Pr) 108 395.67 T
(oblem) 379.77 395.67 T
1 11 Q
-0.19 (File systems such as Sprite, Spritely NFS [Mogul92][Sriniv89][Mogul93], DEcorum [Kazar90],) 118.8 369.67 P
(and Echo [Hisgen89][Mann93] all share a need to recover distributed cache state. The need arises,) 108 356.67 T
0.25 (because the systems allow \336le data caching on client workstations and also guarantee consistency) 108 343.67 P
(amongst the client caches.) 108 330.67 T
0.03 (The clients cache \336le data in their main memories to increase \336le system throughput and reduce) 118.8 305.67 P
1.01 (the latency of \336le data accesses. Due to the locality of \336le accesses, the clients are likely to re-) 108 292.67 P
0.13 (access the cached data soon. A client request satis\336ed from its local \336le cache progresses at main-) 108 279.67 P
0.38 (memory speed, avoiding a slower access of the data across the network on a \336le server) 108 266.67 P
0.38 (. This also) 493.78 266.67 P
-0.1 (reduces the load on the servers themselves. For example, Sprite\325) 108 253.67 P
-0.1 (s \336le data caches on clients absorb) 389.29 253.67 P
-0.08 (60% of read accesses and reduce total \336le traf) 108 240.67 P
-0.08 (\336c between clients and servers by at least 50% [Bak-) 308.52 240.67 P
(er91b].) 108 227.67 T
0.6 (However) 118.8 202.67 P
0.6 (, the same \336le can be stored and modi\336ed by dif) 158.62 202.67 P
0.6 (ferent clients, so a cache consistency) 375.29 202.67 P
0.37 (policy is necessary to ensure that clients all view consistent copies of the data. T) 108 189.67 P
0.37 (o implement this) 465.4 189.67 P
0.07 (policy) 108 176.67 P
0.07 (, a \336le server keeps information about which clients are caching which of its \336les. However) 134.75 176.67 P
0.07 (,) 537.25 176.67 P
1.18 (the \336le server can lose this information if it crashes. Recovering this information after a server) 108 163.67 P
(crash is the) 108 150.67 T
2 F
(distributed cache state r) 160.17 150.67 T
(ecovery pr) 266.27 150.67 T
(oblem) 312.53 150.67 T
1 F
(.) 339.38 150.67 T
0.52 (The following section explains the problem in more detail, or) 118.8 125.67 P
0.52 (ganized as follows. For compari-) 393 125.67 P
0.39 (son, I \336rst describe an older \336le system, NFS [Sandbe85], that has made an opposite set of trade-) 108 112.67 P
-0.18 (of) 108 99.67 P
-0.18 (fs from Sprite\325) 116.95 99.67 P
-0.18 (s. NFS has no state recovery problem, because it limits client \336le caching and pro-) 180.67 99.67 P
1.55 (vides only weak cache consistency) 108 86.67 P
1.55 (. The section then lists the performance bene\336ts Sprite gets) 266.66 86.67 P
FMENDPAGE
%%EndPage: "6" 18
%%Page: "7" 18
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(7) 285 55 T
1 11 Q
0.09 (from caching \336le data, including modi\336ed \050or) 72 712.67 P
2 F
0.09 (dirty) 275.86 712.67 P
1 F
0.09 (\051 data, on clients. This is followed by an expla-) 296.61 712.67 P
0.69 (nation of why Sprite\325) 72 699.67 P
0.69 (s cache consistency policy is necessary and how it works. The section then) 167.14 699.67 P
3.05 (explains the recovery problem that results from Sprite\325) 72 686.67 P
3.05 (s cache consistency guarantees. The) 333.47 686.67 P
(remainder of the section describes some other systems with similar recovery problems.) 72 673.67 T
0 12 Q
(1.1.1. NFS) 72 208.02 T
1 11 Q
0.19 (NFS is a commercial network \336le system that has become a standard for workstations on local-) 82.8 182.68 P
-0.25 (area networks. It uses a client-server model and allows clients to cache \336le data in their main mem-) 72 169.68 P
0.65 (ories. Figure 1-1 shows NFS client workstations, with local caches, connected by a network to a) 72 156.68 P
-0.1 (\336le server with disks and a local cache. T) 72 143.68 P
-0.1 (o read data from a \336le, an NFS client looks for the data in) 252 143.68 P
0.75 (its local cache. If the data is in the cache \050a) 72 130.68 P
2 F
0.75 (cache hit) 271.88 130.68 P
1 F
0.75 (\051, the client does not need to communicate) 312.6 130.68 P
1.2 (with the server) 72 117.68 P
1.2 (. Otherwise the access is a) 139.09 117.68 P
2 F
1.2 (cache miss) 264.36 117.68 P
1 F
1.2 (, and the client requests the data from the) 313.46 117.68 P
0.78 (server) 72 104.68 P
0.78 (. If the request misses in the server) 98.24 104.68 P
0.78 (\325) 256.67 104.68 P
0.78 (s cache, the server retrieves the data from disk into its) 259.72 104.68 P
(cache, and then sends the data to the client, which puts it into its own cache.) 72 91.68 T
(Figure 1-1. Client-server distributed \336le system.) 182.26 346.68 T
1 10 Q
0.08 (This \336gure illustrates a client-server distributed \336le system, such as NFS. The clients read) 108 324.35 P
0.47 (\336le data across the network from the \336le server) 108 313.35 P
0.47 (, unless they \336nd the data already in their) 299.59 313.35 P
0.87 (main-memory caches. T) 108 302.35 P
0.87 (o service a read request, the server \336rst checks its cache for the) 205.9 302.35 P
0.23 (data. If the data is not cached, the server reads the data from disk and returns it to the cli-) 108 291.35 P
0.38 (ents. Likewise, the clients write data from their caches to the server) 108 280.35 P
0.38 (, which in turn writes) 381.27 280.35 P
72 248.02 504 266.02 C
72 248.02 504 266.02 R
7 X
0 K
V
72 257.02 504 257.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(data from its cache to its disk.) 108 269.35 T
72 372.02 504 652 C
72 372.02 504 640 C
7 X
0 K
90 450 36 10 198 389 G
0.5 H
0 Z
0 X
90 450 36 10 198 389 A
7 X
90 450 36 10 198 398 G
0 X
90 450 36 10 198 398 A
7 X
90 450 36 10 198 407 G
0 X
90 450 36 10 198 407 A
7 X
90 450 36 10 198 416 G
0 X
90 450 36 10 198 416 A
1 12 Q
(disk) 185.01 411.82 T
7 X
90 450 57.5 55.5 338.5 452.5 G
0 X
90 450 57.5 55.5 338.5 452.5 A
294 419 384 455 R
5 X
V
0 X
N
294 419 384 473 R
N
(\336le cache) 312 460 T
(\336le server) 311 484 T
244.45 413.76 223.45 414.08 241.42 424.94 242.94 419.35 4 Y
V
292.99 438.32 313.99 438.01 296.02 427.15 294.51 432.73 4 Y
V
242.94 419.34 294.52 432.73 2 L
3 H
N
7 X
90 450 39.31 39.5 131.69 589.5 G
0.5 H
0 X
90 450 39.31 39.5 131.69 589.5 A
101.26 565.66 162.79 591.28 R
5 X
V
0 X
N
101.26 565.66 162.79 604.09 R
N
(\336le cache) 113.57 594.04 T
(client) 117.89 611.11 T
7 X
90 450 39.31 39.5 228.31 589.5 G
0 X
90 450 39.31 39.5 228.31 589.5 A
197.89 565.66 259.42 591.28 R
5 X
V
0 X
N
197.89 565.66 259.42 604.09 R
N
(\336le cache) 210.19 594.04 T
(client) 214.51 611.11 T
7 X
90 450 39.31 39.5 327.31 589.5 G
0 X
90 450 39.31 39.5 327.31 589.5 A
296.89 565.66 358.42 591.28 R
5 X
V
0 X
N
296.89 565.66 358.42 604.09 R
N
(\336le cache) 309.19 594.04 T
(client) 313.51 611.11 T
7 X
90 450 39.31 39.5 426.31 589.5 G
0 X
90 450 39.31 39.5 426.31 589.5 A
395.89 565.66 457.42 591.28 R
5 X
V
0 X
N
395.89 565.66 457.42 604.09 R
N
(\336le cache) 408.19 594.04 T
(client) 412.51 611.11 T
82 518 487 518 2 L
3 H
2 Z
N
126.56 558.19 132.03 578.47 138.14 558.38 132.35 558.29 4 Y
V
138.46 538.28 133 518 126.89 538.09 132.68 538.19 4 Y
V
132.35 558.29 132.68 538.18 2 L
0 Z
N
358.19 431.21 338 437 358.19 442.79 358.19 437 4 Y
V
358.19 437 451 437 2 L
2 Z
N
221.56 558.19 227.03 578.47 233.14 558.38 227.35 558.29 4 Y
V
233.46 538.28 228 518 221.89 538.09 227.67 538.19 4 Y
V
227.35 558.29 227.68 538.18 2 L
0 Z
N
322.56 557.19 328.02 577.47 334.14 557.38 328.35 557.29 4 Y
V
334.46 537.28 328.99 517 322.88 537.09 328.67 537.19 4 Y
V
328.35 557.29 328.68 537.18 2 L
N
421.56 556.19 427.02 576.47 433.13 556.38 427.35 556.29 4 Y
V
433.46 536.28 427.99 516 421.88 536.09 427.67 536.19 4 Y
V
427.35 556.29 427.68 536.18 2 L
N
445.21 497.81 451 518 456.79 497.81 451 497.81 4 Y
V
451 437 451 497.81 2 L
2 Z
N
(network) 94 498 T
72 372.02 504 652 C
72 372.02 504 640 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "7" 19
%%Page: "8" 19
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(8) 321 55 T
1 11 Q
0.13 (NFS is designed primarily to be simple; cache consistency and performance are only secondary) 118.8 712.67 P
-0.01 (goals. T) 108 699.67 P
-0.01 (o simplify the design, NFS \336le servers are) 142.62 699.67 P
2 F
-0.01 (stateless) 330.17 699.67 P
1 F
-0.01 (: servers do not keep state in their main) 367.4 699.67 P
0.98 (memories unless it is also on disk. This means they lose no state information if they crash, and) 108 686.67 P
0.46 (they therefore have no state recovery problem. In particular) 108 673.67 P
0.46 (, NFS servers do not keep state infor-) 372.65 673.67 P
(mation about which clients are caching which \336les.) 108 660.67 T
1.39 (NFS\325) 118.8 635.67 P
1.39 (s simple stateless approach leads to consistency problems which in turn lead to perfor-) 142 635.67 P
0.7 (mance problems during normal processing. Because an NFS server does not know which clients) 108 622.67 P
-0.15 (are caching which \336les, it cannot inform clients when a \336le they have cached has been modi\336ed by) 108 609.67 P
0.47 (another client. The client caches can thus become inconsistent, and some clients may continue to) 108 596.67 P
(use the old \050or) 108 583.67 T
2 F
(stale) 173.91 583.67 T
1 F
(\051 data in their caches.) 194.66 583.67 T
0.17 (T) 118.8 558.67 P
0.17 (o limit these inconsistencies, clients must poll the server periodically to determine if \336les they) 124.74 558.67 P
0.18 (have cached have been updated. Polling puts an extra load on the server and adds latency to some) 108 545.67 P
0.2 (client \336le accesses. Whenever a client accesses a \336le, the client checks how long it has been since) 108 532.67 P
-0.21 (it last polled the server about that \336le. If it has been longer than some number of seconds, the client) 108 519.67 P
-0.18 (asks the server for status information about the \336le. This status information includes the date of the) 108 506.67 P
0.02 (last modi\336cation for the \336le. If the \336le has been modi\336ed since the client last polled the server) 108 493.67 P
0.02 (, the) 521.06 493.67 P
1.15 (client invalidates its cached data for the \336le. In most NFS implementations, the clients poll the) 108 480.67 P
0.61 (server if a \336le\325) 108 467.67 P
0.61 (s status information is older than three to 60 seconds. However) 173.61 467.67 P
0.61 (, this still leaves at) 456.06 467.67 P
0.52 (least three seconds during which a client may use stale data. Section 1.1.3 presents data showing) 108 454.67 P
(the negative impact of this weak cache consistency scheme.) 108 441.67 T
-0.2 (The NFS trade-of) 118.8 416.67 P
-0.2 (f in favor of simple recovery and weak cache consistency has even greater per-) 195.71 416.67 P
0.06 (formance problems than those mentioned above. T) 108 403.67 P
0.06 (o reduce the opportunity for client cache incon-) 330.61 403.67 P
1.01 (sistencies, most NFS implementations use a) 108 390.67 P
2 F
1.01 (write-thr) 309.68 390.67 P
1.01 (ough-on-close) 348.34 390.67 P
1 F
1.01 ( cache policy) 411.19 390.67 P
1.01 (. When a client) 470.46 390.67 P
0.3 (modi\336es \336le data in its cache, it sends the new data back to the server when it closes the \336le. The) 108 377.67 P
0.45 (application\325) 108 364.67 P
0.45 (s \336le close operation blocks until the \336le data has been written all the way through to) 159.88 364.67 P
0.03 (the server) 108 351.67 P
0.03 (\325) 151.44 351.67 P
0.03 (s disk. This makes the new data available quickly for other clients polling the \336le, but it) 154.5 351.67 P
0.43 (increases the delay for the client application, and it increases the load on the network and the \336le) 108 338.67 P
0.39 (server) 108 325.67 P
0.39 (. Most \336les are only open for a short time [Baker91b], so the write-through-on-close policy) 134.24 325.67 P
-0.11 (means that clients write back their dirty data almost immediately) 108 312.67 P
-0.11 (. This ties their write performance) 391.03 312.67 P
0.9 (to the speed of the server) 108 299.67 P
0.9 (\325) 223.07 299.67 P
0.9 (s disk. The following section contains comparative performance mea-) 226.12 299.67 P
-0.17 (surements between NFS and Sprite, which does not write back dirty data as soon as a \336le is closed.) 108 286.67 P
0 12 Q
(1.1.2. Client Caching in Sprite) 108 255 T
1 11 Q
0.29 (The Sprite distributed \336le system uses a client-server model similar to that of NFS, but with an) 118.8 229.67 P
1.1 (almost opposite set of design decisions. In Sprite, performance and cache consistency are more) 108 216.67 P
0.47 (important than the simplicity of state recovery) 108 203.67 P
0.47 (. Sprite therefore allows more aggressive \336le cach-) 313.35 203.67 P
(ing on clients and guarantees that all clients see a consistent view of the \336le data.) 108 190.67 T
0.31 (Unlike NFS, Sprite\325) 118.8 165.67 P
0.31 (s client caches delay writing dirty data back to the \336le server) 207.02 165.67 P
0.31 (. Sprite allows) 476.2 165.67 P
-0.02 (dirty data to remain in the client\325) 108 152.67 P
-0.02 (s cache for about 30 seconds. This) 251.9 152.67 P
2 F
-0.02 (delayed write-back policy) 405.52 152.67 P
1 F
-0.02 ( pro-) 518.97 152.67 P
1.31 (vides two bene\336ts. First, if the dirty data is either deleted or overwritten while cached, it need) 108 139.67 P
-0.15 (never be written across the network through to the \336le server) 108 126.67 P
-0.15 (. This reduces the load on the network) 373.21 126.67 P
0.09 (and \336le server) 108 113.67 P
0.09 (. Second, even if the data is written back to the \336le server after some period of time,) 169.82 113.67 P
1.41 (the write operation is performed) 108 100.67 P
2 F
1.41 (asynchr) 259.37 100.67 P
1.41 (onously) 293.75 100.67 P
1 F
1.41 ( with respect to the application that issued the) 327.93 100.67 P
FMENDPAGE
%%EndPage: "8" 20
%%Page: "9" 20
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(9) 285 55 T
1 11 Q
0.64 (write. This means the application does not block until the write is \336nished, so its performance is) 72 712.67 P
(not limited by the write operation.) 72 699.67 T
2.32 ( Sprite\325) 82.8 674.67 P
2.32 (s delayed write-back policy) 117.16 674.67 P
2.32 (provides better application performance that the write-) 250.3 674.67 P
0.54 (through policy used by NFS. Comparisons between NFS and Sprite in [Nelson88] made on Sun-) 72 661.67 P
-0.1 (3/50 and Sun-3/75 workstations show that Sprite is at least 30 to 40% faster) 72 648.67 P
-0.1 (, due in lar) 403.19 648.67 P
-0.1 (ge part to its) 449.68 648.67 P
0.17 (writing policies. More recent measurements in [Ouste90a] on faster workstations show that Sprite) 72 635.67 P
0.18 (is now 50 to 100% faster) 72 622.67 P
0.18 (. This is because the penalty for using NFS grows worse as machines get) 181.85 622.67 P
1.16 (faster; disks and networks have not increased in speed as fast as have CPUs, and Sprite makes) 72 609.67 P
(fewer disk and network accesses than NFS.) 72 596.67 T
0 12 Q
(1.1.3. Sprite\325) 72 565 T
(s Cache Consistency Policy) 136.85 565 T
1 11 Q
0.62 (Permitting client workstations to cache dirty \336le data improves \336le system performance, but it) 82.8 539.67 P
1.66 (also permits potential cache inconsistencies. These cache inconsistencies would violate one of) 72 526.67 P
0.28 (Sprite\325) 72 513.67 P
0.28 (s goals. Sprite is designed to provide the same view of the \336le system to clients as would a) 101.3 513.67 P
0.23 (single time-shared machine, despite \336le caching. Thus, all clients accessing data from a particular) 72 500.67 P
-0.21 (\336le should see the same, and most recent, view of that data. Sprite\325) 72 487.67 P
-0.21 (s cache consistency policy guar-) 362.68 487.67 P
1.4 (antees this. This section further explains the cache consistency problem and shows how Sprite) 72 474.67 P
0.81 (solves it. It then presents data showing that the cache consistency policy is necessary to prevent) 72 461.67 P
0.52 (clients from accessing inconsistent data. The data also shows that the policy is not invoked often) 72 448.67 P
(enough to degrade overall \336le system performance.) 72 435.67 T
1.91 (Sprite caches can become inconsistent due to) 82.8 410.67 P
2 F
1.91 (write-sharing) 297.28 410.67 P
1 F
1.91 (. Figure 1-2 illustrates how this) 357.1 410.67 P
-0.05 (occurs through) 72 397.67 P
2 F
-0.05 (sequential) 140.24 397.67 P
1 F
-0.05 ( and) 185.4 397.67 P
2 F
-0.05 (concurr) 206.65 397.67 P
-0.05 (ent) 241.02 397.67 P
1 F
-0.05 ( write-sharing. Sequential write-sharing occurs when cli-) 254.45 397.67 P
0.07 (ents sequentially access a \336le, with at least one of them modifying it. The write-sharing is sequen-) 72 384.67 P
0.42 (tial if the \336le is only open on one client at a time. In the \336gure, one workstation \050called larceny) 72 371.67 P
1 9 Q
0.34 (1) 495.85 376.07 P
1 11 Q
0.42 (\051) 500.34 371.67 P
0.65 (opens a \336le for reading and caches it. After larceny closes the \336le, another machine \050called glut-) 72 358.67 P
-0.22 (tony\051 opens and writes the \336le, leaving dirty data in its cache. After gluttony closes the \336le, larceny) 72 345.67 P
0.52 (opens it again. W) 72 332.67 P
0.52 (ithout a cache consistency policy) 150.03 332.67 P
0.52 (, gluttony will read the stale data from its own) 296.65 332.67 P
(cache, because it does not know that larceny has modi\336ed the \336le.) 72 319.67 T
0.96 (Figure 1-2 also illustrates concurrent write-sharing. Concurrent write-sharing occurs if clients) 82.8 294.67 P
0.77 (have a \336le open at the same time, with at least one client writing the \336le. In this case, the client) 72 281.67 P
0.69 (writing the \336le, gluttony) 72 268.67 P
0.69 (, has the most recent data for it. But without a cache consistency policy) 180.19 268.67 P
0.69 (,) 501.25 268.67 P
0.22 (larceny will not know that another client is modifying the \336le, and it will continue to use the stale) 72 255.67 P
(data in its own cache.) 72 242.67 T
-0.15 (T) 82.8 217.67 P
-0.15 (o ensure that all clients see the most recent data in the presence of write-sharing, Sprite\325) 88.74 217.67 P
-0.15 (s cache) 472.13 217.67 P
1.59 (consistency policy does three things. First, the server maintains version numbers on \336les. The) 72 204.67 P
0.16 (server increments a \336le\325) 72 191.67 P
0.16 (s version number whenever the \336le is opened for writing. Whenever a cli-) 177.74 191.67 P
-0.06 (ent opens a \336le for reading or writing, the server returns the \336le\325) 72 178.67 P
-0.06 (s version number) 352.94 178.67 P
-0.06 (. The client saves) 427.89 178.67 P
-0.17 (this number for as long as it caches data from the \336le. If the client opens the \336le again later) 72 165.67 P
-0.17 (, it com-) 467.42 165.67 P
72 117 504 137 C
72 125 204 125 2 L
0.25 H
2 Z
0 X
0 K
N
0 0 612 792 C
1 10 Q
0 X
0 K
-0.01 (1.  All machine names in this thesis are actual names of hosts in the Sprite network at U.C. Berkeley) 72 110.33 P
-0.01 (. Sprite) 472.64 110.33 P
(uses a \322spices and vices\323 naming scheme, but there seems to have been rather more interest in vices than in) 72 99.33 T
(spices.) 72 88.33 T
FMENDPAGE
%%EndPage: "9" 21
%%Page: "10" 21
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(10) 318 55 T
1 11 Q
0.42 (pares the old and new version numbers. If the version number has changed, the client knows that) 108 188.67 P
(its cached data for the \336le is invalid.) 108 175.67 T
0.4 (Second, the server keeps track of all the clients that are caching its \336les and the location of the) 118.8 150.67 P
-0.12 (most recent data for each \336le. The server is able to do this, because the clients send it all their open) 108 137.67 P
-0.02 (and close requests. When the server receives an open request for a \336le from a client, it records in a) 108 124.67 P
0.59 (main memory data structure the fact that the client is caching that \336le and whether it has opened) 108 111.67 P
0.47 (the \336le for reading or writing. The \336le server) 108 98.67 P
0.47 (\325) 308.93 98.67 P
0.47 (s list of which clients are caching which \336les is the) 311.98 98.67 P
2 F
(distributed cache state) 108 85.67 T
1 F
(, and the server is called) 207.48 85.67 T
2 F
(stateful) 316.4 85.67 T
1 F
( because it maintains this state.) 348.75 85.67 T
(Figure 1-2. Sequential and concurrent write-sharing.) 208.82 379.67 T
1 10 Q
1.02 (This \336gure illustrates sequential and concurrent write-sharing using two client worksta-) 144 357.33 P
-0.2 (tions called larceny and gluttony) 144 346.33 P
-0.2 (. In sequential write-sharing, clients take turns accessing a) 273.01 346.33 P
-0.16 (\336le, with at least one of them writing it. In this example, larceny \336rst opens \336le A for read-) 144 335.33 P
0.23 (ing. It then has a copy of that \336le data in its local main-memory \336le cache. After it closes) 144 324.33 P
-0.02 (the \336le, another workstation, gluttony) 144 313.33 P
-0.02 (, opens the \336le for writing. Gluttony now has a mod-) 293.75 313.33 P
0.13 (i\336ed version of the \336le data in its local cache. If larceny then opens the \336le again, without) 144 302.33 P
0.41 (a cache consistency policy) 144 291.33 P
0.41 (, it will read stale data from its local cache, since the new data) 250.87 291.33 P
0.3 (for the \336le is in gluttony\325) 144 280.33 P
0.3 (s cache. In concurrent write-sharing, more than one client opens) 245.16 280.33 P
0.19 (the \336le at the same time, with at least one client writing the \336le. A cache consistency pol-) 144 269.33 P
0.55 (icy is necessary to ensure that any client sharing the \336le always receives the most up-to-) 144 258.33 P
108 226 540 244 C
108 226 540 244 R
7 X
0 K
V
108 235 540 235 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(date data.) 144 247.33 T
108 405 540 720 C
108 405 540 708 C
306 585.78 378 603.78 R
13 X
0 K
V
0.5 H
0 Z
0 X
N
198 620 270 638 R
14 X
V
0 X
N
510.46 616.09 522 612.78 510.46 609.47 510.46 612.78 4 Y
V
162 612.78 510.46 612.78 2 L
14 X
V
2 Z
0 X
N
505.96 463.09 517.5 459.78 505.96 456.48 505.96 459.78 4 Y
V
162 459.78 505.96 459.78 2 L
14 X
V
0 X
N
414 620 486 638 R
14 X
V
0 Z
0 X
N
1 12 Q
(gluttony writes \336le A) 306 575.6 T
(larceny reads \336le A) 414 642.39 T
(larceny reads \336le A) 199.42 641.6 T
(time) 122.68 613.6 T
227.82 468.78 407.82 486.78 R
14 X
V
0 X
N
301.5 432.78 481.5 450.78 R
13 X
V
0 X
N
(larceny:) 144 629 T
(gluttony:) 144 584 T
(time) 121.5 455.17 T
(larceny:) 144 476.6 T
(gluttony:) 144 431.6 T
(larceny reads \336le A) 226.28 489.39 T
(gluttony writes \336le A) 301.5 422.6 T
383.6 682.78 252 682.78 2 L
V
1.14 H
N
0 F
(Sequential Write-Sharing) 252 683.96 T
384.5 524.34 246.93 524.34 2 L
V
N
(Concurrent Write-Sharing) 246.93 525.53 T
106 557 538 557 2 L
13 X
V
0.5 H
2 Z
0 X
N
108 405 540 720 C
108 405 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "10" 22
%%Page: "11" 22
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 282.23 55 T
(1) 287.78 55 T
1 11 Q
-0.08 (Third, the server enforces cache consistency by telling clients to invalidate their caches, to write) 82.8 712.67 P
0.76 (back dirty data, or to make a \336le uncacheable. T) 72 699.67 P
0.76 (o do this, Sprite \336le servers make cache consis-) 289.51 699.67 P
0.59 (tency) 72 686.67 P
2 F
0.59 (call-backs) 99.13 686.67 P
1 F
0.59 ( to their clients. When the server receives an open request, it consults its distrib-) 144.28 686.67 P
1.99 (uted cache state to determine if the request requires any call-back. If so, it calls back to the) 72 673.67 P
-0.22 (appropriate clients to tell them what to do. A call-back may be necessary if the open request causes) 72 660.67 P
(sequential write-sharing. It is always necessary if the request causes concurrent write-sharing.) 72 647.67 T
0.01 (These call-backs are illustrated in Figure 1-3. In the sequential write-sharing case, a call-back is) 82.8 622.67 P
0.49 (necessary if a client still has dirty data in its cache when another client opens the \336le. The server) 72 609.67 P
0.56 (calls back to the client caching the dirty data and tells it to write the data back to the server) 72 596.67 P
0.56 (. The) 480.86 596.67 P
0.29 (new data is then available on the server before it responds to the new client\325) 72 583.67 P
0.29 (s open request. In the) 409.19 583.67 P
0.44 (concurrent write-sharing case, the server calls back to all clients sharing the \336le and tells them to) 72 570.67 P
0.16 (stop caching the \336le. If one of the clients has dirty data for the \336le, it is also told to write that data) 72 557.67 P
0.05 (back to the server) 72 544.67 P
0.05 (. All reads and writes on the \336le then go directly through to the \336le server) 149.34 544.67 P
0.05 (, so the) 472.47 544.67 P
0.25 (server can make the most recent \336le data available to all the clients. The \336le remains uncacheable) 72 531.67 P
0.06 (until all clients have closed it. T) 72 518.67 P
0.06 (urning of) 212.65 518.67 P
0.06 (f client caching during concurrent write-sharing may add) 253.1 518.67 P
-0.06 (latency to individual client read and write requests, but concurrent sharing is so rare that using this) 72 505.67 P
(simple mechanism does not signi\336cantly af) 72 492.67 T
(fect overall system performance [Baker91b].) 261.92 492.67 T
0.6 (Given this explanation of Sprite\325) 82.8 467.67 P
0.6 (s cache consistency policy) 228.64 467.67 P
0.6 (, there are still questions to answer) 345.98 467.67 P
0.6 (.) 501.25 467.67 P
-0.16 (First, is the cache consistency policy really necessary? W) 72 454.67 P
-0.16 (e can answer this by looking at how often) 322.18 454.67 P
1.02 (Sprite clients and users would access stale data if we used a weaker cache consistency scheme,) 72 441.67 P
0.52 (such as NFS\325) 72 428.67 P
0.52 (s. Second, is Sprite\325) 131.02 428.67 P
0.52 (s cache consistency policy likely to degrade overall system per-) 219.55 428.67 P
0.39 (formance? W) 72 415.67 P
0.39 (e can answer this question by looking at how often consistency actions are invoked.) 130.99 415.67 P
0.82 (Finally) 72 402.67 P
0.82 (, are there cases where the policy does not guarantee a consistent single image of the \336le) 102.42 402.67 P
0.03 (system across clients? The rest of this section addresses these issues. I show that the policy is nec-) 72 389.67 P
0.79 (essary to prevent stale data errors, but that it is not invoked often enough to degrade \336le system) 72 376.67 P
0.81 (performance, and that it provides a consistent view of the \336le system except during the unlikely) 72 363.67 P
(event of a network partition.) 72 350.67 T
0.75 (The \336rst question is whether a weaker but simpler cache consistency policy would suf) 82.8 325.67 P
0.75 (\336ce. T) 470.45 325.67 P
0.75 (o) 498.51 325.67 P
-0.04 (estimate the negative impact of a weaker cache consistency scheme than Sprite\325) 72 312.67 P
-0.04 (s, I used Sprite \336le) 422.08 312.67 P
0.56 (system traces to simulate a cache consistency mechanism similar to that in an implementation of) 72 299.67 P
0.23 (NFS. In the simulated mechanism, a client considers data in its cache to be valid for a \336xed inter-) 72 286.67 P
0.43 (val of time \050the) 72 273.67 P
2 F
0.43 (r) 143.91 273.67 P
0.43 (efr) 147.77 273.67 P
0.43 (esh interval) 159.57 273.67 P
1 F
0.43 (\051; on the next access to the \336le after the expiration of the interval,) 211.58 273.67 P
0.47 (the client polls the \336le server and updates its cache if necessary) 72 260.67 P
0.47 (. New data from clients is written) 354.41 260.67 P
0.43 (through to the server almost immediately in order to make it available to other clients. But if one) 72 247.67 P
-0.17 (workstation has cached data for a \336le while another workstation modi\336es the \336le, the \336rst worksta-) 72 234.67 P
(tion may continue to use its stale cache data until the end of its refresh interval.) 72 221.67 T
1.12 (T) 82.8 196.67 P
1.12 (o drive the simulation, I used a set of eight 24-hour traces of Sprite \336le system activity) 88.74 196.67 P
1.12 (. T) 485.94 196.67 P
1.12 (o) 498.51 196.67 P
1.33 (obtain these traces, we instrumented our \336le server kernels to record logical \336le system events) 72 183.67 P
-0.22 (such as \336le opens and closes. Because Sprite clients send all open and close requests through to the) 72 170.67 P
1.07 (server) 72 157.67 P
1.07 (, we are able to trace much of the cache behavior of individual clients. More information) 98.4 157.67 P
(about theses traces can be found in [Baker91b].) 72 144.67 T
1.38 (T) 82.8 119.67 P
1.38 (able 1-1 presents the results of these simulations. A 60-second refresh interval would have) 88.74 119.67 P
0.38 (resulted in many uses of stale data each hour) 72 106.67 P
0.38 (, and one-half of all users would have accessed stale) 271.12 106.67 P
-0.26 (data over a 24-hour period. Although a three-second refresh interval reduces errors, about three out) 72 93.67 P
FMENDPAGE
%%EndPage: "11" 23
%%Page: "12" 23
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(12) 318 55 T
1 11 Q
0.01 (of 52 users would still have received stale data at some point in an average 24-hour period. This is) 108 123.67 P
0.34 (still a lar) 108 110.67 P
0.34 (ge number of potential \336le access errors, particularly when compared to other sources of) 146.93 110.67 P
0.5 (error such as undetected network or disk errors. The level of \336le sharing in Sprite makes a cache) 108 97.67 P
(consistency policy necessary) 108 84.67 T
(.) 234.21 84.67 T
(Figure 1-3. Sprite cache consistency call-backs.) 219.2 325.67 T
1 10 Q
0.09 (This time line illustrates the sequence of calls and cache consistency call-backs that occur) 144 303.33 P
0.88 (in Sprite during sequential and concurrent write-sharing of a \336le. Consistency callbacks) 144 292.33 P
-0.09 (from the server are in italics. For sequential write-sharing, the server responds to larceny\325) 144 281.33 P
-0.09 (s) 500.11 281.33 P
0.39 (second \336le open request by \336rst calling back to gluttony to ask that it write back its dirty) 144 270.33 P
0.82 (data for the \336le. By checking the \336le\325) 144 259.33 P
0.82 (s version number in the open reply) 298.52 259.33 P
0.82 (, larceny learns) 441.58 259.33 P
0.07 (that another client has updated the \336le. Larceny then invalidates its own cache for the \336le.) 144 248.33 P
0.21 (It can then read the most recent data for the \336le from the server) 144 237.33 P
0.21 (. In concurrent write-shar-) 398.47 237.33 P
-0.04 (ing, the server responds to gluttony\325) 144 226.33 P
-0.04 (s request to open the \336le for writing by calling back to) 287.61 226.33 P
0.18 (larceny to tell it to invalidate its cache and stop caching the \336le. As part of the reply from) 144 215.33 P
0.07 (the open request, the server informs gluttony that the \336le is not cacheable. In this way) 144 204.33 P
0.07 (, the) 486.71 204.33 P
1.08 (server tuns of) 144 193.33 P
1.08 (f client caching for the \336le. During concurrent write-sharing, all read and) 200.38 193.33 P
108 161 540 179 C
108 161 540 179 R
7 X
0 K
V
108 170 540 170 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(write requests from the clients go through to the \336le server) 144 182.33 T
(.) 377.73 182.33 T
108 351 540 720 C
108 351 540 708 C
483 661 483 384 2 L
0.5 H
2 Z
11 X
0 K
N
414 664 414 387 2 L
N
345 669 345 384 2 L
N
267 663 267 363 2 L
N
129 671 129 364 2 L
N
198 666 198 364 2 L
N
1 12 Q
0 X
(server) 181 673 T
(larceny) 115 675 T
(gluttony) 241 673 T
186.79 659.3 198 655 186.22 652.71 186.51 656 4 Y
V
129 661 186.51 656 2 L
N
1 10 Q
(open \336le for reading) 133 645 T
(open reply: cacheable) 133 621 T
(close \336le) 133 593 T
(close reply) 134 565 T
(open \336le for writing) 204 560 T
(open reply: cacheable) 203 533 T
(close \336le) 204 508 T
(close reply) 204 485 T
(open \336le for reading) 134 467.17 T
2 F
(write back dirty data) 204.44 444 T
1 F
(write) 204.46 399.67 T
(open reply: cacheable, new version) 133 368 T
0 12 Q
(time) 297 684 T
311.62 402.3 306.66 385 301.7 402.3 306.66 402.3 4 Y
V
306.66 674 306.66 402.3 2 L
2 H
N
1 F
(server) 397 671 T
(larceny) 331 673 T
(gluttony) 457 671 T
1 10 Q
(open \336le for reading) 349 640 T
(open reply: cacheable) 349 616 T
(open \336le for writing) 420 591 T
(open reply: not cacheable) 418 507 T
2 F
(invalidate cache for \336le) 351 563 T
1 F
(call-back reply) 352 535 T
(read) 351.8 431.17 T
(read reply) 351 404.17 T
(write) 419 473 T
267.8 693.07 136.2 693.07 2 L
V
1.14 H
0 Z
N
0 12 Q
(Sequential Write-Sharing) 136.2 694.25 T
497.79 692.07 360.21 692.07 2 L
V
N
(Concurrent Write-Sharing) 360.21 693.25 T
471.79 520.3 482.99 516 471.22 513.71 471.5 517 4 Y
V
414 522 471.51 517 2 L
0.5 H
2 Z
N
356.77 623.71 345 626 356.2 630.3 356.49 627 4 Y
V
414 632 356.49 627 2 L
N
138.78 626.71 127 629 138.2 633.3 138.49 630 4 Y
V
196 635 138.49 630 2 L
N
187.79 605.3 199 601 187.22 598.71 187.51 602 4 Y
V
130 607 187.51 602 2 L
N
139.78 572.71 128 575 139.2 579.3 139.49 576 4 Y
V
197 581 139.49 576 2 L
N
208.78 565.71 197 568 208.2 572.3 208.49 569 4 Y
V
266 574 208.49 569 2 L
N
257.79 546.3 269 542 257.22 539.71 257.51 543 4 Y
V
200 548 257.51 543 2 L
N
207.78 515.71 196 518 207.2 522.3 207.49 519 4 Y
V
265 524 207.49 519 2 L
N
257.79 497.3 269 493 257.22 490.71 257.51 494.01 4 Y
V
200 499 257.51 494 2 L
N
186.79 481.3 198 477 186.22 474.71 186.51 478.01 4 Y
V
129 483 186.51 478 2 L
N
258.35 458.97 269.49 454.51 257.68 452.39 258.02 455.68 4 Y
V
200.5 461.5 258.02 455.67 2 L
N
142.28 377.21 130.5 379.51 141.7 383.8 141.99 380.51 4 Y
V
199.5 385.5 141.99 380.5 2 L
N
208.28 429.71 196.5 432.01 207.7 436.3 207.99 433.01 4 Y
V
265.5 438 207.99 433 2 L
N
402.79 442.3 413.99 438 402.22 435.71 402.5 439.01 4 Y
V
345 444 402.51 439 2 L
N
404.79 549.3 415.99 545 404.22 542.71 404.5 546 4 Y
V
347 551 404.51 546 2 L
N
401.79 654.3 413 650 401.22 647.71 401.5 651 4 Y
V
344 656 401.51 651 2 L
N
356.78 408.71 345 411 356.2 415.3 356.49 412.01 4 Y
V
414 417 356.49 412 2 L
N
424.77 597.71 412.99 600 424.2 604.3 424.49 601 4 Y
V
482 606 424.49 601 2 L
N
424.77 479.71 412.99 482 424.2 486.3 424.49 483.01 4 Y
V
482 488 424.49 483 2 L
N
355.78 568.71 344 571 355.2 575.3 355.49 572 4 Y
V
413 577 355.49 572 2 L
N
471.79 460.3 482.99 456 471.22 453.71 471.5 457.01 4 Y
V
414 462 471.51 457 2 L
N
1 10 Q
(write reply) 420.42 448.17 T
255.79 392.8 267 388.51 255.22 386.21 255.51 389.51 4 Y
V
198 394.5 255.51 389.5 2 L
N
209.78 407.21 198 409.51 209.2 413.8 209.49 410.51 4 Y
V
267 415.5 209.49 410.5 2 L
N
(call-back reply) 203.92 422.17 T
(write reply) 204.46 381.67 T
108 351 540 720 C
108 351 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "12" 24
%%Page: "13" 24
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(13) 282 55 T
1 11 Q
0.67 (Sprite is not the only environment in which \336le write-sharing occurs. A year) 82.8 465.17 P
0.67 (-long trace of \336le) 426.01 465.17 P
0.16 (activity in AFS [Satyan90], a distributed system with over 400 users, also shows some sharing. In) 72 452.17 P
0.97 (AFS, the chances of a \336le being modi\336ed by two dif) 72 439.17 P
0.97 (ferent users in less than a day are between) 311.33 439.17 P
0.34 (0.09% and 0.72%, depending upon the type of \336le [Kistle91]. While the measurements show less) 72 426.17 P
0.41 (sharing than in Sprite, they still indicate a signi\336cant percentage of possible consistency errors in) 72 413.17 P
-0.24 (the absence of an ef) 72 400.17 P
-0.24 (fective cache consistency policy) 158.08 400.17 P
-0.24 (. Also, these measurements do not include pos-) 298.5 400.17 P
(sible consistency violations due to the same user modifying a \336le on more than one machine.) 72 387.17 T
-0.17 (The Sprite environment, however) 82.8 362.17 P
-0.17 (, encourages users to share \336les between machines. In Sprite, a) 229.54 362.17 P
0.58 (user may edit, compile, and run the same program on dif) 72 349.17 P
0.58 (ferent machines and trust that the cache) 326.61 349.17 P
0.93 (consistency policy will handle con\337icts. Sprite also allows processes to migrate transparently to) 72 336.17 P
0.83 (idle nodes in the network. As a process migrates from one machine to another) 72 323.17 P
0.83 (, its data accesses) 424.64 323.17 P
0.43 (can cause sequential sharing across those machines. As a result, same-user \336le modi\336cations in a) 72 310.17 P
(system such as Sprite can require a cache consistency policy) 72 297.17 T
(.) 337.03 297.17 T
0.17 (The same trace data from Sprite helps answer the second question: whether consistency actions) 82.8 272.17 P
0.18 (are invoked often enough to degrade overall performance. T) 72 259.17 P
0.18 (able 1-2 presents this data. About one) 337.21 259.17 P
1.86 (in every 300 \336le opens causes a \336le to be opened for reading and writing on more than one) 72 246.17 P
0.78 (machine. In addition, for about one in every 60 opens, the server recalls dirty data from another) 72 233.17 P
0.86 (client\325) 72 220.17 P
0.86 (s cache in order to obtain the most recent version of a \336le. This is an upper bound on the) 99.47 220.17 P
0.8 (required number of server recalls, because the Sprite server actually issues more call-backs than) 72 207.17 P
-0.17 (necessary) 72 194.17 P
-0.17 (. It sometimes fails to keep track of whether a client has already \336nished \337ushing its dirty) 113.99 194.17 P
0.89 (data back to the server via the delayed write mechanism of the cache. Our conclusion from this) 72 181.17 P
0.09 (data is that Sprite\325) 72 168.17 P
0.09 (s cache consistency actions are not invoked often enough to have a lar) 151.91 168.17 P
0.09 (ge impact) 460.89 168.17 P
(on overall performance.) 72 155.17 T
0.31 (The last question is whether there are cases for which Sprite\325) 82.8 130.17 P
0.31 (s cache consistency policy fails to) 353.22 130.17 P
1.12 (guarantee a consistent image of the \336le system across clients. Sprite\325) 72 117.17 P
1.12 (s cache consistency policy) 384.39 117.17 P
-0 (works well unless a network partition occurs between the server and a client. If a server loses con-) 72 104.17 P
0.46 (tact with a client for a signi\336cant period of time \050explained in chapter 3\051, the server assumes that) 72 91.17 P
72 81 504 720 C
73.61 472.5 502.39 720 C
73.61 477 501.11 715.5 R
7 X
0 K
V
1 10 Q
0 X
(Measurement) 164.27 675.83 T
(60-second) 315.52 675.83 T
(3-second) 413.92 675.83 T
(A) 98.9 657.83 T
(verage errors per hour) 105.38 657.83 T
(18 \0508-53\051) 342.63 657.83 T
(0.59 \0500.12-1.8\051) 415.86 657.83 T
(Percent of users af) 98.9 639.83 T
(fected during 24 hours) 172.82 639.83 T
(48 \05038-54\051) 337.63 639.83 T
(7.1 \0504.5-12\051) 428.35 639.83 T
(Percent of users af) 98.9 621.83 T
(fected over all traces) 172.82 621.83 T
(63 \050NA\051) 346.52 621.83 T
(20 \050NA\051) 442.24 621.83 T
(Percent of \336le opens with error) 98.9 603.83 T
(0.34 \0500.21-0.93\051) 315.14 603.83 T
(0.01) 391.24 603.83 T
(1 \0500.0001-0.032\051) 408.36 603.83 T
1 11 Q
(T) 226.73 579.17 T
(able 1-1. Stale data errors.) 232.67 579.17 T
1 10 Q
0.11 (This table lists results from simulations of a weaker cache consistency mechanism based) 109.61 554.83 P
0.25 (on polling: clients refresh their caches by checking the server for newer data at intervals) 109.61 543.83 P
0.66 (of 60 seconds or three seconds. Errors are de\336ned as potential uses of stale cache data.) 109.61 532.83 P
1.27 (Ef) 109.61 521.83 P
1.27 (fected users are those whose processes suf) 118.87 521.83 P
1.27 (fered errors. The numbers in parentheses) 295.58 521.83 P
0.31 (give the minimum and maximum values among the eight traces. NA means not applica-) 109.61 510.83 P
73.61 478.5 501.11 496.5 C
73.61 478.5 501.11 496.5 R
7 X
0 K
V
73.61 487.5 505.61 487.5 2 L
V
0.5 H
2 Z
0 X
N
73.61 472.5 502.39 720 C
1 10 Q
0 X
0 K
(ble.) 109.61 499.83 T
94.9 685.5 94.9 597.5 2 L
V
2 H
0 Z
N
288.03 687.5 288.03 595.5 2 L
V
N
384.1 687.5 384.1 595.5 2 L
V
0.5 H
N
479.82 685.5 479.82 597.5 2 L
V
2 H
N
93.9 686.5 480.82 686.5 2 L
V
N
95.9 669.75 478.82 669.75 2 L
V
0.5 H
N
95.9 667.25 478.82 667.25 2 L
V
N
93.9 650.5 480.82 650.5 2 L
V
N
93.9 632.5 480.82 632.5 2 L
V
N
93.9 614.5 480.82 614.5 2 L
V
N
93.9 596.5 480.82 596.5 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "13" 25
%%Page: "14" 25
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(14) 318 55 T
1 11 Q
0.52 (the client has crashed. The server will then clean up the cache state associated with the client, so) 108 485.66 P
-0.03 (that it can grant requests from other clients to access \336les that were cached by the lost client. If the) 108 472.66 P
0.55 (lost client has not actually crashed, though, it will still have the \336les cached. During the network) 108 459.66 P
1.17 (partition, it will not see other clients\325 modi\336cations to its \336les, thus violating the single-system) 108 446.66 P
-0.05 (image of the \336le system. Also, when the lost client is able to contact the server again, it will not be) 108 433.66 P
0.81 (permitted to write its dirty data back to the server for any \336le that has been modi\336ed during the) 108 420.66 P
0.88 (partition by another client. In this sense, the isolated client is treated as if it crashed and lost its) 108 407.66 P
1.73 (dirty data. The Echo system, described later in this section, guarantees a single-system image) 108 394.66 P
0.89 (across clients even during a network partition, but it too can lose dirty data on clients separated) 108 381.66 P
0.06 (from their server) 108 368.66 P
0.06 (. Fortunately) 181.34 368.66 P
0.06 (, on Sprite\325) 236.84 368.66 P
0.06 (s locally-distributed network, we almost never experience) 285.48 368.66 P
(network partitions. This could be a more severe problem in a wider) 108 355.66 T
(-area network.) 403.14 355.66 T
0 12 Q
(1.1.4. Sprite\325) 108 323.99 T
(s Distributed Cache State Recovery Pr) 172.85 323.99 T
(oblem) 369.48 323.99 T
1 11 Q
-0.08 (Keeping distributed cache state in main memory data structures on the \336le server solves Sprite\325) 118.8 298.66 P
-0.08 (s) 535.73 298.66 P
0.77 (cache consistency problem, but it creates a crash recovery problem. The cache state information) 108 285.66 P
0.74 (can be lost when the \336le server crashes and must be recovered before the server can continue to) 108 272.66 P
(satisfy client requests while maintaining cache consistency) 108 259.66 T
(.) 366.04 259.66 T
0.05 (Originally) 118.8 234.66 P
0.05 (, Sprite did not attempt to recover distributed cache state. T) 163.25 234.66 P
0.05 (o avoid cache inconsisten-) 423.6 234.66 P
1.12 (cies after a server failure, users were forced to reboot their client workstations. While this now) 108 221.66 P
-0.17 (sounds like a bad decision, it did not seem so before we acquired much experience with distributed) 108 208.66 P
0.85 (computing. After all, in a central time-shared system, terminal users must all login again after a) 108 195.66 P
1.6 (machine crash. But workstation users keep more state information locally than terminal users;) 108 182.66 P
1.39 (window set-ups and on-going processes are inconvenient to restart. The situation soon became) 108 169.66 P
-0.16 (intolerable. Clearly) 108 156.66 P
-0.16 (, Sprite needed a mechanism to recover distributed cache state that would allow) 191.95 156.66 P
1.68 (client workstations to continue to operate seamlessly after a server reboot, without losing any) 108 143.66 P
(information.) 108 130.66 T
1.41 (This thesis evaluates three such methods for recovering distributed state, all implemented in) 118.8 105.66 P
0.35 (Sprite. The \336rst method, described in chapter 3, is client-driven recovery) 108 92.66 P
0.35 (, in which clients initiate) 430.26 92.66 P
108 81 540 720 C
108 492.99 540 720 C
107.5 502 539.5 715.5 R
7 X
0 K
V
1 11 Q
0 X
(T) 233.92 605.17 T
(able 1-2. Consistency action frequency) 239.87 605.17 T
(.) 410.32 605.17 T
1 10 Q
0.04 (This table gives the frequency of various consistency actions, measured as a percent of all) 143.5 580.83 P
0.49 (\336le opens, excluding directories. Concurrent write-sharing refers to opens that result in a) 143.5 569.83 P
0.02 (\336le being open on multiple machines and open for writing on at least one machine. Server) 143.5 558.83 P
1.15 (recall refers to opens for which the \336le\325) 143.5 547.83 P
1.15 (s current data resides on another client and the) 308.9 547.83 P
0.15 (server must retrieve it. The numbers in parentheses give the minimum and maximum val-) 143.5 536.83 P
108 504.5 539.5 522.5 C
107.5 504.5 539.5 522.5 R
7 X
0 K
V
107.5 513.5 539.5 513.5 2 L
V
0.5 H
2 Z
0 X
N
108 492.99 540 720 C
1 10 Q
0 X
0 K
(ues among the eight traces.) 143.5 525.83 T
(T) 245.2 675.83 T
(ype of action) 250.61 675.83 T
(File opens \050%\051) 354.07 675.83 T
(Concurrent write-sharing) 218 657.83 T
(0.34 \0500.18-0.56\051) 364.04 657.83 T
(Server recall) 218 639.83 T
(1.7 \0500.79-3.35\051) 369.04 639.83 T
214 685.5 214 633.5 2 L
V
2 H
0 Z
N
334 687.5 334 631.5 2 L
V
N
433 685.5 433 633.5 2 L
V
N
213 686.5 434 686.5 2 L
V
N
215 669.75 432 669.75 2 L
V
0.5 H
N
215 667.25 432 667.25 2 L
V
N
213 650.5 434 650.5 2 L
V
N
213 632.5 434 632.5 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "14" 26
%%Page: "15" 26
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(15) 282 55 T
1 11 Q
0.57 (recovery with the server) 72 712.67 P
0.57 (. The central idea for this technique is that each client workstation keeps) 179.57 712.67 P
0.03 (track of the \336les it has open or cached. Thus each workstation has a copy of its own state informa-) 72 699.67 P
-0.16 (tion. T) 72 686.67 P
-0.16 (o recover) 100.37 686.67 P
-0.16 (, the clients send their state information to the server) 140.95 686.67 P
-0.16 (, and the server uses this infor-) 369.78 686.67 P
0.4 (mation to rebuild its distributed cache state. The second method, described in chapter 4 is server) 72 673.67 P
0.4 (-) 500.34 673.67 P
0.29 (driven recovery) 72 660.67 P
0.29 (. This is a modi\336cation of client-driven recovery in which the server initiates con-) 140.82 660.67 P
0.96 (tact with the clients to request their state information. The third method is transparent recovery) 72 647.67 P
0.96 (,) 501.25 647.67 P
0.37 (described in chapter 5. For transparent recovery the server keeps the distributed state information) 72 634.67 P
0.65 (in stable storage, preserving it across failures. After a failure the server retrieves the information) 72 621.67 P
(from its stable storage, so that it does not need to communicate with clients to recover) 72 608.67 T
(.) 449.16 608.67 T
0.03 (This thesis concentrates on recovery in Sprite, but many other systems have the same task. Like) 82.8 583.67 P
0.36 (Sprite, these systems cache \336le data on clients for performance but keep distributed state to guar-) 72 570.67 P
2.42 (antee client cache consistency) 72 557.67 P
2.42 (. The following sections describe how three other \336le systems) 210.65 557.67 P
0.85 (recover their distributed cache state. The choice of recovery mechanism in the \336rst two systems) 72 544.67 P
0.42 (was in\337uenced by Sprite. Spritely NFS [Mogul92][Mogul93][Sriniv89] uses server) 72 531.67 P
0.42 (-driven recov-) 441.04 531.67 P
1.52 (ery) 72 518.67 P
1.52 (, and DEcorum [Kazar90] uses client-driven recovery) 85.32 518.67 P
1.52 (. The third system, Echo [Hisgen89][-) 329.52 518.67 P
0.18 (Mann93], instead maintains a backup server with a copy of the distributed state. This technique is) 72 505.67 P
0.67 (similar to transparent recovery) 72 492.67 P
0.67 (, except that the stable storage for the server) 207.84 492.67 P
0.67 (\325) 407.33 492.67 P
0.67 (s state is actually the) 410.39 492.67 P
(main memory of another server) 72 479.67 T
(.) 209.91 479.67 T
0.45 (Unfortunately) 82.8 454.67 P
0.45 (, the following sections provide only limited recovery performance data. Spritely) 143.72 454.67 P
-0 (NFS is the only one of the three systems to publish such data so far) 72 441.67 P
-0 (. While other aspects of system) 366.72 441.67 P
(design and performance receive much attention in the literature, recovery usually does not.) 72 428.67 T
0 12 Q
(1.1.5. Spritely NFS) 72 397 T
1 11 Q
1.59 (Spritely NFS addresses the cache consistency and performance problems of NFS by adding) 82.8 371.67 P
0.35 (Sprite\325) 72 358.67 P
0.35 (s cache consistency protocol to NFS. A goal of Spritely NFS is to show that a stateful sys-) 101.3 358.67 P
1.32 (tem can provide strong cache consistency guarantees and high performance without a complex) 72 345.67 P
(recovery implementation.) 72 332.67 T
0.45 (T) 82.8 307.67 P
0.45 (o guarantee cache consistency) 88.74 307.67 P
0.45 (, Spritely NFS turns an NFS stateless server into stateful server) 222.09 307.67 P
0.32 (using protocols similar to those in Sprite. A Spritely NFS server maintains distributed cache state) 72 294.67 P
0.11 (that it uses to enforce cache consistency among its clients. T) 72 281.67 P
0.11 (o maintain the distributed cache state,) 337.47 281.67 P
0.97 (Spritely NFS modi\336es the NSF protocol to add new client-to-server open and close calls. As in) 72 268.67 P
-0.06 (Sprite, the server can then monitor which clients are caching which \336les by tracking their \336le open) 72 255.67 P
(and close requests.) 72 242.67 T
1.92 (The stateful server also addresses the performance problems of standard NFS. Because the) 82.8 217.67 P
1.05 (server can enforce cache consistency) 72 204.67 P
1.05 (, it is safe for clients to delay writing back dirty data from) 237.78 204.67 P
1.58 (their caches. Using this delayed write-back policy) 72 191.67 P
1.58 (, Spritely NFS clients gain improved perfor-) 300.14 191.67 P
0.11 (mance over standard NFS clients which must use a write-through-on-close policy to reduce possi-) 72 178.67 P
(ble cache consistency violations.) 72 165.67 T
-0.22 (T) 82.8 140.67 P
-0.22 (o recover the cache state information after a server crash, Spritely NFS uses an implementation) 88.74 140.67 P
0.32 (of the server) 72 127.67 P
0.32 (-driven recovery described in chapter 4. On disk, the server keeps track of which cli-) 127.33 127.67 P
0.76 (ents it must contact for recovery) 72 114.67 P
0.76 (. After rebooting it asks those clients to send it their cache state) 216.95 114.67 P
0.28 (information. The server regenerates its cache state information by combining the state sent by the) 72 101.67 P
FMENDPAGE
%%EndPage: "15" 27
%%Page: "16" 27
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(16) 318 55 T
1 11 Q
0.15 (clients. Server state recovery takes about two seconds for a single client with 393 open \336les. Thus) 108 712.67 P
(recovery seems to take about \336ve to seven milliseconds per open \336le.) 108 699.67 T
-0.09 (Spritely NFS makes a strong ar) 118.8 674.67 P
-0.09 (gument in favor of stateful systems. It shows that it is possible to) 255.77 674.67 P
0.37 (make a few changes to a stateless protocol to turn it into a stateful one and gain performance and) 108 661.67 P
(cache consistency advantages without introducing great complexity) 108 648.67 T
(.) 404.48 648.67 T
0 12 Q
(1.1.6. DEcorum) 108 617 T
1 11 Q
-0.09 (T) 118.8 591.67 P
-0.09 (ransarc\325) 125.13 591.67 P
-0.09 (s DEcorum [Kazar90] \336le system for the Distributed Computing Environment is based) 159.9 591.67 P
-0.17 (on a previous \336le system called AFS [Howard88][Satyan90] but has made several modi\336cations to) 108 578.67 P
-0.03 (provide higher performance and stricter cache consistency guarantees. While AFS only allows cli-) 108 565.67 P
0.86 (ents to cache \336le data on their local disks, DEcorum allows diskless clients to cache \336le data in) 108 552.67 P
0.47 (their main memories for higher performance. DEcorum also uses a delayed write-back policy for) 108 539.67 P
-0.02 (cached dirty data on clients, rather than AFS\325) 108 526.67 P
-0.02 (s write-through-on close policy) 306.8 526.67 P
-0.02 (. This provides higher) 443.63 526.67 P
-0.27 (performance and better cache consistency guarantees. W) 108 513.67 P
-0.27 (ith these features, DEcorum\325) 355.18 513.67 P
-0.27 (s use of client) 480.08 513.67 P
(caching is very similar to Sprite\325) 108 500.67 T
(s.) 251.12 500.67 T
0.43 (DEcorum also uses a cache consistency policy similar to Sprite\325) 118.8 475.67 P
0.43 (s. DEcorum provides a consis-) 403.71 475.67 P
0.62 (tent single-image of the \336le system across clients, but it implements its cache consistency policy) 108 462.67 P
0.64 (using) 108 449.67 P
2 F
0.64 (tokens) 135.2 449.67 P
1 F
0.64 (. A token represents permission to access a \336le or other object in some manner) 163.27 449.67 P
0.64 (. The) 516.78 449.67 P
0.01 (token manager on the \336le server grants tokens in response to client requests to open, read, write or) 108 436.67 P
1.22 (otherwise access \336les. A client must not read or write cached \336le data until it has received the) 108 423.67 P
0.72 (appropriate token from the \336le server) 108 410.67 P
0.72 (. As in Sprite, the server) 274.84 410.67 P
0.72 (\325) 385.35 410.67 P
0.72 (s token manager intercepts all \336le) 388.4 410.67 P
0.76 (open and close requests \050and all other client calls through the Vnode [Kleima86] interface\051. The) 108 397.67 P
0.93 (token manager keeps track of which clients have which type of tokens for which \336les. If a new) 108 384.67 P
0.08 (token request could cause a cache consistency con\337ict, the manager calls back to clients to revoke) 108 371.67 P
0.46 (the con\337icting tokens, thereby notifying the clients that their cached data will no longer be valid.) 108 358.67 P
0.89 (When the manager revokes a write token, the client must also write back any modi\336ed \336le data) 108 345.67 P
0.11 (before returning the token. Thus DEcorum prevents cache inconsistencies during write-sharing by) 108 332.67 P
0.25 (ensuring that only one write token exists for the shared data. This allows only one client at a time) 108 319.67 P
-0 (to modi\336y the shared data. Before that client is granted the write-token, the server revokes all read) 108 306.67 P
(tokens. This prevents other clients from reading stale shared data.) 108 293.67 T
-0.25 (DEcorum\325) 118.8 268.67 P
-0.25 (s cache consistency policy dif) 164.57 268.67 P
-0.25 (fers from Sprite\325) 294.55 268.67 P
-0.25 (s in a few ways. DEcorum clients cache) 366.66 268.67 P
0.4 (\336le status information as well as \336le data. The \336le status, or) 108 255.67 P
2 F
0.4 (attributes) 377.06 255.67 P
1 F
0.4 (, includes such information) 419.18 255.67 P
0.45 (as \336le size, ownership, and last modi\336cation date. Caching this information makes updates to the) 108 242.67 P
-0 (\336le attributes faster) 108 229.67 P
-0 (. Also, DEcorum can associate tokens with byte ranges on \336les, rather than just) 192.21 229.67 P
0.7 (whole \336les. This allows for \336ner) 108 216.67 P
0.7 (-grained \336le sharing. For example, one client can obtain a write) 254.1 216.67 P
0.09 (token for the beginning of a \336le, even if another client currently has a token for the end of the \336le.) 108 203.67 P
-0.14 (Thus one client can cache and modify the beginning of a \336le while another client caches the end of) 108 190.67 P
0.1 (the \336le. This may be of limited bene\336t, though, unless the level of \336le sharing increases in distrib-) 108 177.67 P
-0.24 (uted systems. Finally) 108 164.67 P
-0.24 (, in order to handle network partitions, servers wait two minutes before begin-) 199.9 164.67 P
0.35 (ning to grant token requests that con\337ict with those held by a client they assume to have crashed.) 108 151.67 P
0.57 (This allows the isolated client more of an opportunity to rejoin the system before its cached data) 108 138.67 P
-0.03 (can become stale. However) 108 125.67 P
-0.03 (, two minutes is a long time to delay the new token requests from other) 228.27 125.67 P
(clients.) 108 112.67 T
FMENDPAGE
%%EndPage: "16" 28
%%Page: "17" 28
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(17) 282 55 T
1 11 Q
-0.22 (DEcorum\325) 82.8 712.67 P
-0.22 (s recovery state problem is similar to Sprite\325) 128.57 712.67 P
-0.22 (s. If a DEcorum server crashes, it loses its) 321.44 712.67 P
2 (token information and must recover it. DEcorum uses an implementation of the client-driven) 72 699.67 P
0.32 (recovery technique described in chapter 3, but with more attention paid to recovery after network) 72 686.67 P
1.01 (partitions [Kazar93]. Clients detect when servers return after a crash or network partition. They) 72 673.67 P
-0.16 (then make calls to the server) 72 660.67 P
-0.16 (, and the server responds with an indication of whether it truly crashed) 196.18 660.67 P
0.5 (and lost the token information. For token recovery) 72 647.67 P
0.5 (, each client scans a table looking for \336les that) 296.3 647.67 P
1.24 (are either currently open or have cached dirty data. For each such \336le, the client then calls the) 72 634.67 P
1.48 (server to re-establish the token with it. Currently) 72 621.67 P
1.48 (, no performance data is available concerning) 295.27 621.67 P
(DEcorum\325) 72 608.67 T
(s token recovery protocol.) 117.77 608.67 T
0 12 Q
(1.1.7. Echo) 72 577 T
1 11 Q
0.62 (Echo [Hisgen89][Mann93] is interesting in the context of this dissertation for at least two rea-) 82.8 551.67 P
0.15 (sons: Echo provides high availability through replicated \336le server CPUs and disks, a method that) 72 538.67 P
2.82 (contrasts with Sprite\325) 72 525.67 P
2.82 (s approach, and it keeps distributed cache state information similar to) 171.01 525.67 P
-0.25 (Sprite\325) 72 512.67 P
-0.25 (s. This section describes both aspects of Echo, because Echo\325) 101.3 512.67 P
-0.25 (s use of replication af) 368.46 512.67 P
-0.25 (fects how) 461.84 512.67 P
(it performs distributed cache state recovery) 72 499.67 T
(.) 261.36 499.67 T
0.56 (For high availability) 82.8 474.67 P
0.56 (, Echo allows both \336le servers and disks to be replicated. Figure 1-4 illus-) 172.94 474.67 P
0.13 (trates an Echo system. W) 72 461.67 P
0.13 (ith this replication scheme, Echo remains available despite the crash of a) 183.44 461.67 P
0.34 (server CPU or a disk. When a primary server fails, its backup takes over the primary\325) 72 448.67 P
0.34 (s duties and) 451.45 448.67 P
(has access to the same disks. Likewise, if a disk fails, its replica is still available to the servers.) 72 435.67 T
0.37 (This replication scheme provides better availability than Sprite, but it is not simple and it costs) 82.8 410.67 P
0.55 (more, because it uses extra hardware. Besides the cost of the extra servers and disks, the scheme) 72 397.67 P
5.34 (uses special disk hardware and a high-bandwidth, low-latency network called Autonet) 72 384.67 P
-0.17 ([Rodehe91]. Echo disks are equipped with hardware that recognizes at most one server at a time as) 72 371.67 P
-0.05 (the disk\325) 72 358.67 P
-0.05 (s owner) 109.5 358.67 P
-0.05 (. This is necessary) 143.32 358.67 P
-0.05 (, because it is possible for a backup server to try to take over for) 223.02 358.67 P
0.02 (a primary that is merely slow but not actually down. The extra hardware prevents the servers from) 72 345.67 P
0.78 (both trying to access the same disk in this situation. Autonet makes it possible to detect crashed) 72 332.67 P
-0.18 (nodes in under a second. This allows a backup server to take over for a primary very quickly) 72 319.67 P
-0.18 (. Also,) 475.19 319.67 P
0.1 (as described below) 72 306.67 P
0.1 (, a low-latency network reduces overhead when a primary server CPU commu-) 155.08 306.67 P
(nicates with its backup to update the replicated main-memory cache state.) 72 293.67 T
0.07 (Like Sprite, Echo clients cache \336le data for high performance, but Echo\325) 82.8 268.67 P
0.07 (s client caching is even) 401.81 268.67 P
0.1 (more aggressive than Sprite\325) 72 255.67 P
0.1 (s in at least three ways. First, most of the client workstations dedicate) 197.7 255.67 P
0.61 (more than 16 megabytes to the cache. Sprite clients generally use about one-fourth of their main) 72 242.67 P
1.35 (memory for the \336le cache, for an average of seven out of 28 megabytes. Second, Echo clients) 72 229.67 P
0.08 (cache directories as well as \336les, so clients see very good performance when listing directory con-) 72 216.67 P
1.59 (tents. Sprite clients do not cache directories. Third, Echo allows clients to cache modi\336ed \336le) 72 203.67 P
(attributes as well as dirty \336le data. This speeds up operations that examine the status of \336les.) 72 190.67 T
0.82 (T) 82.8 165.67 P
0.82 (o guarantee cache consistency) 88.74 165.67 P
0.82 (, Echo uses a token scheme with) 223.2 165.67 P
2 F
0.82 (leases) 374.19 165.67 P
1 F
0.82 ( [Gray89]. A lease is a) 401.05 165.67 P
0.44 (time-out period associated with a token and agreed upon by both the server and the client. T) 72 152.67 P
0.44 (oken) 482.64 152.67 P
0.34 (managers on Echo \336le servers grant and revoke tokens to maintain cache consistency in the same) 72 139.67 P
-0.03 (way DEcorum token managers do. However) 72 126.67 P
-0.03 (, tokens granted by Echo servers are valid only for the) 266.65 126.67 P
0.02 (duration of the lease; they must be refreshed by the client before the time-out deadline in order for) 72 113.67 P
-0 (the client to continue to cache the associated \336le. The advantage of leases is that they simplify and) 72 100.67 P
0.45 (improve handling of network partitions. If a server loses contact with a client, the server waits to) 72 87.67 P
FMENDPAGE
%%EndPage: "17" 29
%%Page: "18" 29
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(18) 318 55 T
1 11 Q
-0.26 (revoke the client\325) 108 206.69 P
-0.26 (s tokens until they time-out. The client knows that its tokens are no longer valid if) 183.76 206.69 P
0.8 (it has been unable to refresh them with the server) 108 193.69 P
0.8 (. Unlike Sprite, this allows Echo to maintain a) 330.94 193.69 P
0.19 (consistent single-system image across clients even during network partition. Unfortunately) 108 180.69 P
0.19 (, leases) 508.08 180.69 P
0.04 (of) 108 167.69 P
0.04 (fer no further advantages if the client has dirty data in its cache. Any dirty data still on the client) 116.95 167.69 P
-0.06 (during a network partition may have to be discarded when the client\325) 108 154.69 P
-0.06 (s tokens time-out. This is true) 409.69 154.69 P
-0.09 (even if the application that created the dirty data has already exited assuming it wrote the data suc-) 108 141.69 P
(cessfully) 108 128.69 T
(.) 146.34 128.69 T
0.84 (Echo\325) 118.8 103.69 P
0.84 (s cache consistency policy dif) 144.43 103.69 P
0.84 (fers from Sprite\325) 278.8 103.69 P
0.84 (s by allowing more caching during write-) 353.1 103.69 P
0.69 (sharing. In Sprite, a \336le under) 108 90.69 P
0.69 (going concurrent write-sharing is marked uncacheable. In Echo, at) 242.17 90.69 P
(Figure 1-4. The Echo system.) 259.01 309.69 T
1 10 Q
0.41 (This \336gure illustrates replication of \336le servers and disks in the Echo distributed \336le sys-) 144 287.36 P
0.55 (tem. If the primary server fails, the secondary can take over) 144 276.36 P
0.55 (, because it has access to the) 387.2 276.36 P
108 244.02 540 262.02 C
108 244.02 540 262.02 R
7 X
0 K
V
108 253.02 540 253.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(same disks. If a disk fails, its replica is available to the servers.) 144 265.36 T
108 335.02 540 720 C
108 335.02 540 708 C
7 X
0 K
90 450 36 10 369 376 G
0.5 H
0 Z
0 X
90 450 36 10 369 376 A
7 X
90 450 36 10 369 385 G
0 X
90 450 36 10 369 385 A
7 X
90 450 36 10 369 394 G
0 X
90 450 36 10 369 394 A
7 X
90 450 36 10 369 403 G
0 X
90 450 36 10 369 403 A
1 12 Q
(disk replica) 342.01 399.82 T
7 X
90 450 39.31 39.5 227.19 661.01 G
0 X
90 450 39.31 39.5 227.19 661.01 A
196.76 637.17 258.29 662.79 R
5 X
V
0 X
N
196.76 637.17 258.29 675.6 R
N
(\336le cache) 209.07 665.55 T
(client) 213.39 682.63 T
7 X
90 450 39.31 39.5 429.81 662.01 G
0 X
90 450 39.31 39.5 429.81 662.01 A
399.39 638.17 460.92 663.79 R
5 X
V
0 X
N
399.39 638.17 460.92 676.6 R
N
(\336le cache) 411.69 666.55 T
(client) 416.01 683.63 T
121.5 590.51 526.5 590.51 2 L
3 H
2 Z
N
222.06 629.71 227.53 649.98 233.64 629.89 227.85 629.8 4 Y
V
233.96 609.79 228.5 589.51 222.39 609.6 228.17 609.7 4 Y
V
227.85 629.8 228.18 609.7 2 L
0 Z
N
423.06 630.71 428.52 650.98 434.64 630.89 428.85 630.8 4 Y
V
434.96 610.79 429.49 590.51 423.38 610.6 429.17 610.7 4 Y
V
428.85 630.8 429.18 610.7 2 L
N
(network) 133.5 570.51 T
7 X
90 450 36 10 270 376 G
0.5 H
0 X
90 450 36 10 270 376 A
7 X
90 450 36 10 270 385 G
0 X
90 450 36 10 270 385 A
7 X
90 450 36 10 270 394 G
0 X
90 450 36 10 270 394 A
7 X
90 450 36 10 270 403 G
0 X
90 450 36 10 270 403 A
(disk) 261.01 400.82 T
289.67 580.73 307.99 591.01 297.9 572.59 293.79 576.66 4 Y
V
284.81 559.77 266.49 549.5 276.58 567.91 280.69 563.84 4 Y
V
293.8 576.66 280.7 563.83 2 L
7 X
V
3 H
0 X
N
367.57 572.59 357.48 591.01 375.8 580.73 371.69 576.66 4 Y
V
388.89 567.91 398.98 549.5 380.67 559.77 384.78 563.84 4 Y
V
371.7 576.66 384.8 563.83 2 L
7 X
V
0 X
N
7 X
90 450 57.5 55.5 242.5 500.5 G
0.5 H
0 X
90 450 57.5 55.5 242.5 500.5 A
198 467 288 503 R
5 X
V
0 X
N
198 467 288 521 R
N
(\336le cache) 216 508 T
(\336le server) 215 528 T
7 X
90 450 57.5 55.5 414.5 495.5 G
0 X
90 450 57.5 55.5 414.5 495.5 A
370 462 460 498 R
5 X
V
0 X
N
370 462 460 516 R
N
(\336le cache) 388 503 T
(\336le server) 389 523 T
(primary) 224 540 T
(secondary) 389 534 T
257.05 434.54 255.44 446.43 263.1 437.2 260.08 435.87 4 Y
V
268.39 424.9 269.99 413.01 262.33 422.25 265.36 423.58 4 Y
V
260.08 435.86 265.37 423.56 2 L
1 H
N
385.33 437.2 392.99 446.43 391.38 434.54 388.36 435.87 4 Y
V
386.1 422.25 378.44 413.01 380.04 424.9 383.07 423.58 4 Y
V
388.37 435.86 383.08 423.56 2 L
N
281.99 412.92 269.99 413.01 280.22 419.29 281.11 416.11 4 Y
V
380.99 446.52 392.99 446.43 382.77 440.15 381.88 443.34 4 Y
V
281.11 416.1 381.89 443.33 2 L
N
366.77 420.29 376.99 414.01 364.99 413.92 365.88 417.11 4 Y
V
264.22 441.15 253.99 447.43 265.99 447.53 265.11 444.34 4 Y
V
365.89 417.1 265.11 444.33 2 L
N
7 X
90 450 39.31 39.5 329.19 664.01 G
0.5 H
0 X
90 450 39.31 39.5 329.19 664.01 A
298.77 640.17 360.29 665.79 R
5 X
V
0 X
N
298.77 640.17 360.29 678.6 R
N
(\336le cache) 311.07 668.55 T
(client) 315.39 685.63 T
324.06 632.71 329.53 652.98 335.64 632.89 329.85 632.8 4 Y
V
335.96 612.79 330.5 592.51 324.39 612.6 330.17 612.7 4 Y
V
329.85 632.8 330.18 612.7 2 L
3 H
N
108 335.02 540 720 C
108 335.02 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "18" 30
%%Page: "19" 30
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(19) 282 55 T
1 11 Q
1.78 (least one client is always allowed to cache a \336le, even during concurrent write-sharing. Echo) 72 712.67 P
0.28 (makes this increased sharing possible by granting cache tokens for read and write requests, rather) 72 699.67 P
0.51 (than handling cache consistency based only on \336le open and close requests. If two clients have a) 72 686.67 P
0.05 (\336le open for concurrent write-sharing, tokens for the \336le will pass back and forth between them as) 72 673.67 P
-0 (they each issue read and write requests. This is an advantage unless the tokens pass back and forth) 72 660.67 P
-0.16 (frequently) 72 647.67 P
-0.16 (, in which case the token approach will generate just as much traf) 116.44 647.67 P
-0.16 (\336c as Sprite: the caches) 401.49 647.67 P
0.38 (will be \337ushed continuously by token recalls, whole cache blocks will be reread many times, and) 72 634.67 P
(there will be additional overhead for issuing and recalling tokens.) 72 621.67 T
0.84 (Like Sprite, Echo must recover its distributed cache state after a server failure, but Echo uses) 82.8 596.67 P
0.77 (server replication to accomplish this. The token information constitutes Echo\325) 72 583.67 P
0.77 (s distributed cache) 420.69 583.67 P
0.06 (state. Unlike Sprite, Echo is able to take advantage of its replicated \336le servers for token recovery) 72 570.67 P
0.06 (.) 501.25 570.67 P
1.3 (Echo stores the token information in main memory on both the primary server and its backup.) 72 557.67 P
0.86 (Before granting any token request to a client, the primary server sends a message to the backup) 72 544.67 P
-0.06 (causing it to update its copy of the token information. Updating the token information in the mem-) 72 531.67 P
0.64 (ory of the backup server is faster than updating it on disk. And because Echo already uses repli-) 72 518.67 P
1.03 (cated servers for high availability) 72 505.67 P
1.03 (, this is a natural solution for protecting the token information) 222.45 505.67 P
1.83 (from server failures. When the primary server fails, the token information is available on the) 72 492.67 P
(backup that takes over the duties of the failed server) 72 479.67 T
(.) 300.53 479.67 T
1.15 (If both servers crash, though, Echo has no way to regain the token information. In this case,) 82.8 454.67 P
-0.12 (Echo users must reboot their workstations as was done originally in Sprite. Echo\325) 72 441.67 P
-0.12 (s designers chose) 427.95 441.67 P
0.67 (not to implement a recovery mechanism such as Sprite\325) 72 428.67 P
0.67 (s that would allow the servers to retrieve) 320.84 428.67 P
-0.21 (the token information from the clients. One of the reasons is that Echo authenticates client requests) 72 415.67 P
-0.03 (more carefully than Sprite [Mann93]; it would have to authenticate the token information received) 72 402.67 P
0.9 (from clients after a crash. However) 72 389.67 P
0.9 (, Echo\325) 231.04 389.67 P
0.9 (s designers believe that a mechanism such as Sprite\325) 263.06 389.67 P
0.9 (s) 499.73 389.67 P
-0 (would have been useful: \322W) 72 376.67 P
-0 (eighing the advantages and disadvantages, we prefer token replication) 196.19 376.67 P
0.25 (as the \336rst line of defense against server crashes. However) 72 363.67 P
0.25 (, we encountered enough double server) 330.69 363.67 P
1.09 (crashes in Echo to convince us that token recovery would have been useful as a second line of) 72 350.67 P
(defense. It would have considerably reduced the disruption to users in these cases [Mann93].\323) 72 337.67 T
0 14 Q
(1.2. Pr) 72 304.67 T
(oviding High A) 111 304.67 T
(vailability) 200.94 304.67 T
1 11 Q
0.26 (This section describes traditional fault-tolerant techniques used to provide very high \050non-stop\051) 82.8 278.67 P
1.69 (availability) 72 265.67 P
1.69 (. The categories of techniques are error repair) 120.72 265.67 P
1.69 (, redundant \050replicated\051 hardware and) 332.21 265.67 P
1.44 (software, and transactions. For each category) 72 252.67 P
1.44 (, I describe a few systems that use the technique.) 277.12 252.67 P
0.65 (However) 72 239.67 P
0.65 (, these divisions are somewhat clumsy) 111.82 239.67 P
0.65 (, because the techniques are not entirely indepen-) 282.82 239.67 P
(dent and many systems use more than one.) 72 226.67 T
0.88 (There is a further category of research that attempts to provide high availability through soft-) 82.8 201.67 P
1.64 (ware veri\336cation. The idea behind this work is to build systems that avoid crashes altogether) 72 188.67 P
1.64 (,) 501.25 188.67 P
1.78 (because they are \337awless and can be proved so. I do not describe work in this area, because) 72 175.67 P
(nobody has yet formally veri\336ed a distributed system the size and complexity of Sprite.) 72 162.67 T
-0.01 (The goal of this section is to explore the trade-of) 82.8 137.67 P
-0.01 (fs between fault tolerance and the fast recovery) 296.36 137.67 P
-0.01 (approach to high availability) 72 124.67 P
-0.01 (. If a system must guarantee non-stop availability) 197.27 124.67 P
-0.01 (, then it must use the) 413.12 124.67 P
0.77 (fault-tolerant techniques described in this section. In particular) 72 111.67 P
0.77 (, it must use some form of redun-) 352.15 111.67 P
0.17 (dant hardware and software to provide continuous operation in the event of a failure. However) 72 98.67 P
0.17 (, as) 489.18 98.67 P
0.58 (described below) 72 85.67 P
0.58 (, these fault-tolerant techniques also have disadvantages. They can be dif) 143.56 85.67 P
0.58 (\336cult to) 469.54 85.67 P
FMENDPAGE
%%EndPage: "19" 31
%%Page: "20" 31
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(20) 318 55 T
1 11 Q
1.95 (generalize \050error repair\051, slow \050transaction-based systems\051 or some combination of expensive,) 108 712.67 P
1.55 (complex, and slow \050redundant hardware and software\051. In contrast, the fast recovery approach) 108 699.67 P
0.89 (does not provide continuous operation after a failure. It merely attempts to reduce downtime by) 108 686.67 P
-0.06 (recovering quickly) 108 673.67 P
-0.06 (. But because the fast recovery approach is simpler and less expensive, environ-) 189.9 673.67 P
(ments with less stringent availability requirements may \336nd it more attractive.) 108 660.67 T
0 12 Q
(1.2.1. Err) 108 629 T
(or Repair) 156.42 629 T
1 11 Q
-0.15 (T) 118.8 603.67 P
-0.15 (o provide high availability) 124.74 603.67 P
-0.15 (, some systems attempt to detect and repair errors on-line. One name) 239.86 603.67 P
0.82 (for this technique is) 108 590.67 P
2 F
0.82 (err) 200.99 590.67 P
0.82 (or r) 214 590.67 P
0.82 (epair) 231.2 590.67 P
1 F
0.82 (. It is also called) 253.79 590.67 P
2 F
0.82 (forwar) 332.33 590.67 P
0.82 (d err) 361.84 590.67 P
0.82 (or r) 383.92 590.67 P
0.82 (ecovery) 401.12 590.67 P
1 F
0.82 (. T) 434.56 590.67 P
0.82 (andem\325) 446.82 590.67 P
0.82 (s Integrity S2) 479.16 590.67 P
0.59 ([Jewett91] and A) 108 577.67 P
0.59 (T&T\325) 183.62 577.67 P
0.59 (s 5ESS \050electronic switching system\051 [Smith81] [T) 208.65 577.67 P
0.59 (oy92a] are examples of) 435.42 577.67 P
0.18 (systems that detect their own faults and repair themselves on-line, as described below) 108 564.67 P
0.18 (. The appeal) 485.64 564.67 P
0.38 (of error repair is that it does not incur the performance overhead of redundant hardware and soft-) 108 551.67 P
0.77 (ware. Also, the technique is mandatory in real-time environments that cannot stop processing or) 108 538.67 P
0.73 (back up and redo operations. However) 108 525.67 P
0.73 (, there are several disadvantages of the technique. First, it) 280.83 525.67 P
0.3 (often requires help from special hardware which adds to the cost of the system. Second, it is hard) 108 512.67 P
0.09 (to generalize to dif) 108 499.67 P
0.09 (ferent systems, because it requires ad-hoc recovery code for each dif) 190.77 499.67 P
0.09 (ferent type) 492.62 499.67 P
1.67 (of error) 108 486.67 P
1.67 (. Finally) 142.31 486.67 P
1.67 (, if the failing component of the system is unavailable while under) 179.9 486.67 P
1.67 (going error) 489.21 486.67 P
0.66 (repair) 108 473.67 P
0.66 (, this technique does not provide truly continuous operation. For this last reason, most sys-) 133.18 473.67 P
1.23 (tems, including those described below) 108 460.67 P
1.23 (, combine error repair with redundant hardware and soft-) 280.33 460.67 P
(ware.) 108 447.67 T
0 12 Q
(1.2.1.1. Integrity S2) 108 416 T
1 11 Q
-0.1 (A goal of T) 118.8 390.67 P
-0.1 (andem\325) 168.69 390.67 P
-0.1 (s Integrity S2 is to provide high availability and good performance for a stan-) 201.04 390.67 P
0.7 (dard UNIX operating system with source-level application portability) 108 377.67 P
0.7 (. Integrity S2 accomplishes) 418.27 377.67 P
0.22 (this goal with highly redundant and specialized hardware and the ability of portions of the system) 108 364.67 P
0.14 (to locate and \336x hardware and software errors. Integrity S2\325) 108 351.67 P
0.14 (s hardware architecture allows on-line) 371.65 351.67 P
-0.24 (removal of failed components including CPUs. Faults that occur in the processor memory complex) 108 338.67 P
0.54 (are reported to the processors using a high-priority interrupt. The operating system can then exe-) 108 325.67 P
0.36 (cute instructions to repair the system, but it \336rst identi\336es the faulty component and executes any) 108 312.67 P
0.63 (needed recovery code. Faults in the I/O system or peripheral devices are handled by an I/O fault) 108 299.67 P
(handling layer) 108 286.67 T
(.) 170.56 286.67 T
0.5 (Integrity S2 provides error repair capabilities in the software by modifying the standard UNIX) 118.8 261.67 P
1.01 (implementation of internal consistency checks. In a standard UNIX kernel, a detected failure in) 108 248.67 P
0.67 (either the hardware or the kernel software will cause a) 108 235.67 P
2 F
0.67 (panic) 355.67 235.67 P
1 F
0.67 (, which in turn causes the operating) 380.08 235.67 P
0.99 (system to cease processing. In contrast, Integrity S2 uses a) 108 222.67 P
2 F
0.99 (forwar) 377.89 222.67 P
0.99 (d r) 407.39 222.67 P
0.99 (ecovery model) 420.49 222.67 P
1 F
0.99 (. The kernel) 485.24 222.67 P
0.75 (still self-checks itself for faults, but instead of allowing the consistency checks to cause a panic,) 108 209.67 P
0.28 (the kernel executes a forward recovery routine speci\336c to the type of fault detected. The recovery) 108 196.67 P
-0.19 (routine attempts to \336x the problem and whatever damage it may have caused. For example, consis-) 108 183.67 P
0.39 (tency checks are executed by audit routines to maintain the correctness and consistency of kernel) 108 170.67 P
0.13 (data structures. This approach is not easily generalizable, because for any given system it requires) 108 157.67 P
-0.27 (an arbitrary number of consistency checks with special recovery code for each. It can be dif) 108 144.67 P
-0.27 (\336cult to) 506.39 144.67 P
0.3 (determine if all possible errors have been assigned recovery code. It can also be dif) 108 131.67 P
0.3 (\336cult to deter-) 477.16 131.67 P
(mine if the recovery code is correct.) 108 118.67 T
FMENDPAGE
%%EndPage: "20" 32
%%Page: "21" 32
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(21) 282 55 T
0 F
(1.2.1.2. 5ESS) 72 712 T
1 11 Q
0.04 (A) 82.8 686.67 P
0.04 (T&T\325) 89.51 686.67 P
0.04 (s 5ESS [Smith81][T) 114.54 686.67 P
0.04 (oy92a] [T) 202.96 686.67 P
0.04 (oy92b] is another example of a system that combines error) 245.85 686.67 P
0.19 (repair with redundant hardware and software. 5ESS detects and repairs faults in both its hardware) 72 673.67 P
0.22 (and software, and can even make hardware and software upgrades, all without interruption in ser-) 72 660.67 P
0.33 (vice. For hardware error repair) 72 647.67 P
0.33 (, the 3B20D processor includes the ability to detect faults and exe-) 208.02 647.67 P
-0.22 (cute self-correcting instruction sequences. The system also logs error rates. If a certain rate of error) 72 634.67 P
0.19 (is exceeded, the system switches to a new component and automatically removes the failing com-) 72 621.67 P
0.79 (ponent from service. Specialized hardware and software and a highly redundant hardware archi-) 72 608.67 P
(tecture make this possible.) 72 595.67 T
0.06 (The software also includes self-check and repair capabilities. 5ESS uses the UNIX R) 82.8 570.67 P
0.06 (TR operat-) 456.04 570.67 P
-0.22 (ing system, intended to handle both real-time and time-shared functions. All the components of the) 72 557.67 P
0.91 (software audit their important data structures, either regularly or upon request. If the audits \336nd) 72 544.67 P
0.23 (problems with the data, they can either attempt to correct the data, or they can execute other error) 72 531.67 P
1.58 (recovery mechanisms) 72 518.67 P
3 F
1.58 (-) 173.4 518.67 P
1 F
1.58 ( sometimes causing initialization of data structures or even removal of) 179.43 518.67 P
-0.06 (hardware components. As a technique for providing high availability) 72 505.67 P
-0.06 (, the UNIX R) 373.77 505.67 P
-0.06 (TR software has) 432.12 505.67 P
0.19 (clearly been ef) 72 492.67 P
0.19 (fective; the telephone switching system long functioned within its goal of a total of) 136.85 492.67 P
0.45 (only a few minutes of downtime each year) 72 479.67 P
0.45 (. However) 261.6 479.67 P
0.45 (, recent interruptions in service show that as) 307.38 479.67 P
0.28 (the system becomes more complex, it has the same downside as the software for Integrity S2; the) 72 466.67 P
(system of checks and recovery actions is complicated and hard to verify) 72 453.67 T
(.) 387.68 453.67 T
1.73 (Besides checking and repairing faults, 5ESS uses redundant hardware and software compo-) 82.8 428.67 P
0.22 (nents, in part so that it can upgrade hardware and software without interrupting service. There are) 72 415.67 P
0 (three main factors involved in retro\336tting a 5ESS switch this way) 72 402.67 P
0 (. New hardware and software are) 358.78 402.67 P
0.01 (added to the system at dif) 72 389.67 P
0.01 (ferent times, so new software must be compatible with the old hardware,) 184.44 389.67 P
0.73 (and new hardware must be compatible with the old software. Second, to prevent loss of service,) 72 376.67 P
1.52 (not all the software modules can be changed at once. Therefore, messages from new software) 72 363.67 P
1.27 (modules to old ones must be compatible with the old modules. Third, the databases within the) 72 350.67 P
0.68 (5ESS switch \050for routing and subscriber information and data about the hardware and peripheral) 72 337.67 P
0.87 (equipment\051 must evolve from a format compatible with the old software to a format compatible) 72 324.67 P
0.21 (with the new) 72 311.67 P
0.21 (. The method used to accomplish these tasks is called) 128.45 311.67 P
2 F
0.21 (generic r) 367.61 311.67 P
0.21 (etr) 407.37 311.67 P
0.21 (o\336t) 419.17 311.67 P
1 F
0.21 (. It takes advan-) 433.21 311.67 P
0.46 (tage of the redundancy in the switch so that one part can be changed while another still operates.) 72 298.67 P
-0.05 (The redundancy is costly) 72 285.67 P
-0.05 (, but the alternatives are worse: no upgrades to 5ESS, or loss of service to) 181.28 285.67 P
0.88 (customers. More detailed descriptions of systems using redundancy for fault tolerance follow in) 72 272.67 P
(the next section.) 72 259.67 T
0 12 Q
(1.2.2.) 72 228 T
(Redundancy for Masking Faults) 101.98 228 T
1 11 Q
-0.25 (Most systems that provide high availability use some variety of redundancy) 82.8 202.67 P
-0.25 (, in the hardware, the) 412.24 202.67 P
0.82 (software, or both to allow the system to mask failures. For example, if a system has backup \336le) 72 189.67 P
-0.22 (servers, then the failure of a primary \336le server is masked if the backup \336le server can take over for) 72 176.67 P
(the failed primary) 72 163.67 T
(.) 150 163.67 T
0.68 (T) 82.8 138.67 P
0.68 (o provide non-stop processing it is absolutely necessary to use this sort of redundancy) 88.74 138.67 P
0.68 (, but it) 474.26 138.67 P
0.85 (does not come for free. Extra hardware costs money and can cause increased architectural com-) 72 125.67 P
0.33 (plexity and performance degradation. Performance degradation occurs if backup systems must be) 72 112.67 P
0.75 (kept up to date with primary systems. Keeping them up to date requires more message traf) 72 99.67 P
0.75 (\336c as) 480.36 99.67 P
0.58 (well as added complexity) 72 86.67 P
0.58 (. If the backup systems are designed to handle a full load when the pri-) 185 86.67 P
FMENDPAGE
%%EndPage: "21" 33
%%Page: "22" 33
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(22) 318 55 T
1 11 Q
-0.23 (mary has failed, then there is wasted extra capacity in normal operation. Otherwise the system runs) 108 712.67 P
(slower when in backup mode.) 108 699.67 T
-0.04 (While the systems described in this section all use redundancy to tolerate faults, they dif) 118.8 674.67 P
-0.04 (fer in at) 505.91 674.67 P
0.34 (least three important ways. First, they are designed to tolerate dif) 108 661.67 P
0.34 (ferent types of faults. For exam-) 396.75 661.67 P
0.76 (ple, some systems tolerate hardware errors but not software errors. Second, in some systems the) 108 648.67 P
1.26 (existence of replicated resources is transparent to both users and software, while other systems) 108 635.67 P
0.67 (require sophisticated knowledge to write fault-tolerant programs. Third, the systems dif) 108 622.67 P
0.67 (fer in the) 498.99 622.67 P
0.14 (extent to which replicated resources are wasted in the absence of failures. For example, some sys-) 108 609.67 P
0.75 (tems use their replicated processors only if a primary processor fails. In other systems, the extra) 108 596.67 P
(processors run dif) 108 583.67 T
(ferent jobs and therefore contribute to the overall processing power) 186.52 583.67 T
(.) 481.56 583.67 T
1.89 (In this section I describe T) 118.8 558.67 P
1.89 (andem [Bartle81][Bartle90], Stratus [Stratu89][W) 244.34 558.67 P
1.89 (ebber92], T) 468.82 558.67 P
1.89 (AR-) 521.08 558.67 P
0.11 (GON/32 [Bor) 108 545.67 P
0.11 (g83][Bor) 168.63 545.67 P
0.11 (g89], Zebra [Hartma93], and ISIS [Birman84][Birman89]. Some other sys-) 208.71 545.67 P
3.22 (tems using replication are Andrew [Howard88], Cedar [Gif) 108 532.67 P
3.22 (for88], Eden [Pu86], Grapevine) 390.91 532.67 P
-0.11 ([Birrel82], LOCUS [W) 108 519.67 P
-0.11 (alker83], and SW) 209.12 519.67 P
-0.11 (ALLOW [Reed81]. There is also some work on replicated) 284.88 519.67 P
(recoverable processes [Babaog90] on Mach [Accett86].) 108 506.67 T
0 12 Q
(1.2.2.1. T) 108 475 T
(andem NonStop Systems) 153.88 475 T
1 11 Q
0.04 (T) 118.8 449.67 P
0.04 (andem\325) 124.74 449.67 P
0.04 (s NonStop Systems are some of the best-known highly available systems and use hard-) 157.09 449.67 P
0.19 (ware and software redundancy to tolerate both hardware and software failures. Their main market) 108 436.67 P
1.15 (is on-line transaction processing. Through a highly redundant architecture, T) 108 423.67 P
1.15 (andem systems are) 454.71 423.67 P
(able to tolerate the failure of any single hardware component.) 108 410.67 T
-0.2 (T) 118.8 385.67 P
-0.2 (andem\325) 124.74 385.67 P
-0.2 (s hardware redundancy is designed to help prevent) 157.09 385.67 P
2 F
-0.2 (err) 380.68 385.67 P
-0.2 (or pr) 393.7 385.67 P
-0.2 (opagation) 415.38 385.67 P
1 F
-0.2 (, in which an error) 459.94 385.67 P
1.06 (causing one system component to fail causes other parts to fail as they take over) 108 372.67 P
1.06 (. For example,) 474.4 372.67 P
1.29 (T) 108 359.67 P
1.29 (andem developed a loosely-coupled multiple computer architecture using primary and backup) 113.94 359.67 P
0.09 (processors. If one processor fails, a backup is ready to take over) 108 346.67 P
0.09 (, but the backup is usually passive) 389.6 346.67 P
0.29 (and only periodically updated by a checkpoint from the primary) 108 333.67 P
0.29 (. Because the backup processor is) 390.89 333.67 P
-0.06 (updated by checkpoint, rather than by executing exactly what the primary executes, it is less likely) 108 320.67 P
0.87 (to suf) 108 307.67 P
0.87 (fer the same error as the primary) 133.39 307.67 P
0.87 (. Other hardware redundancy in the system includes fully) 281.3 307.67 P
0.13 (replicated \050mirrored\051 disks to provide full backup of the database, a separate I/O bus for each pro-) 108 294.67 P
(cessor) 108 281.67 T
(, and dual-ported controllers connected to the I/O busses.) 135.01 281.67 T
-0.12 (T) 118.8 256.67 P
-0.12 (andem\325) 124.74 256.67 P
-0.12 (s software fault tolerance is also designed to avoid error propagation. T) 157.09 256.67 P
-0.12 (andem uses) 468.03 256.67 P
2 F
-0.12 (pr) 521.49 256.67 P
-0.12 (o-) 530.85 256.67 P
0.56 (cess pairs) 108 243.67 P
1 F
0.56 ( supported by the Guardian operating system kernel. A process pair functions logically) 152.2 243.67 P
0.38 (as a single process, but it is composed of a primary process and a backup process. T) 108 230.67 P
0.38 (andem\325) 481.95 230.67 P
0.38 (s pro-) 514.29 230.67 P
0.3 (cess pairs are similar to the primary/backup scheme used in their hardware; the backup process is) 108 217.67 P
1.65 (updated by checkpoint, rather than by executing everything the primary executes, so it is less) 108 204.67 P
0.62 (likely to suf) 108 191.67 P
0.62 (fer the same error as the primary) 161.53 191.67 P
0.62 (. In T) 307.9 191.67 P
0.62 (andem\325) 332.47 191.67 P
0.62 (s case, the primary process does all the) 364.82 191.67 P
0.12 (work while the backup remains passive and prepared to take over if the primary suf) 108 178.67 P
0.12 (fers a fault. At) 476.19 178.67 P
1.85 (critical points, the primary sends checkpoint messages to the backup. The backup applies the) 108 165.67 P
-0.25 (changes in the checkpoint messages to its own state and data structures. Immediately after a check-) 108 152.67 P
1.57 (point, the primary and backup processes are identical. The checkpoint messages usually occur) 108 139.67 P
-0.07 (before or after an important I/O or \336le operation, since these operations change the state of the pri-) 108 126.67 P
0.27 (mary process with respect to the outside system. After a fault in the primary) 108 113.67 P
0.27 (, the backup becomes) 444.61 113.67 P
2.02 (the new primary process and begins processing at the point of the last checkpoint operation.) 108 100.67 P
FMENDPAGE
%%EndPage: "22" 34
%%Page: "23" 34
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(23) 282 55 T
1 11 Q
1.87 (Sequence numbers are associated with requests so that if a new primary process duplicates a) 72 712.67 P
(request sent by the old primary before it died, the request is recognizable as a duplicate.) 72 699.67 T
0.02 (T) 82.8 674.67 P
0.02 (andem\325) 88.74 674.67 P
0.02 (s process pair scheme is particularly suited to avoiding failures from) 121.09 674.67 P
2 F
0.02 (transient) 424.34 674.67 P
1 F
0.02 ( software) 463.4 674.67 P
-0.02 (errors) 72 661.67 P
3 F
-0.02 (-) 100.35 661.67 P
1 F
-0.02 ( the most pernicious sort of software error) 106.38 661.67 P
-0.02 (. A transient error) 290.25 661.67 P
-0.02 (is one that occurs infrequently) 371.03 661.67 P
1.2 (and is hard to reproduce. They are often timing-dependent. For this reason they are also called) 72 648.67 P
2 F
0.33 (nondeterministic) 72 635.67 P
1 F
0.33 ( errors. The backup process executes what the primary executes only after a fail-) 145.85 635.67 P
0.3 (ure, when it begins processing from the point of the last checkpoint. An infrequent timing-depen-) 72 622.67 P
0.71 (dent error is thus unlikely to strike both the primary and then the backup as it recovers from the) 72 609.67 P
0.54 (last checkpoint. Software bugs that are not transient will likely be debugged and removed before) 72 596.67 P
0.46 (long, but transient problems can be very dif) 72 583.67 P
0.46 (\336cult to \336nd and \336x. It is T) 266.67 583.67 P
0.46 (andem\325) 387.56 583.67 P
0.46 (s opinion that soft-) 419.9 583.67 P
-0.08 (ware faults are inevitable and also more common than hardware faults. Therefore it is necessary to) 72 570.67 P
(guard against transient software faults to provide high availability) 72 557.67 T
(.) 360.56 557.67 T
0.82 ( The main problem with process pairs as implemented by T) 82.8 532.67 P
0.82 (andem is that they are not easy to) 351.47 532.67 P
1.22 (use. Choosing when to checkpoint primary process state to the backup requires experience and) 72 519.67 P
0.51 (expertise from the programmer for good performance. A typical checkpoint might indicate that a) 72 506.67 P
-0.24 (\336le has been opened or closed. Depending on the importance, even an update to a \336le could require) 72 493.67 P
-0.1 (a checkpoint, causing signi\336cant overhead. Since the checkpoint operations are expensive, it is not) 72 480.67 P
(reasonable to insert them naively in applications that need to be fast.) 72 467.67 T
1.66 (T) 82.8 442.67 P
1.66 (andem is one of the most successful vendors in the on-line transaction processing market.) 88.74 442.67 P
1.02 (Depending on how much customers are willing to pay) 72 429.67 P
1.02 (, they can buy as much fault-tolerance as) 317.46 429.67 P
-0.09 (they want from T) 72 416.67 P
-0.09 (andem. T) 147.55 416.67 P
-0.09 (andem can even replicate entire geographic sites to prevent major disas-) 188.19 416.67 P
-0.08 (ters from bringing companies to a halt. However) 72 403.67 P
-0.08 (, T) 284.57 403.67 P
-0.08 (andem systems can cost tens of millions of dol-) 295.93 403.67 P
1.34 (lars [T) 72 390.67 P
1.34 (andem90], and it is not easy to write fault-tolerant applications using their process pairs) 101.55 390.67 P
(directly) 72 377.67 T
(. In many computing environments the cost of this approach is too high.) 104.85 377.67 T
0 12 Q
(1.2.2.2. T) 72 346 T
(ARGON/32) 118.09 346 T
1 11 Q
0.79 (T) 82.8 320.67 P
0.79 (ARGON/32 is a UNIX-based system intended for an on-line transaction processing environ-) 88.63 320.67 P
-0 (ment. The goal of the system is to ensure that all executing processes will survive any single hard-) 72 307.67 P
1.58 (ware failure and some nondeterministic software failures. T) 72 294.67 P
1.58 (o achieve this goal T) 344.7 294.67 P
1.58 (ARGON uses) 441.7 294.67 P
1.01 (redundant and specialized hardware and software, including three-way atomic message delivery) 72 281.67 P
(and process pairs.) 72 268.67 T
1.23 (For hardware fault tolerance T) 82.8 243.67 P
1.23 (ARGON uses a special setup of redundant multiprocessors, as) 221.07 243.67 P
-0.27 (illustrated in Figure 1-5. They connect two to 16) 72 230.67 P
2 F
-0.27 (clusters) 285.58 230.67 P
1 F
-0.27 ( using a fast replicated bus. Each cluster is) 319.76 230.67 P
1.1 (actually a shared-memory multiprocessor with three processors. T) 72 217.67 P
1.1 (wo of the processors run user) 369.42 217.67 P
1.22 (processes and most of the system code. One of the processors executes special kernel code for) 72 204.67 P
-0.16 (message handling and recovery of backup processes, as described below) 72 191.67 P
-0.16 (. The replicated clusters in) 388.38 191.67 P
0.34 (the T) 72 178.67 P
0.34 (ARGON system are not used solely as backups. They are available for productive use in the) 94.34 178.67 P
-0.2 (absence of failures. All peripheral devices are dual-ported so that they remain available even if one) 72 165.67 P
(cluster fails. Finally) 72 152.67 T
(, disks can be mirrored to keep data available in the event of a disk crash.) 158.87 152.67 T
0.67 (T) 82.8 127.67 P
0.67 (o provide non-stop availability) 88.74 127.67 P
0.67 (, T) 225.23 127.67 P
0.67 (ARGON uses a process pair scheme similar to T) 237.23 127.67 P
0.67 (andem\325) 455.42 127.67 P
0.67 (s in) 487.76 127.67 P
0.8 (many ways. Like T) 72 114.67 P
0.8 (andem, T) 158.47 114.67 P
0.8 (ARGON\325) 199.89 114.67 P
0.8 (s process pairs avoid error propagation and failures due to) 242 114.67 P
0.41 (some transient software failures. Each process pair is composed of an active primary process and) 72 101.67 P
0.11 (its inactive backup process. The primary and backup run on dif) 72 88.67 P
0.11 (ferent clusters, to provide fault tol-) 350.27 88.67 P
FMENDPAGE
%%EndPage: "23" 35
%%Page: "24" 35
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(24) 318 55 T
1 11 Q
0.71 (erance in the event of any single processor failure. During normal execution, the system logs all) 108 328.67 P
0.63 (input to the primary in a queue for the backup process. Periodically) 108 315.67 P
0.63 (, the state of the primary and) 410.2 315.67 P
0.36 (backup are synchronized, and the input in the backup\325) 108 302.67 P
0.36 (s queue is deleted. In the event of a failure,) 347.93 302.67 P
-0.16 (the backup process rolls forward by processing all the input in its queue since the last synchroniza-) 108 289.67 P
(tion point. This brings its state up to date with that of the primary at the time it failed.) 108 276.67 T
1.13 (T) 118.8 251.67 P
1.13 (ARGON\325) 124.63 251.67 P
1.13 (s process pair implementation dif) 166.74 251.67 P
1.13 (fers from T) 317.54 251.67 P
1.13 (andem\325) 369.07 251.67 P
1.13 (s, because T) 401.41 251.67 P
1.13 (ARGON\325) 456.79 251.67 P
1.13 (s focuses) 498.9 251.67 P
0.68 (on ease of use. T) 108 238.67 P
0.68 (ARGON\325) 183.99 238.67 P
0.68 (s approach thus requires that the use of process pairs be entirely auto-) 226.1 238.67 P
0.71 (matic and transparent to users of the system and user) 108 225.67 P
0.71 (-level software. Primary processes in T) 346.34 225.67 P
0.71 (AR-) 521.08 225.67 P
-0.16 (GON do not require explicit checkpoints to bring the backups up to date. Instead, the processes are) 108 212.67 P
(synchronized automatically by the system using a message-based strategy) 108 199.67 T
(.) 431.94 199.67 T
0.34 (T) 118.8 174.67 P
0.34 (ARGON\325) 124.63 174.67 P
0.34 (s message-passing software and hardware provides much of the system\325) 166.74 174.67 P
0.34 (s fault toler-) 485.61 174.67 P
1.23 (ance. All input to and output from processes is in the form of messages, so the backup\325) 108 161.67 P
1.23 (s input) 509.16 161.67 P
0.63 (queue is actually a message queue. For fault tolerance, the backup process must receive all mes-) 108 148.67 P
-0.16 (sages received by its primary) 108 135.67 P
-0.16 (, but no additional messages. This requires three-way atomic message) 234.79 135.67 P
0.14 (delivery; whenever one primary process sends a message to another primary process, the message) 108 122.67 P
0.27 (must also be noted by the backup of the sending process and queued at the backup of the destina-) 108 109.67 P
(Figure 1-5. T) 230.46 431.67 T
(ARGON system architecture.) 287.87 431.67 T
1 10 Q
0.76 (This \336gure is a simpli\336ed illustration of a two-cluster T) 144 409.33 P
0.76 (ARGON system. Each cluster is) 371.87 409.33 P
0.37 (composed of a multi-processor with three processors. A replicated bus connects the clus-) 144 398.33 P
108 366 540 384 C
108 366 540 384 R
7 X
0 K
V
108 375 540 375 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(ters. Both clusters can access the disks, which may be mirrored.) 144 387.33 T
108 457 540 720 C
108 457 540 708 C
351 570 420 604 R
1 H
0 Z
0 X
0 K
N
1 10 Q
(processor 2) 364 584 T
389 611 458 645 R
N
(processor 1) 402 625 T
435 570 504 604 R
N
(processor 3) 448 584 T
144 570 213 604 R
N
(processor 2) 157 584 T
182 611 251 645 R
N
(processor 1) 195 625 T
228 570 297 604 R
N
(processor 3) 241 584 T
135 537 306 663 R
N
342 537 513 663 R
N
189 663 189 699 2 L
3 H
2 Z
N
429.81 704.79 450 699 429.81 693.21 429.81 699 4 Y
V
189 699 429.81 699 2 L
N
405 699 405 663 2 L
N
261 663 261 681 2 L
N
447.81 686.79 468 681 447.81 675.21 447.81 681 4 Y
V
261 681 447.81 681 2 L
N
369 681 369 663 2 L
N
1 12 Q
(system busses) 216 686 T
7 X
90 450 36 10 397 475 G
0.5 H
0 Z
0 X
90 450 36 10 397 475 A
7 X
90 450 36 10 397 484 G
0 X
90 450 36 10 397 484 A
7 X
90 450 36 10 397 493 G
0 X
90 450 36 10 397 493 A
7 X
90 450 36 10 397 502 G
0 X
90 450 36 10 397 502 A
(disks) 388.01 499.82 T
7 X
90 450 36 10 252 475 G
0 X
90 450 36 10 252 475 A
7 X
90 450 36 10 252 484 G
0 X
90 450 36 10 252 484 A
7 X
90 450 36 10 252 493 G
0 X
90 450 36 10 252 493 A
7 X
90 450 36 10 252 502 G
0 X
90 450 36 10 252 502 A
(disks) 243.01 499.82 T
272 535 272 507 2 L
7 X
V
3 H
2 Z
0 X
N
277 536 373 506 2 L
7 X
V
2 H
0 X
N
370 537 274 507 2 L
7 X
V
0 X
N
371 535 371 507 2 L
7 X
V
3 H
0 X
N
108 457 540 720 C
108 457 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "24" 36
%%Page: "25" 36
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(25) 282 55 T
1 11 Q
1.77 (tion process. This three-way atomic message system is implemented with special-purpose bus) 72 712.67 P
(hardware and low-level software in the device driver) 72 699.67 T
(.) 303.56 699.67 T
-0.04 (T) 82.8 674.67 P
-0.04 (ARGON is an attractive approach to fault-tolerance in the on-line processing environment, but) 88.63 674.67 P
1.13 (it has three disadvantages for a typical of) 72 661.67 P
1.13 (\336ce/engineering environment. First, the replicated and) 260.04 661.67 P
2.58 (special-purpose hardware makes the system more costly) 72 648.67 P
2.58 (. Second, T) 333.9 648.67 P
2.58 (ARGON\325) 388.23 648.67 P
2.58 (s fault-tolerance) 430.34 648.67 P
0.4 (reduces its performance compared to a standard UNIX system. Third, the system implementation) 72 635.67 P
(is complex.) 72 622.67 T
1.2 (Extra communication is a lar) 82.8 597.67 P
1.2 (ge part of the performance overhead in T) 214.34 597.67 P
1.2 (ARGON. On a single-) 402.15 597.67 P
1.74 (machine system, without any fault-tolerance, the overhead of communication with server pro-) 72 584.67 P
1.08 (cesses is about ten percent, ranging from three to 20% for dif) 72 571.67 P
1.08 (ferent system calls. Running on a) 352.14 571.67 P
0.92 (two-machine system, the overhead for a single process becomes 15%. However) 72 558.67 P
0.92 (, the capacity of) 431.06 558.67 P
-0.1 (the system increases with the additional machine. Adding fault tolerance \050backup processes\051 to the) 72 545.67 P
(system reduces performance by another ten percent.) 72 532.67 T
1.32 (One example of implementation complexity in T) 82.8 507.67 P
1.32 (ARGON is that dif) 304.67 507.67 P
1.32 (ferent types of processes) 391.74 507.67 P
0.18 (require dif) 72 494.67 P
0.18 (ferent backup and recovery schemes. In T) 118.04 494.67 P
0.18 (ARGON, the kernel does not survive crashes,) 302.18 494.67 P
0.8 (so important operating system functions must run as recoverable server processes. However) 72 481.67 P
0.8 (, the) 484.29 481.67 P
0.19 (implementation of backup processes for user processes is dif) 72 468.67 P
0.19 (ferent than that for kernel server pro-) 339.97 468.67 P
0.28 (cesses and peripheral devices. For ef) 72 455.67 P
0.28 (\336ciency) 234.29 455.67 P
0.28 (, the kernel servers must violate some of the assump-) 268.36 455.67 P
1.6 (tions made of user processes. Even the implementation of servers for block-special \050disk-like\051) 72 442.67 P
0.67 (devices dif) 72 429.67 P
0.67 (fers from that of character) 120.37 429.67 P
0.67 (-special \050tty-like\051 severs. Another example of complexity is) 237.52 429.67 P
1.09 (that T) 72 416.67 P
1.09 (ARGON\325) 98.15 416.67 P
1.09 (s process pair scheme requires cooperation between the message system and the) 140.26 416.67 P
-0.11 (paging mechanism. Any changes in the address space of the primary since the last synchronization) 72 403.67 P
(must be stored so that they are available to the backup process in the event of a failure.) 72 390.67 T
0 12 Q
(1.2.2.3. Stratus) 72 359 T
1 11 Q
-0.08 (Stratus also provides hardware and software redundancy for fault tolerance, but it uses) 82.8 333.67 P
2 F
-0.08 (lock-step) 464.34 333.67 P
1 F
0.34 (synchronization for its replicated processors rather than T) 72 320.67 P
0.34 (andem\325) 327.18 320.67 P
0.34 (s or T) 359.52 320.67 P
0.34 (ARGON\325) 384.96 320.67 P
0.34 (s primary/backup) 427.07 320.67 P
1.59 (scheme. A pair of processors or other boards in a hardware module perform the same actions) 72 307.67 P
0.68 (together) 72 294.67 P
0.68 (, in lock-step. If the self-check on one of the boards fails, then the other board is able to) 107.56 294.67 P
0.55 (continue functioning with no delay) 72 281.67 P
0.55 (. The advantages of this approach are that hardware errors are) 227.29 281.67 P
0.07 (detected immediately) 72 268.67 P
0.07 (, and no checkpoints are necessary) 165.64 268.67 P
0.07 (, since both boards in a pair have the same) 317.22 268.67 P
-0.12 (state at all times. The disadvantage is the cost/performance trade-of) 72 255.67 P
-0.12 (f. Since the same software runs) 367.3 255.67 P
1.12 (on the synchronized processors, the processing capabilities of at least one processor are wasted) 72 242.67 P
0.81 (during normal operation of the system. Thus the cost of the system is higher than its processing) 72 229.67 P
(capacity warrants.) 72 216.67 T
0 12 Q
(1.2.2.4.) 72 185 T
(Zebra) 110.98 185 T
1 11 Q
0.62 (Zebra is an example of a high-performance network \336le system that uses replication for avail-) 82.8 159.67 P
0.89 (ability but wastes very little system capacity) 72 146.67 P
0.89 (. T) 271.29 146.67 P
0.89 (o do this, Zebra uses two techniques from RAID) 283.62 146.67 P
1.32 ([Patter88]:) 72 133.67 P
2 F
1.32 (striping) 123.05 133.67 P
1 F
1.32 ( for fast \336le access, and) 157.24 133.67 P
2 F
1.32 (parity) 271.02 133.67 P
1 F
1.32 ( for high availability of \336le data. These tech-) 297.26 133.67 P
0.42 (niques are illustrated in Figure 1-6. In Zebra, \336le striping means that dif) 72 120.67 P
0.42 (ferent blocks of a \336le are) 392.37 120.67 P
0.44 (stored on dif) 72 107.67 P
0.44 (ferent storage servers. Striping provides faster access to lar) 128.23 107.67 P
0.44 (ge \336les, because dif) 390.6 107.67 P
0.44 (ferent) 478.38 107.67 P
0.35 (portions of the \336le can be read simultaneously from the dif) 72 94.67 P
0.35 (ferent servers. For example, in the \336g-) 333.47 94.67 P
FMENDPAGE
%%EndPage: "25" 37
%%Page: "26" 37
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(26) 318 55 T
1 11 Q
0.97 (ure the \336rst three blocks of a \336le are striped across the \336rst three servers. Parity blocks provide) 108 712.67 P
0.1 (high availability of \336le data, because they make it possible to retrieve the contents of an entire \336le) 108 699.67 P
0.41 (in the event of any single server failure. In the \336gure, the fourth server stores the parity block for) 108 686.67 P
0.28 (the \336rst stripe. This parity block is the exclusive-or of the \336rst three blocks. If any server crashes,) 108 673.67 P
0.8 (we can construct the missing block of the stripe from the other blocks combined with the parity) 108 660.67 P
0.67 (block. The next stripe is composed of the next three \336le blocks along with their parity block. T) 108 647.67 P
0.67 (o) 534.51 647.67 P
(spread out the load, the parity blocks for the dif) 108 634.67 T
(ferent stripes are located on dif) 316.51 634.67 T
(ferent servers.) 452.68 634.67 T
1.59 (W) 118.8 199.67 P
1.59 (ith suf) 128.73 199.67 P
1.59 (\336cient servers, Zebra wastes very little system capacity) 157.9 199.67 P
1.59 (. The extra hardware cost is) 410.61 199.67 P
0.18 (ef) 108 186.67 P
0.18 (fectively one block\325) 116.34 186.67 P
0.18 (s worth of disk space for each data stripe. This extra block holds the stripe\325) 203.96 186.67 P
0.18 (s) 535.73 186.67 P
0.1 (parity) 108 173.67 P
0.1 (. Since the size of a stripe depends on the number of servers in the system, the percentage of) 132.92 173.67 P
-0.25 (lost capacity due to parity blocks decreases as the number of servers increases. In terms of process-) 108 160.67 P
-0.14 (ing capacity) 108 147.67 P
-0.14 (, no storage server is wasted during normal processing, since no server stores only par-) 160.54 147.67 P
0.21 (ity blocks. However) 108 134.67 P
0.21 (, extra processing is required during a failure to access data or reconstruct \336le) 196.77 134.67 P
(data from the surviving data blocks and their parity) 108 121.67 T
(.) 332.47 121.67 T
(Figure 1-6. File striping and parity blocks in Zebra.) 211.09 326.67 T
1 10 Q
-0.14 (This \336gure shows how a \336le with six blocks is striped across four storage servers. The \336rst) 144 304.33 P
1.51 (stripe consists of block numbers one to three with a parity block stored on the fourth) 144 293.33 P
0.05 (server) 144 282.33 P
0.05 (. The parity block is the exclusive-or of the other three blocks in the stripe. The sec-) 167.87 282.33 P
0.67 (ond stripe consists of blocks four to six. T) 144 271.33 P
0.67 (o balance the load amongst servers, the parity) 316.65 271.33 P
108 239 540 257 C
108 239 540 257 R
7 X
0 K
V
108 248 540 248 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(blocks for dif) 144 260.33 T
(ferent stripes are spread amongst dif) 197.67 260.33 T
(ferent servers.) 342.65 260.33 T
108 352 540 613 C
108 352 540 601 C
342 403 378 547 R
1 H
0 Z
0 X
0 K
N
342.71 512 378 512 2 L
2 Z
N
342 476 377.29 476 2 L
N
342.71 441 378 441 2 L
N
199 403 234 547 R
0 Z
N
199.69 512 234 512 2 L
2 Z
N
199 476 233.31 476 2 L
N
199.69 441 234 441 2 L
N
414 403 450 547 R
0 Z
N
414.71 512 450 512 2 L
2 Z
N
414 476 449.29 476 2 L
N
414.71 441 450 441 2 L
N
270 403 305 547 R
0 Z
N
270.69 512 305 512 2 L
2 Z
N
270 476 304.31 476 2 L
N
270.69 441 305 441 2 L
N
1 12 Q
(1) 211.35 484 T
(2) 282.35 484 T
(3) 352.59 484 T
(4) 282.35 448 T
(5) 352.59 448 T
(6) 424.59 448 T
199 441 234 476 R
9 X
V
0 Z
0 X
N
414.71 476 449.29 512 R
9 X
V
0 X
N
186.46 465.49 198 462.18 186.46 458.88 186.46 462.18 4 Y
V
171 462.18 186.46 462.18 2 L
9 X
V
0.5 H
2 Z
0 X
N
463.23 489.11 451.58 492 462.99 495.72 463.11 492.41 4 Y
V
463.11 492.41 479.58 493 2 L
9 X
V
0 X
N
216 556 432 592 R
0 Z
N
252 592 252 556 2 L
2 Z
N
288 592 288 556 2 L
N
324 592 324 556 2 L
N
360 592 360 556 2 L
N
396 592 396 556 2 L
N
(1) 234 565 T
(2) 270 565 T
(3) 306 565 T
(4) 342 565 T
(5) 378 565 T
(6) 414 565 T
(File:) 185 574.82 T
(Storage servers) 277.4 376 T
1 10 Q
(4) 127 459 T
3 F
(\304 5 \304 6) 134.5 459 T
(1 \304 2 \304 3) 482 490 T
108 352 540 613 C
108 352 540 601 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "26" 38
%%Page: "27" 38
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(27) 282 55 T
1 11 Q
0.25 (While Zebra can continue operation despite the failure of a storage server) 82.8 712.67 P
0.25 (, it does have a single) 408.17 712.67 P
0.61 (point of failure. One server) 72 699.67 P
0.61 (, called the \336le manager) 193.28 699.67 P
0.61 (, must also keep track of which parts of a \336le) 300.52 699.67 P
0.14 (are on which storage servers. All lookup operations go through the \336le manager) 72 686.67 P
0.14 (, and the \336le man-) 423.81 686.67 P
-0.09 (ager maintains the \336le system metadata. Unless it is replicated, the \336le manager is a single point of) 72 673.67 P
(failure, because clients will not be able to open new \336les if it crashes.) 72 660.67 T
0.06 (Zebra\325) 82.8 635.67 P
0.06 (s \336le manager may be a good tar) 111.47 635.67 P
0.06 (get for some of the fast recovery techniques described in) 254.8 635.67 P
-0.06 (this thesis. The faster the \336le manager restarts, the sooner Zebra can return to service. Fast start-up) 72 622.67 P
0.41 (for the \336le manager is particularly appropriate, because the Zebra designers believe that it should) 72 609.67 P
0.37 (be possible to store the \336le manager) 72 596.67 P
0.37 (\325) 232.68 596.67 P
0.37 (s metadata on the storage servers, rather than on a local disk) 235.73 596.67 P
0.21 (on the \336le manager) 72 583.67 P
0.21 (. Thus, if the \336le manager breaks, any other server can take over for it quickly) 156.54 583.67 P
0.21 (,) 501.25 583.67 P
(using the metadata on the storage servers.) 72 570.67 T
0 12 Q
(1.2.2.5. ISIS) 72 539 T
1 11 Q
0.65 (The ISIS project provides high-level support for writing fault-tolerant distributed programs by) 82.8 513.67 P
-0.1 (replicating code and data on dif) 72 500.67 P
-0.1 (ferent machines. ISIS runs on top of the operating system. Its spec-) 210.1 500.67 P
1.17 (i\336cation language allows programmers to replicate data structures as many times as desired, so) 72 487.67 P
0.47 (programs can survive the failure of an arbitrary number of sites. Programs access the data as if it) 72 474.67 P
0.27 (weren\325) 72 461.67 P
0.27 (t distributed. A front-end system inserts calls to a run-time system that handles replication,) 102.3 461.67 P
1.57 (consistency) 72 448.67 P
1.57 (, failure detection, and recovery) 122.55 448.67 P
1.57 (. T) 267.84 448.67 P
1.57 (o manage synchronization and concurrency) 280.85 448.67 P
1.57 (, ISIS) 477.4 448.67 P
0.25 (provides special commit protocols, all-or) 72 435.67 P
0.25 (-nothing broadcast protocols, atomic broadcast protocols) 253.13 435.67 P
-0 (\050all sites see messages in the same order\051 and variations with less strict ordering but higher perfor-) 72 422.67 P
(mance. ISIS also has an automatic distributed checkpoint mechanism.) 72 409.67 T
-0.2 (Although many applications have been built with ISIS, the most interesting in the context of this) 82.8 384.67 P
-0.07 (thesis is the Deceit \336le system [Siegel89]. Deceit is an NFS-compatible distributed \336le system that) 72 371.67 P
0.58 (provides the user with per) 72 358.67 P
0.58 (-\336le control over reliability and performance. For example, a user may) 188.21 358.67 P
-0.24 (choose higher reliability with less performance for some critical \336les, and higher performance with) 72 345.67 P
(less reliability for often-accessed \336les.) 72 332.67 T
1.14 (These capabilities, however) 82.8 307.67 P
1.14 (, do not come for free. Performance measurements with only one) 206.99 307.67 P
0.77 (client and an unreplicated server show that many Deceit operations are signi\336cantly slower than) 72 294.67 P
0.89 (the corresponding NFS operations. A NULL RPC is 26% slower; an eight-kilobyte read is 19%) 72 281.67 P
0.43 (slower; an eight-kilobyte write is 24% slower; a GET) 72 268.67 P
0.43 (A) 309.52 268.67 P
0.43 (TTR RPC is 20% slower; and a remove is) 316.23 268.67 P
0.6 (more than three times slower) 72 255.67 P
0.6 (. A few operations, however) 201.32 255.67 P
0.6 (, are faster: lookup, rename, and mkdir) 327.73 255.67 P
0.6 (.) 501.25 255.67 P
1.25 (Replicating the servers to provide availability further decreases performance. An eight-kilobyte) 72 242.67 P
1.45 (write to a server with one replica is about twice as slow as an eight-kilobyte write to an NFS) 72 229.67 P
(server) 72 216.67 T
(.) 98.24 216.67 T
0 12 Q
(1.2.3. T) 72 185 T
(ransactional Systems) 109.1 185 T
1 11 Q
-0.09 (The concept of) 82.8 159.67 P
2 F
-0.09 ( transactions) 148.52 159.67 P
1 F
-0.09 ( makes it easier to implement fault-tolerant systems. This is because) 205.51 159.67 P
1.71 (transactions make it easier to handle redundancy and failure recovery) 72 146.67 P
1.71 (. Operations executed as) 391.47 146.67 P
-0.25 (transactions are atomic \050either all the changes are made or none is made\051, durable \050the changes sur-) 72 133.67 P
2.59 (vive failures\051, isolated \050serializable\051, and consistent \050the transformation is correct\051 [Gray88].) 72 120.67 P
0.08 (T) 72 107.67 P
0.08 (ransactions ease handling of system redundancy) 78.33 107.67 P
0.08 (, because they can ensure that the replicated por-) 289.47 107.67 P
-0.05 (tions remain consistent. For example, a system that uses replicated \336le servers for availability may) 72 94.67 P
FMENDPAGE
%%EndPage: "27" 39
%%Page: "28" 39
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(28) 318 55 T
1 11 Q
1.06 (update both servers simultaneously as a single transaction. Because transactions are atomic, the) 108 712.67 P
1.95 (state on both servers will remain identical. T) 108 699.67 P
1.95 (ransactions also make recovery actions easier to) 317.17 699.67 P
0.5 (de\336ne. For example, a client might perform a set of related \336le operations as a transaction. If the) 108 686.67 P
-0.15 (transaction \336nishes, the client knows that the server completed all the operations. If the server fails) 108 673.67 P
0.98 (before the transaction \336nishes, the client can assume that the server executed none of its opera-) 108 660.67 P
-0.16 (tions. Thus there is no question about which operations the client must re-execute after the failure.) 108 647.67 P
-0.27 (While transactions make it easier to implement fault-tolerant systems, they do not by themselves) 118.8 622.67 P
2.12 (provide non-stop availability) 108 609.67 P
2.12 (. Redundancy is still necessary) 238.47 609.67 P
2.12 (. If some system component fails,) 381.41 609.67 P
0.94 (transactions cannot provide continuous operation unless another component can take over) 108 596.67 P
0.94 (. Thus) 511.6 596.67 P
(fault-tolerant systems that use transactions do so in conjunction with redundancy) 108 583.67 T
(.) 462.47 583.67 T
0.27 (T) 118.8 558.67 P
0.27 (ransactions do have a disadvantage) 125.13 558.67 P
3 F
0.27 (-) 283.59 558.67 P
1 F
0.27 ( performance overhead. As a general rule, the less a sys-) 289.62 558.67 P
0.19 (tem must do, the faster it can do it, and transactional systems must do extra work. In order to pro-) 108 545.67 P
-0.24 (vide atomicity) 108 532.67 P
-0.24 (, every operation performed in a transaction must be undoable in case the transaction) 170.22 532.67 P
-0.04 (fails. An easy way to make operations undoable is to copy the state of an object before performing) 108 519.67 P
1.2 (any transaction on it. If the transaction fails, the original copy can be restored. But copying an) 108 506.67 P
1.75 (object for each transaction can be costly) 108 493.67 P
1.75 (. Another way to make operations undoable is to log) 294.15 493.67 P
-0.12 (changes to an object, and periodically checkpoint the object by applying the log changes to it. This) 108 480.67 P
0.93 (avoids copying the object for every transaction, but requires extra work to maintain the log and) 108 467.67 P
-0.22 (perform checkpoints. For this reason, systems such as Sprite that care primarily about performance) 108 454.67 P
0.52 (are not built on top of transactional systems. Instead, these systems craft individual operations to) 108 441.67 P
(be atomic as necessary) 108 428.67 T
(.) 207.66 428.67 T
0.08 (In this section I describe two systems that use transactions in dif) 118.8 403.67 P
0.08 (ferent ways to provide recover-) 401.78 403.67 P
0.36 (able \336le systems. LOCUS [Muelle83][Popek85][W) 108 390.67 P
0.36 (alker83] uses transactions to keep data consis-) 334.66 390.67 P
2.49 (tent across replicas, while QuickSilver [Haskin88] uses transactions simply to provide clean) 108 377.67 P
1.33 (recovery of non-replicated resources. While LOCUS and QuickSilver provide transactions as a) 108 364.67 P
1.1 (part of the operating system \050) 108 351.67 P
2 F
1.1 (embedded transaction support) 242.58 351.67 P
1 F
1.1 (\051, some systems provide transaction) 378.44 351.67 P
-0.13 (services in an environment or language built on top of the operating system. T) 108 338.67 P
-0.13 (ransactional systems) 449.5 338.67 P
1.38 (that I do not describe include Camelot [Bruell88], Ar) 108 325.67 P
1.38 (gus [Liskov88], T) 352.27 325.67 P
1.38 (ABS [Specto85], Cedar) 433.19 325.67 P
0.92 ([Gif) 108 312.67 P
0.92 (for88], Clouds [Dasgup88], Eden [Pu86], SW) 126.11 312.67 P
0.92 (ALLOW [Reed81], and V [Cherit84]. T) 330.86 312.67 P
0.92 (andem) 510.71 312.67 P
-0.05 (and Stratus, described previously) 108 299.67 P
-0.05 (, are also transactional systems. Further comparison of embedded) 252.99 299.67 P
(transaction systems can be found in [Gray93] and [Seltz93a].) 108 286.67 T
0 12 Q
(1.2.3.1. LOCUS) 108 255 T
1 11 Q
0.65 (LOCUS provides a UNIX-compatible, transparently distributed \336le system with automatic \336le) 118.8 229.67 P
-0.19 (replication for high availability) 108 216.67 P
-0.19 (. T) 243.73 216.67 P
-0.19 (ransparent handling of replicated \336les is a major goal in LOCUS.) 255.36 216.67 P
0.75 (Users can choose the desired degree of replication for \336les. T) 108 203.67 P
0.75 (o make \336le replication transparent,) 384.13 203.67 P
0.75 (the system automatically propagates updates to a \336le to all its replicas and maintains the consis-) 108 190.67 P
-0.06 (tency of these replicas. Sets of changes to a \336le and its replicas are applied atomically) 108 177.67 P
-0.06 (, with a) 482.83 177.67 P
2 F
-0.06 (com-) 518.04 177.67 P
4.16 (mit) 108 164.67 P
1 F
4.16 ( operation to end the transaction. Closing a \336le automatically commits any changes.) 122.04 164.67 P
0.78 (Recognizing that updates to a set of \336les might be related, LOCUS even allows users to specify) 108 151.67 P
2.19 (groups of \336les amongst which updates should be handled atomically) 108 138.67 P
2.19 (. T) 427.62 138.67 P
2.19 (o make this possible,) 441.25 138.67 P
-0.15 (LOCUS implements) 108 125.67 P
2 F
-0.15 (nested transactions) 200.49 125.67 P
1 F
-0.15 (. A nested transaction is a transaction performed as part of) 285.48 125.67 P
1.31 (a lar) 108 112.67 P
1.31 (ger transaction. Its results are visible as soon as it completes, before the lar) 128.32 112.67 P
1.31 (ger transaction) 473.71 112.67 P
(completes, but can be undone if the lar) 108 99.67 T
(ger transaction fails.) 278.06 99.67 T
FMENDPAGE
%%EndPage: "28" 40
%%Page: "29" 40
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(29) 282 55 T
1 11 Q
0.13 (For the highest availability) 82.8 712.67 P
0.13 (, LOCUS designers originally chose to make both a \336le and its repli-) 200.59 712.67 P
-0.02 (cas available even when they are separated during a network partition. Under these circumstances,) 72 699.67 P
-0.21 (the dif) 72 686.67 P
-0.21 (ferent copies can be concurrently updated, each from within its portion of the partition. Thus) 99.97 686.67 P
1.39 (the \336le and its replica could become inconsistent during a partition. When the partition ended,) 72 673.67 P
-0.03 (LOCUS attempted to mer) 72 660.67 P
-0.03 (ge the \336le\325) 184.94 660.67 P
-0.03 (s con\337icting updates transparently) 231.27 660.67 P
-0.03 (. This led to a lot of special-) 380.91 660.67 P
0.96 (case protocols for mer) 72 647.67 P
0.96 (ging con\337icting copies of dif) 172.61 647.67 P
0.96 (ferent types of \336les or directories. In a more) 303.2 647.67 P
0.32 (recent version of the system, the designers have decided to eliminate this complexity by allowing) 72 634.67 P
0.49 (only the primary copy of a \336le to be modi\336ed during a partition. Thus only the changes from the) 72 621.67 P
(primary copy need to be applied to the replicas to mer) 72 608.67 T
(ge partitions.) 309.18 608.67 T
1.07 (Besides complexity) 82.8 583.67 P
1.07 (, a disadvantage of LOCUS is that it is slow [Lai89]. Maintaining consis-) 169.52 583.67 P
0.5 (tency between \336le replicas is one source of performance overhead. The system enforces \336le con-) 72 570.67 P
0.73 (sistency guarantees across machines with distributed transactions implemented with a two-phase) 72 557.67 P
-0.16 (commit protocol. Thus an update to a \336le requires messages to and from any hosts storing replicas.) 72 544.67 P
1.42 (Another slow operation in LOCUS is failure recovery) 72 531.67 P
1.42 (, because it is optimized for the unlikely) 317.69 531.67 P
-0.16 (occurrence of network partitions. The LOCUS recovery protocol requires communication between) 72 518.67 P
-0 (every pair of hosts in the network. Each host communicates with each other host to ensure that the) 72 505.67 P
(hosts form the lar) 72 492.67 T
(gest possible fully-connected partitions.) 149 492.67 T
0 12 Q
(1.2.3.2. QuickSilver) 72 461 T
1 11 Q
0.51 (The designers of QuickSilver took the approach that software and data replication for recover-) 82.8 435.67 P
0.53 (ability requires too much performance overhead, so the QuickSilver operating system uses trans-) 72 422.67 P
-0.05 (actions as its single system-wide recovery paradigm. QuickSilver guarantees that the \336le system is) 72 409.67 P
0.41 (recoverable to a consistent state after any failure, because all \336le modi\336cations are made transac-) 72 396.67 P
(tionally) 72 383.67 T
(.) 104.86 383.67 T
1.44 (QuickSilver is structured as a small kernel with system services implemented as server pro-) 82.8 358.67 P
-0.13 (cesses. Communication between client and server processes is implemented with an IPC \050interpro-) 72 345.67 P
0.5 (cess communication\051 mechanism with transaction support. The Log Manager provides a general-) 72 332.67 P
1.69 (purpose low-level interface for transactional logging. Using this interface, each server process) 72 319.67 P
-0.16 (chooses the type of logging and commit protocol appropriate for its task. Thus, the servers are able) 72 306.67 P
-0.1 (to optimize transaction performance as much as possible. After a crash, the servers drive their own) 72 293.67 P
(recovery from the log.) 72 280.67 T
0.18 (QuickSilver is probably the transactional \336le system that has placed the highest priority on per-) 82.8 255.67 P
0.89 (formance, but embedded transactions do cause some overhead. For example, a remote one-kilo-) 72 242.67 P
1.31 (byte IPC message on QuickSilver is at least twice as slow as one on Sprite, due in part to the) 72 229.67 P
1.11 (transaction support the QuickSilver IPC system must make to higher) 72 216.67 P
1.11 (-level software. Every IPC) 383.53 216.67 P
0.67 (message belongs to a uniquely identi\336ed transaction. The IPC mechanism must keep track of all) 72 203.67 P
0.41 (servers receiving messages belonging to any particular transaction so that QuickSilver) 72 190.67 P
0.41 (\325) 455.47 190.67 P
0.41 (s T) 458.52 190.67 P
0.41 (ransac-) 472.28 190.67 P
(tion Manager can include them in the transaction\325) 72 177.67 T
(s commit protocol.) 290.17 177.67 T
0 14 Q
(1.3. Recovery Using State Information Stor) 72 144.67 T
(ed in Main Memory) 329.4 144.67 T
1 11 Q
0.1 (T) 82.8 118.67 P
0.1 (raditionally) 89.13 118.67 P
0.1 (, the contents of main memory are not considered reliable after a crash. Even if the) 139.07 118.67 P
0.74 (memory is battery-backed \050non-volatile\051 so that its contents are preserved across power outages,) 72 105.67 P
FMENDPAGE
%%EndPage: "29" 41
%%Page: "30" 41
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(30) 318 55 T
1 11 Q
-0.1 (many systems do not consider the data trust-worthy after a failure. This is because the failure itself) 108 712.67 P
(may in some way have disturbed the data.) 108 699.67 T
0.22 (Instead, systems use magnetic disk or tape or other stable storage device to store data that must) 118.8 674.67 P
0.02 (be preserved across failures. While a failure can also corrupt data stored on these devices, systems) 108 661.67 P
0.86 (designers have accumulated techniques to help prevent, detect and \336x such corruption. Unfortu-) 108 648.67 P
0.37 (nately) 108 635.67 P
0.37 (, accessing data on these devices is orders of magnitude slower than accessing data in main) 134.14 635.67 P
0.67 (memory) 108 622.67 P
0.67 (. Preserving and retrieving data would be much faster if we could safely store it in main) 143.9 622.67 P
(memory) 108 609.67 T
(.) 143.9 609.67 T
0.64 (This thesis develops a method to treat main memory as stable storage. The idea is to structure) 118.8 584.67 P
0.26 (the contents of an area of main memory \050called the) 108 571.67 P
2 F
0.26 (r) 336.95 571.67 P
0.26 (ecovery box) 340.81 571.67 P
1 F
0.26 (\051 so that we can avoid corruption) 393.84 571.67 P
0.09 (of its contents. The recovery box also allows us to detect any memory corruption after a failure. If) 108 558.67 P
0.58 (corruption occurs, we must discard the recovery box contents, but hardware write protection and) 108 545.67 P
0.15 (other techniques described in chapter 5 make this corruption unlikely) 108 532.67 P
0.15 (. If the contents are okay) 412.88 532.67 P
0.15 (, we) 521.54 532.67 P
0.1 (have very fast access to the preserved data after a failure. There is also less performance overhead) 108 519.67 P
0.05 (to maintain the data in main memory during normal system processing than to maintain it on disk.) 108 506.67 P
1.71 (Chapter 5 explains how Sprite uses the recovery box to preserve distributed state information) 108 493.67 P
(across \336le server crashes.) 108 480.67 T
0.75 (The lar) 118.8 455.67 P
0.75 (gest body of work similar to the recovery box consists of the many examples of main-) 150.77 455.67 P
7.47 (memory databases or database models [Birrel87][DeW) 108 442.67 P
7.47 (itt84][Garcia92][Hagman86][Sale-) 386.85 442.67 P
0.52 (m86][Stoneb87]. However) 108 429.67 P
0.52 (, most of these systems eventually push the database log to stable disk) 225.85 429.67 P
1.69 (storage and recover only the tail of the log from memory) 108 416.67 P
1.69 (, which is usually non-volatile. This) 373.77 416.67 P
-0.2 (enables the database to recover a consistent copy of the database even if the tail of the log becomes) 108 403.67 P
0.34 (corrupted. For example, the original design of the POSTGRES storage system assumed the exist-) 108 390.67 P
0.13 (ence of some non-volatile main memory that could be implemented with battery backup and error) 108 377.67 P
0.41 (correction techniques. The design proposed storing the tail of the transaction log in the non-vola-) 108 364.67 P
0.03 (tile memory) 108 351.67 P
0.03 (. However) 160.72 351.67 P
0.03 (, the actual implementation of POSTGRES pushes the log and data pages to) 206.07 351.67 P
(disk on every transaction commit [Sulli93b].) 108 338.67 T
0.85 (Another similar technique is Recoverable V) 118.8 313.67 P
0.85 (irtual Memory \050R) 315.52 313.67 P
0.85 (VM\051 [Satyan93]. R) 393.84 313.67 P
0.85 (VM is a very) 479.79 313.67 P
1.21 (lightweight transactional facility designed for UNIX applications with persistent data structures) 108 300.67 P
0.95 (whose updates must be fault-tolerant. T) 108 287.67 P
0.95 (o avoid severe performance overhead, R) 285.9 287.67 P
0.95 (VM values sim-) 467.31 287.67 P
1 (plicity over generality; for instance, it does not provide nested or distributed transactions, but it) 108 274.67 P
-0.25 (does provide permanence in the event of power failures by pushing log changes to disk. The recov-) 108 261.67 P
0.93 (ery box takes an even more extreme approach. The recovery box does not by itself protect data) 108 248.67 P
-0.04 (from power failures, so it does not need to write data to disk. This makes it very lightweight, but it) 108 235.67 P
(also limits its suitability to applications that can occasionally suf) 108 222.67 T
(fer failures.) 391.32 222.67 T
0.86 (Despite this list of similar techniques, there seem to be few systems that depend primarily on) 118.8 197.67 P
-0.15 (main memory for stable storage of any of their data, and in particular) 108 184.67 P
-0.15 (, very few \336le systems that do) 409.37 184.67 P
0.23 (this. Besides Sprite\325) 108 171.67 P
0.23 (s use of the recovery box, I am aware of only two other \336le systems that have) 196.06 171.67 P
0.13 (considered this technique: the Phoenix In-Memory File System [Gait90], and the Harp \336le system) 108 158.67 P
1.7 ([Liskov91]. However) 108 145.67 P
1.7 (, Harp currently does not actually implement the technique [Johnso93]. I) 203.84 145.67 P
(describe these two systems in this section.) 108 132.67 T
FMENDPAGE
%%EndPage: "30" 42
%%Page: "31" 42
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(31) 282 55 T
0 F
(1.3.1. Phoenix) 72 712 T
1 11 Q
0.26 (Phoenix is an in-memory \336le system intended mainly for diskless computers with battery-pow-) 82.8 686.67 P
1.1 (ered memory) 72 673.67 P
1.1 (. T) 130.65 673.67 P
1.1 (o protect the \336le system, Phoenix uses a copy-on-write and checkpoint scheme.) 143.19 673.67 P
1.96 (The system starts with a time-stamped and write-protected copy of the \336le system called the) 72 660.67 P
0.27 (reserve \336le system. As pages of the \336le system change, the new pages are added to a new version) 72 647.67 P
1.03 (of the \336le system, leaving the reserve copy unchanged. At some interval the system performs a) 72 634.67 P
-0.05 (checkpoint, garbage collecting the replaced pages in the reserve \336le system. Then the process con-) 72 621.67 P
0.08 (tinues with the newly time-stamped version used as the reserve \336le system. W) 72 608.67 P
0.08 (ith this use of mem-) 415.79 608.67 P
-0.12 (ory) 72 595.67 P
-0.12 (, Phoenix is probably not appropriate for lar) 85.93 595.67 P
-0.12 (ge highly-active \336le systems. Its designer) 277.7 595.67 P
-0.12 (, however) 458.5 595.67 P
-0.12 (,) 501.25 595.67 P
(feels it might be appropriate as a cache for lar) 72 582.67 T
(ge high-performance \336le systems.) 272.85 582.67 T
0.1 (There is one big dif) 82.8 557.67 P
0.1 (ference between Phoenix\325) 169.07 557.67 P
0.1 (s use of main memory and the recovery box\325) 282.76 557.67 P
0.1 (s use.) 479.48 557.67 P
0.35 (After a crash Phoenix may lose all changes to the \336le system since the last checkpoint. While the) 72 544.67 P
-0.17 (memory containing the changes may be non-volatile, there seem to be no checksums or other tech-) 72 531.67 P
1.5 (niques to ensure its contents are uncorrupted. Checksums may be too expensive to protect the) 72 518.67 P
(Phoenix \336le system from corruption.) 72 505.67 T
0 12 Q
(1.3.2. Harp) 72 474 T
1 11 Q
0.42 (Harp is relevant to this thesis for at least two reasons: it stores state information in main mem-) 82.8 448.67 P
0.54 (ory) 72 435.67 P
0.54 (, and it uses replicated \336le servers for high availability) 85.93 435.67 P
0.54 (. Harp is a replicated UNIX \336le system) 328.72 435.67 P
0.82 (accessed via NFS. Each primary Harp \336le server has a backup \336le server capable of serving the) 72 422.67 P
-0.07 (same \336les. The backup can also be a primary \336le server for a dif) 72 409.67 P
-0.07 (ferent set of \336les, to avoid wasting) 352.78 409.67 P
0.03 (capacity in the system. Clients send their requests to a primary \336le server) 72 396.67 P
0.03 (. The primary server logs) 393.11 396.67 P
0.14 (any resulting \336le system changes to its main memory) 72 383.67 P
0.14 (. It later applies these changes to the \336le sys-) 306.2 383.67 P
0.26 (tem on disk asynchronously) 72 370.67 P
0.26 (. Before responding to the client, the primary server also forwards the) 195.06 370.67 P
0.1 (request information to the backup server) 72 357.67 P
0.1 (, which logs the \336le system modi\336cations in its own main) 249.96 357.67 P
1.92 (memory) 72 344.67 P
1.92 (. The backup then responds to the primary before the primary responds to the client.) 107.9 344.67 P
0.61 (Updating this information in the main memory of the backup server is faster than synchronously) 72 331.67 P
-0.17 (updating the \336le system on disk. In this way) 72 318.67 P
-0.17 (, Harp replicates its \336le system change log in the mem-) 263.72 318.67 P
(ory of a backup machine in the same way Echo replicates its token information.) 72 305.67 T
0.46 (Harp designers considered using main memory to store information to help the system recover) 82.8 280.67 P
0.73 (after failures that cause both the primary and backup server to crash. If both servers crash, Harp) 72 267.67 P
-0.11 (loses the \336le system changes logged only in main memory) 72 254.67 P
-0.11 (. T) 326.94 254.67 P
-0.11 (o handle multiple server crashes Harp) 338.27 254.67 P
0.73 (considered modifying UNIX so that a portion of its volatile memory would survive a soft crash.) 72 241.67 P
0.34 (They could then store some system state, such as the log and information about the commit state,) 72 228.67 P
-0.16 (in this part of memory and use it to restart the system quickly) 72 215.67 P
-0.16 (. The designers have so far not imple-) 339.13 215.67 P
0.04 (mented the technique, because they do a complete reboot after a crash, and their computers \050a col-) 72 202.67 P
1.48 (lection of MicroV) 72 189.67 P
1.48 (ax 3500\325) 153.06 189.67 P
1.48 (s\051 perform a memory check that overwrites the contents of memory) 192.68 189.67 P
([Johnso93].) 72 176.67 T
0 14 Q
(1.4. Summary) 72 143.67 T
1 11 Q
1.23 (An important part of recovery in distributed \336le systems is the recovery of distributed cache) 82.8 117.67 P
0.13 (state information. Many modern distributed \336le systems cache \336le data on client workstations and) 72 104.67 P
2.55 (provide cache consistency by maintaining distributed cache state information the \336le server) 72 91.67 P
2.55 (.) 501.25 91.67 P
FMENDPAGE
%%EndPage: "31" 43
%%Page: "32" 43
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(32) 318 55 T
1 11 Q
0.26 (Recovering this state information quickly after a \336le server failure is part of the challenge for fast) 108 712.67 P
(crash recovery and is the subject of most of this dissertation.) 108 699.67 T
0.27 (Fast crash recovery is an availability technique intended for environments that require low cost) 118.8 674.67 P
0.71 (and high performance and that bene\336t only secondarily from high availability) 108 661.67 P
0.71 (. The fast recovery) 455.51 661.67 P
1.69 (approach is not fault-tolerant. It does not mask or repair faults. It merely recovers from them) 108 648.67 P
(quickly enough to provide good availability) 108 635.67 T
(.) 299.84 635.67 T
0.69 (In contrast, traditional systems provide high availability through the use of fault-tolerant tech-) 118.8 610.67 P
-0.09 (niques) 108 597.67 P
3 F
-0.09 (-) 139.34 597.67 P
1 F
-0.09 ( techniques designed to allow the system to operate correctly and continuously despite the) 145.38 597.67 P
0.39 (presence of faults. These techniques are necessary for non-stop operation, but they can be expen-) 108 584.67 P
0.35 (sive, slow and complex. Most of these systems use replicated hardware and software that enables) 108 571.67 P
0.7 (them to mask faults. Other systems also use error repair to \336x the damage associated with faults) 108 558.67 P
1.69 (and continue operating. Some systems make all \336le system modi\336cations transactionally) 108 545.67 P
1.69 (. This) 513.28 545.67 P
0.67 (ensures that their \336le systems are recoverable to a consistent state. Figure 1-7 qualitatively illus-) 108 532.67 P
(trates these dif) 108 519.67 T
(ferences between the fault-tolerant and fast recovery approaches.) 171.88 519.67 T
FMENDPAGE
%%EndPage: "32" 44
%%Page: "33" 44
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(33) 282 55 T
1 11 Q
(Figure 1-7. Comparison of fault-tolerant and fast recovery approaches.) 132.7 397.67 T
1 10 Q
-0.19 (This \336gure qualitatively illustrates the dif) 108 375.33 P
-0.19 (ference between the fault-tolerant and fast recov-) 272.63 375.33 P
0.38 (ery approaches to providing high availability) 108 364.33 P
0.38 (. The \336gure is a Kiviat graph. There are \336ve) 288.86 364.33 P
0.71 (axes, each showing the value of a system parameter) 108 353.33 P
0.71 (. For example, the upper axis shows) 319.93 353.33 P
0.55 (the cost of the system. A point far away from the center of the \336gure indicates low cost,) 108 342.33 P
-0.12 (while a point towards the center indicates high cost. On all axes, a point farther away from) 108 331.33 P
1.11 (the center is better) 108 320.33 P
1.11 (. The fast recovery approach meets the axes at points indicating low) 184.33 320.33 P
0.09 (cost, simplicity) 108 309.33 P
0.09 (, low performance overhead, fairly fast recovery) 168.52 309.33 P
0.09 (, and some number of fail-) 361.54 309.33 P
1.3 (ures. The fault tolerant approach guarantees the fastest recovery time and no complete) 108 298.33 P
0.31 (failures, since it masks faults entirely) 108 287.33 P
0.31 (. However) 257.69 287.33 P
0.31 (, it is more expensive due to its replicated) 299.23 287.33 P
(hardware, it is more complex, and it has higher performance overhead.) 108 276.33 T
72 423 504 720 C
72 423 504 708 C
0 0 0 612 792 298 341.5 143 361.5 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/kiviat.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 612 792
%%CreationDate: Mon Dec 13 20:47:40 1993
%%Title: kiviat.ppres
%%For: mgbaker (Mary Baker)
%%DocumentNeededResources: font Times-Bold Times-Roman Helvetica-Bold 
%%Creator: Perspecta Presents
%%Pages: (atend)
%%PageOrder: Ascend
%%EndComments
%%BeginProlog
% Start of header.ps -- prolog for postscript output
% Copyright (c) 1992, Perspecta Software, Inc.
% All rights reserved.
% $Header: /home/ginger/sprite/users/mgbaker/thesis/RCS/kiviat.ps,v 1.2 1993/12/18 21:45:53 mgbaker Exp $
save /SpotJob exch def
40 dict begin

% Be a good EPS file and declare all the variables that will be used.

/Matrix matrix def	% Utility matrix
/CL 0 def		% Color level (0 = BW, 1 = Grey, 2 = Color)
/FStep .5 def		% Feathering step.
/SY 0 def		% Saved Y pos for showing text.
/Boxes 8 def		% Number of boxes per side for stipple pattern.

/t true def		% Used when drawing lines.
/f false def

/x 0 def		% The variable x is used as a utility variable to hold
			% temporary data in procedures.

/x1 0 def		% Used to ensure that slide fits in printing area
/y1 0 def		% of the paper.
/x2 0 def
/y2 0 def
/dx 0 def
/dy 0 def
/dpx 0 def
/dpy 0 def

/dict_countppres 0 def	% Used when including EPS files.
/op_countppres 0 def


% Set the drawing color depending on the color level.
% If the rgb color is actually a shade of gray, use "setgray"
% instead of "setrgbcolor" because it gives better output on
% some color printers.

/Color {		% r g b --
  setrgbcolor
  CL 2 lt {
    currentgray
    CL 0 eq {
      .5 lt {0} {1} ifelse
    } if
    setgray
  } {
    currentrgbcolor 2 index eq 3 1 roll eq and {
      currentgray setgray
    } if
  } ifelse
} bind def


% Make a rectangular path.

/Rect {			% x y width height --
  4 2 roll moveto 1 index 0 rlineto 0 exch rlineto neg 0 rlineto closepath
} bind def


% Make a path consisting of an arc segment.

/Arc {			% x y width height startangle endangle --
  Matrix currentmatrix pop
  6 2 roll 2 div exch 2 div exch 4 2 roll
  2 index add exch 3 index add exch translate
  scale
  0 0 1 5 3 roll arcn
  Matrix setmatrix
} bind def


% Make a path consisting of a pie slice.

/Pie {			% x y width height startangle endangle --
  Matrix currentmatrix pop 
  6 2 roll 2 div exch 2 div exch 4 2 roll
  2 index add exch 3 index add exch translate
  scale
  0 0 moveto 0 0 1 5 3 roll arcn closepath
  Matrix setmatrix
} bind def


% Make a path consisting of a sequence of line segments.

/Line {			% closed? mark x1 y1 x2 y2 [x3 y3 ...] --
  counttomark -2 2 {2 roll} for
  moveto
  counttomark -1 bitshift {lineto} repeat
  pop
  {closepath} if
} bind def


% Fill an existing rectangular path with a blended fill.

/Feather {		% r1 g1 b1 r2 g2 b2 angle x y --
  gsave
    clip
    translate
    rotate
    3 2 roll 5 index sub
    3 2 roll 4 index sub
    3 2 roll 3 index sub
    /x CL def
    CL 0 eq {/CL 1 def} if

    pathbbox 4 2 roll pop pop

    exch FStep div floor FStep mul dup 1 le {pop 1} if exch

    newpath

    0 FStep 3 index {
      0 0 FStep 2 mul 4 index Rect
      2 index div
      dup 6 index mul 9 index add exch
      dup 6 index mul 9 index add exch
      5 index mul 8 index add Color fill
      FStep 0 translate
    } for
    
    8 {pop} repeat
    /CL x def
  grestore
  newpath
} bind def


% Return the size in points to use for one side of a square bitmap used in
% tiling the plane.  The desired effect is that each "bitmap pixel", when
% printed, occupies an integer number of "printer pixels", so that Moire
% and other interference patterns are avoided.

/PatternSide {		% -- side
  72 0 Matrix currentmatrix dtransform
  dup mul exch dup mul add sqrt 72 div dup round dup 0 eq {pop 1} if
  exch div Boxes mul
} bind def


% Either fill the interior or stroke the border of a the current path with
% a colored pattern.  The path and color are already established by the
% caller

/Pattern {		% string filled? --
  % When stroking a stippled dashed line, it may die, so in that
  % case stroke the line stippled without the dashes.

  {
    gsave eoclip
  } {
    {gsave strokepath} stopped {grestore gsave [] 0 setdash strokepath} if
    clip
  } ifelse

  PatternSide Boxes div dup neg scale

  pathbbox
  newpath
  Matrix identmatrix pop

  4 2 roll
  Boxes div cvi Boxes mul Boxes sub 4 1 roll
  Boxes div cvi Boxes mul 3 2 roll

  Boxes exch {
    2 index Boxes 3 index {
      gsave
        1 index exch translate
	Boxes dup true Matrix {3 index} imagemask
      grestore
    } for
    pop
  } for

  pop
  pop
  pop
  grestore
  newpath
} bind def

% Ensure that a bbox specifying the slide's area will fit inside the
% printable region of the printer.

/Fits {		% x1 y1 x2 y2 --
  /y2 exch def
  /x2 exch def
  /y1 exch def
  /x1 exch def
  clippath pathbbox newpath
  x1 4 index lt x2 3 index gt or {
    3 index 0 translate
    true
  } {false} ifelse
  y1 4 index lt y2 3 index gt or {
    0 4 index translate
    true
  } {false} ifelse
  /dx x2 x1 sub def  
  /dy y2 y1 sub def  
  3 index 6 index sub /dpx exch def 
  2 index 5 index sub /dpy exch def 
  dx dpx gt dy dpy gt or {
    dx dpx sub dy dpy sub gt {dpx dx div} {dpy dy div} ifelse dup scale
  } if
  {0 y1 neg translate} if
  {x1 neg 0 translate} if
  4 {pop} repeat
} bind def



% The following routines are used to print text items

% Find font.

/F {		% pointsize fontname
  findfont exch scalefont setfont
} bind def  


% Show a string in the current font at the specified coordinates.

/S {		% string x y
  neg dup /SY exch def moveto show
} bind def


% Show a string in the current font at the specified x location, and at
% the same y location as the most recently displayed string.

/R {		% string x
  SY moveto show
} bind def

/Notice {
  0 setgray 10 /Helvetica F
  translate 1 -1 scale
  (Call Perspecta Software at 510-649-4900 to get licenses.) 0 0 S
} bind def
    


% The following routines are used to include ecapsulated postscript files.

% Save state before inserting an encapsulated postscript file.

/BeginEPSFppres {		% -- save
  save
  /dict_countppres countdictstack def
  /op_countppres count 1 sub def
  userdict begin
  /showpage {} def
  0 setgray 0 setlinecap 1 setlinewidth 0 setlinejoin
  10 setmiterlimit [] 0 setdash newpath
  /languagelevel where {
    pop languagelevel 1 ne {
      false setstrokeadjust false setoverprint
    } if
  } if
} bind def


% Restore state after inserting an encapsulated postscript file.

/EndEPSFppres {		% save --
  count op_countppres sub {pop} repeat
  countdictstack dict_countppres sub {end} repeat
  restore
} bind def


% The following routines are convenience routines for drawing items.

/W /setlinewidth load def
/D {0 setdash} bind def
/K /stroke load def
/L /eofill load def

% The following is Ken Shirriff's magic incantation to re-align the
% color dots for the color printer in 608-2.

{
    { } setblackgeneration
    { pop 0 } setundercolorremoval
    
    currentcolorscreen
    /scrn exch def
    /ang exch def
    /freq exch def
    
    pop pop pop pop pop pop pop pop pop
    
    freq ang {scrn} freq ang {scrn} freq ang {scrn}
    freq ang {scrn} setcolorscreen
} stopped pop
/CL 2 def
%%EndProlog
%%BeginSetup
%%IncludeResource: font Times-Bold Times-Roman Helvetica-Bold 
%%EndSetup
%%Page: slide_1 1
save 0 792 translate 1 -1 scale
 save 0 0 translate 1 dup scale
  0 0 612 792 Rect clip 1 setgray fill
  495 657 translate 1 -1 scale
  1 -1 scale -495 -657 translate newpath
  97 95 translate 1 -1 scale
  1 -1 scale -97 -95 translate newpath
  360 36 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (inexpensive) 0.472 22.504 S
  1 -1 scale -360 -36 translate newpath
  45 306 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (simple) -0.224 24.16 S
  1 -1 scale -45 -306 translate newpath
  81 36 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (no) 0.784 22.504 S
   (downtime) 30.784 R
  1 -1 scale -81 -36 translate newpath
  405 297 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (low) 116 22.504 S
   (performance) 30.728 54.62752 S
   (overhead) 64.04 86.75104 S
  1 -1 scale -405 -297 translate newpath
  243 432 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (no) 0.784 22.504 S
   (failures) 30.784 R
  1 -1 scale -243 -432 translate newpath
  t [ 337.5 49.5 488.25 252 353.25 373.5 126 335.25 166.5 123.75 337.5 49.5 Line 0 0 0 Color 
  <8004400801200210> t Pattern
  t [ 337.5 49.5 488.25 252 353.25 373.5 126 335.25 166.5 123.75 337.5 49.5 Line 0 0 0 Color 2 W K
  t [ 312.75 168.75 414 252 396 459 207 297 132.75 90 312.75 168.75 Line 0 0 0 Color 
  <8844221188442211> t Pattern
  t [ 312.75 168.75 414 252 396 459 207 297 132.75 90 312.75 168.75 Line 0 0 0 Color 2 W K
  t [ 288 252 284.085 239.168 275.385 247.433 Line 0 0 0 Color L
  t [ 117 72 120.915 84.8325 129.615 76.5675 Line 0 0 0 Color L
  f [ 121.132 76.35 283.868 247.65 Line 0 0 0 Color 2 W K
  t [ 297 243 305.321 232.476 293.574 230.029 Line 0 0 0 Color L
  t [ 342 27 333.679 37.524 345.426 39.9715 Line 0 0 0 Color L
  f [ 340.776 32.8739 298.224 237.126 Line 0 0 0 Color 2 W K
  t [ 522 252 510 246 510 258 Line 0 0 0 Color L
  t [ 306 252 318 258 318 246 Line 0 0 0 Color L
  f [ 312 252 516 252 Line 0 0 0 Color 2 W K
  t [ 405 477 405 463.584 394.267 468.95 Line 0 0 0 Color L
  t [ 297 261 297 274.416 307.733 269.05 Line 0 0 0 Color L
  f [ 299.683 266.367 402.317 471.633 Line 0 0 0 Color 2 W K
  t [ 288 261 274.591 260.545 279.591 271.454 Line 0 0 0 Color L
  t [ 72 360 85.4087 360.455 80.4088 349.546 Line 0 0 0 Color L
  f [ 77.4544 357.5 282.546 263.5 Line 0 0 0 Color 2 W K
  45 486 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (fast) 0.52 22.504 S
   (recovery) 41.176 R
   (system) 131.128 R
  1 -1 scale -45 -486 translate newpath
  45 522 translate 1 -1 scale
   0 0 0 Color 24 /Times-Roman F
   (fault-tolerant) 0.52 22.504 S
   (system) 131.824 R
  1 -1 scale -45 -522 translate newpath
  261 486 81 27 Rect 0 0 0 Color 
  <8004400801200210> t Pattern
  261 486 81 27 Rect 0 0 0 Color 2 W K
  261 522 81 27 Rect 0 0 0 Color 
  <8844221188442211> t Pattern
  261 522 81 27 Rect 0 0 0 Color 2 W K
 restore
restore showpage
%%Trailer
%%Pages: 1
end SpotJob restore
%%EOF

%%EndDocument
FMENDEPSF
72 423 504 720 C
72 423 504 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "33" 45
%%Page: "34" 45
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(34) 318 55 T
108 666 540 720 C
108 666 540 720 R
7 X
0 K
V
108 693 540 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
108 594 540 648 C
108 594 540 648 R
7 X
0 K
V
108 603 540 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(3) 144 638 T
0 18 Q
(Client-Driven Recovery) 180 654 T
1 11 Q
-0.27 (This chapter describes client-driven recovery of distributed cache and \336le system state. In client-) 118.8 519.67 P
1.55 (driven recovery) 108 506.67 P
1.55 (, clients detect \336le server failures and initiate recovery with the server when it) 178.09 506.67 P
0.28 (reboots. T) 108 493.67 P
0.28 (o recover) 152.06 493.67 P
0.28 (, the clients send the server their \336le system state, including information about) 193.07 493.67 P
1.43 (which \336les they have cached locally) 108 480.67 P
1.43 (. From this information, the server rebuilds the distributed) 273.42 480.67 P
(cache state that it uses to guarantee cache consistency) 108 467.67 T
(.) 343.43 467.67 T
0.31 (The advantage of client-driven recovery is that it is the most natural and least complex form of) 118.8 442.67 P
0.32 (state recovery in Sprite. The clients control recovery and request recovery of the \336le server in the) 108 429.67 P
0.28 (same way they request all other services. Client-driven recovery thus requires the least amount of) 108 416.67 P
-0.16 (special-purpose code of all the techniques described in this thesis. This reduces the probability that) 108 403.67 P
(the recovery code is itself incorrect and likely to cause a failure.) 108 390.67 T
0.12 (However) 118.8 365.67 P
0.12 (, allowing the clients to drive recovery also has several disadvantages, including a ten-) 158.62 365.67 P
0.8 (dency to cause resource contention on the \336le server) 108 352.67 P
0.8 (. For example, as the Sprite system grew to) 343.82 352.67 P
0.7 (include more client workstations, the increased amount of recovery traf) 108 339.67 P
0.7 (\336c caused server conges-) 427.77 339.67 P
1.05 (tion and instability during recovery) 108 326.67 P
1.05 (. Recovery of the distributed cache state sometimes required) 266.49 326.67 P
0.73 (ten to \336fteen minutes to complete, and occasionally failed to \336nish until users rebooted many of) 108 313.67 P
(the client workstations.) 108 300.67 T
-0.08 (Fortunately) 118.8 275.67 P
-0.08 (, the server congestion problem is solvable. W) 168.74 275.67 P
-0.08 (ith the congestion control mechanisms) 371.26 275.67 P
0.19 (and other performance improvements described in this chapter) 108 262.67 P
0.19 (, it now takes an average of 21 sec-) 383.8 262.67 P
1.45 (onds to recover the cache state on a SP) 108 249.67 P
1.45 (ARCstation-2 server in a test network with ten clients.) 289.46 249.67 P
0.5 (There is a lot of variance in this recovery time, because as described later in this chapter) 108 236.67 P
0.5 (, ten cli-) 502.69 236.67 P
-0.18 (ents may easily take 30 seconds to recover) 108 223.67 P
-0.18 (. Many more clients may be added to the system without) 293.14 223.67 P
0.28 (increasing recovery time beyond 30 seconds, because the server spends over 90% of the recovery) 108 210.67 P
(time idle, waiting for clients to send it their state to recover) 108 197.67 T
(.) 367.38 197.67 T
0.01 (Other problems with client-driven recovery are cache consistency violations after a server crash) 118.8 172.67 P
0.63 (and limited recovery speed. Unlike the congestion problems, these problems cannot be solved in) 108 159.67 P
1.41 (the client-driven recovery approach. The cache consistency violations arise, because the server) 108 146.67 P
0.79 (does not have control over when recovery \336nishes and other client requests begin. Client-driven) 108 133.67 P
1.01 (recovery is slower than the other techniques, because the server must wait for clients to initiate) 108 120.67 P
0.38 (recovery) 108 107.67 P
0.38 (. These problems are addressed by server) 145.72 107.67 P
0.38 (-driven recovery) 328.72 107.67 P
0.38 (, which is described in the next) 401.29 107.67 P
(chapter) 108 94.67 T
(.) 139.73 94.67 T
FMENDPAGE
%%EndPage: "34" 46
%%Page: "35" 46
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(35) 282 55 T
1 11 Q
0.66 (This chapter is or) 82.8 712.67 P
0.66 (ganized as follows. It \336rst explains the process of client-driven recovery and) 161.16 712.67 P
-0 (then details the amount and type of state recovered by clients. Then it lists the problems that cause) 72 699.67 P
-0.16 (congestion on the \336le server during recovery) 72 686.67 P
-0.16 (, and how to solve them. Finally) 266.8 686.67 P
-0.16 (, it describes the prob-) 406.71 686.67 P
0.45 (lems that can be solved only by switching to server) 72 673.67 P
0.45 (-driven or transparent recovery: cache consis-) 300.71 673.67 P
2.18 (tency violations after a server failure and limited recovery speed. Brent W) 72 660.67 P
2.18 (elch designed and) 420.93 660.67 P
-0.15 (implemented the original version of client-driven recovery) 72 647.67 P
-0.15 (, but the analysis of its problems and the) 327.9 647.67 P
(solutions presented here are my own work.) 72 634.67 T
0 14 Q
(3.1. How Client-Driven Recovery W) 72 601.67 T
(orks) 286.52 601.67 T
1 11 Q
-0.22 (While Sprite\325) 82.8 575.67 P
-0.22 (s distributed caches create a crash recovery problem, their distributed nature is also) 141.47 575.67 P
2.34 (the solution to this problem. This observation was made by Brent W) 72 562.67 P
2.34 (elch and Mike Nelson:) 397.19 562.67 P
0.04 (although the server loses its distributed cache state information after a crash, each client retains its) 72 549.67 P
1.27 (own information about which \336les it has open or cached. T) 72 536.67 P
1.27 (o regenerate the information on the) 342.97 536.67 P
-0.12 (server) 72 523.67 P
-0.12 (, it is necessary only to gather that information from the clients. In client-driven recovery the) 98.4 523.67 P
-0.11 (clients detect that the server has crashed and rebooted, and they send the server their cache and \336le) 72 510.67 P
-0 (system state via an idempotent recovery protocol. From this state, the server reconstructs the vola-) 72 497.67 P
(tile data structures it uses to guarantee cache consistency and to control access to its resources.) 72 484.67 T
0.67 (The following sections describe this mechanism in more detail. The \336rst section explains how) 82.8 459.67 P
0.65 (clients detect server crashes. The next section describes how clients recover with the server) 72 446.67 P
0.65 (. The) 480.77 446.67 P
0.23 (third section describes recovery on the server side, namely) 72 433.67 P
0.23 (, how the server uses the state informa-) 330.32 433.67 P
(tion it receives from clients.) 72 420.67 T
0 12 Q
(3.1.1. Detecting Server Crashes and Reboots) 72 389 T
1 11 Q
1.45 (T) 82.8 363.67 P
1.45 (o initiate recovery with a server that has crashed and rebooted, the clients must be able to) 88.74 363.67 P
0.16 (detect the crash and reboot. Sprite clients do this using a low-level mechanism that monitors mes-) 72 350.67 P
0.04 (sage traf) 72 337.67 P
0.04 (\336c. Hosts communicate with each other in Sprite using kernel-to-kernel remote procedure) 109.36 337.67 P
0.55 (calls \050RPCs\051 [W) 72 324.67 P
0.55 (elch86]. A client issues a request of the \336le server by sending it an RPC. One of) 144.24 324.67 P
0.26 (several RPC server processes in the server) 72 311.67 P
0.26 (\325) 260.05 311.67 P
0.26 (s kernel handles the request. The server then sends the) 263.11 311.67 P
0.06 (results of the request back to the client in a response to the RPC. The clients and server keep track) 72 298.67 P
0.02 (of hosts from which they\325ve received an RPC request or reply) 72 285.67 P
0.02 (. If they\325ve received a message from) 343.69 285.67 P
0.25 (a host recently) 72 272.67 P
0.25 (, they label the host as being alive. But if an RPC to a server) 135.85 272.67 P
2 F
0.25 (times out) 407.15 272.67 P
1 F
0.25 ( \050receives no) 447.38 272.67 P
0.09 (response\051, the client considers the server to have crashed. The RPC that times out will) 72 259.67 P
2 F
0.09 (hang) 453.87 259.67 P
1 F
0.09 (, wait-) 475.84 259.67 P
-0.19 (ing for the server to become available again. T) 72 246.67 P
-0.19 (o detect when the server returns to service, the client) 274.44 246.67 P
1.31 (periodically) 72 233.67 P
2 F
1.31 (pin) 128.54 233.67 P
1 F
1.31 (gs the dead server) 142.58 233.67 P
1.31 (. A ping is a simple RPC that requests nothing more than an) 224.92 233.67 P
1.49 (acknowledgment from the receiving host. When the client \336nally receives an acknowledgment) 72 220.67 P
0.09 (from a server that crashed, it means the server has rebooted and is available again. The clients can) 72 207.67 P
(then recover with it.) 72 194.67 T
0.72 (T) 82.8 169.67 P
0.72 (o detect server reboots, clients also monitor the server) 88.74 169.67 P
0.72 (\325) 331.96 169.67 P
0.72 (s) 335.01 169.67 P
2 F
0.72 (boot ID) 342.75 169.67 P
1 F
0.72 (. A host changes its boot ID) 377.33 169.67 P
1 (whenever it reboots, and it includes this boot ID in the header of every RPC request or reply it) 72 156.67 P
0.27 (issues. If a server crashes and reboots between RPCs from a client, the client will detect a change) 72 143.67 P
0 (in the bootID during its next RPC. W) 72 130.67 P
0 (ith the improvements in recovery speed described in this the-) 235.77 130.67 P
0.18 (sis, it is possible for a server to crash and reboot quickly enough that a client would not otherwise) 72 117.67 P
(detect the event with a hung RPC.) 72 104.67 T
FMENDPAGE
%%EndPage: "35" 47
%%Page: "36" 47
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(36) 318 55 T
1 11 Q
0.71 (The boot ID also helps distinguish between a true crash and a network partition. In a network) 118.8 712.67 P
1 (partition, the server remains operational but is unreachable due to network problems. If a client) 108 699.67 P
-0.19 (marks a server as dead and later receives an acknowledgment to a ping, it checks the boot ID in the) 108 686.67 P
2.23 (server) 108 673.67 P
2.23 (\325) 135.25 673.67 P
2.23 (s acknowledgment. If the boot ID has changed, the client knows that the server truly) 138.3 673.67 P
0.6 (crashed and rebooted. If the boot ID has not changed, then the server) 108 660.67 P
0.6 (\325) 418.26 660.67 P
0.6 (s inability to communicate) 421.32 660.67 P
(was due to a network partition.) 108 647.67 T
0.55 ( Unfortunately) 118.8 622.67 P
0.55 (, dif) 183.02 622.67 P
0.55 (ferentiating between crashes and network partitions is not very useful in the) 201.07 622.67 P
0.12 (context of Sprite\325) 108 609.67 P
0.12 (s state recovery) 184.54 609.67 P
0.12 (. Even if the communication lapse was due to a network partition) 252.41 609.67 P
0.62 (and not a crash, the client must still go through recovery with the server) 108 596.67 P
0.62 (. This is because servers) 431.02 596.67 P
0.01 (also monitor the state of clients. If the server cannot communicate with a client, it assumes the cli-) 108 583.67 P
-0.25 (ent has crashed and it garbage collects the client\325) 108 570.67 P
-0.25 (s state information. When the client and server are) 320.8 570.67 P
-0.06 (again able to communicate, the client must assume that the server has cleaned up its state informa-) 108 557.67 P
0.42 (tion. The client therefore treats the network partition as if the server crashed and rebooted, so the) 108 544.67 P
(client must send the server its state information again.) 108 531.67 T
0 12 Q
(3.1.2. Client State Recovery) 108 500 T
1 11 Q
0.99 (When a client detects that a server has crashed and rebooted, it initiates recovery action with) 118.8 474.67 P
0.54 (that server) 108 461.67 P
0.54 (. This section describes the \336rst of the two basic steps a client goes through to recover) 154 461.67 P
-0.25 (from a server crash. In the \336rst step, the client sends its cache state and other \336le system state to the) 108 448.67 P
0.25 (server) 108 435.67 P
0.25 (. This is called) 134.24 435.67 P
2 F
0.25 (r) 202.05 435.67 P
0.25 (ecovering) 205.92 435.67 P
1 F
0.25 ( the state information. This section details the amount and type of) 249.24 435.67 P
0.47 (state the clients recover) 108 422.67 P
0.47 (, and explains how the clients recover it. The second client recovery step,) 212.41 422.67 P
(restarting hung RPCs, is described in the next section.) 108 409.67 T
1.08 (There are three basic types of state information, and clients recover these in separate phases:) 118.8 384.67 P
2 F
0.65 (pr) 108 371.67 P
0.65 (e\336xes) 117.36 371.67 P
1 F
0.65 ( \336rst, then) 141.76 371.67 P
2 F
0.65 (I/O handles) 190.7 371.67 P
1 F
0.65 (, and \336nally) 242.91 371.67 P
2 F
0.65 (str) 299.78 371.67 P
0.65 (eams) 310.98 371.67 P
1 F
0.65 (, as described below) 333.55 371.67 P
0.65 (. I provide the most detail) 423.86 371.67 P
0.27 (for recovery of I/O handles for \336les. This is because \336les are the only cacheable objects in Sprite.) 108 358.67 P
0.01 (File I/O handles thus form the distributed cache state that accounts for the bulk of \336le system state) 108 345.67 P
(to recover) 108 332.67 T
(.) 151.63 332.67 T
0.05 (Clients \336rst recover their pre\336xes. A pre\336x is a reference to the root of a \336le system, and it con-) 118.8 307.67 P
0.58 (tains information about that \336le system domain. A client cannot access an object in a \336le system) 108 294.67 P
0.44 (without \336rst obtaining a pre\336x handle to that \336le system. Thus pre\336xes must be recovered before) 108 281.67 P
(other types of information.) 108 268.67 T
1.12 (Clients next recover their I/O handles. I/O handles store information about objects in the \336le) 118.8 243.67 P
1.2 (system, such as \336les and directories, devices, pipes, and) 108 230.67 P
2 F
1.2 (pseudo device) 366.83 230.67 P
1 F
1.2 (s. \050A pseudo-device is a) 429.96 230.67 P
1.8 (named object in the \336le system that is actually implemented by a user) 108 217.67 P
1.8 (-level software process) 435.12 217.67 P
0.58 ([W) 108 204.67 P
0.58 (elch88].\051 An I/O handle is similar to a UNIX inode, but also includes information such as the) 121.15 204.67 P
0.27 (number of open references \050) 108 191.67 P
2 F
0.27 (str) 232.94 191.67 P
0.27 (eams) 244.14 191.67 P
1 F
0.27 (\051 that the client has for an object, and whether the streams are) 266.71 191.67 P
0.04 (open for reading or writing. For \336les, it includes other cache state information such as whether the) 108 178.67 P
0.65 (client has cached pages from the \336le. Some \336le I/O handles reference directories, because Sprite) 108 165.67 P
1.01 (implements directories as uncacheable \336les. An object does not have to be open to have an I/O) 108 152.67 P
-0.22 (handle. For instance, clients will have \336le I/O handles for \336les they have closed, but for which they) 108 139.67 P
(still have cached pages.) 108 126.67 T
0.04 (Finally) 118.8 101.67 P
0.04 (, clients recover their streams \050sometimes called stream handles\051. These are the open ref-) 149.22 101.67 P
-0.19 (erences to objects in the \336le system and are similar to UNIX open \336le table entries. A stream keeps) 108 88.67 P
FMENDPAGE
%%EndPage: "36" 48
%%Page: "37" 48
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(37) 282 55 T
1 11 Q
0.47 (state information about the open reference, such as the of) 72 712.67 P
0.47 (fset into a \336le for the next read or write) 327.41 712.67 P
1.87 (operation. Each stream also points to a corresponding I/O handle for the object it references.) 72 699.67 P
-0.07 (Streams are reopened last, because the server must already have information about the I/O handles) 72 686.67 P
(referenced by the streams.) 72 673.67 T
0.39 (T) 82.8 648.67 P
0.39 (o recover a pre\336x, I/O handle, or stream, a client) 88.74 648.67 P
2 F
0.39 (r) 308.99 648.67 P
0.39 (eopens) 312.86 648.67 P
1 F
0.39 ( the object by issuing an RPC to the) 343.37 648.67 P
0.78 (\336le server) 72 635.67 P
0.78 (. The reopen RPC contains information the server needs to generate its own set of I/O) 115.8 635.67 P
(handles and streams.These I/O handles and streams form the server) 72 622.67 T
(\325) 368.36 622.67 T
(s distributed \336le system state.) 371.41 622.67 T
0.78 (Figure 3-1 and Figure 3-2 illustrate the client recovery process for \336les. Figure 3-1 shows the) 82.8 157.68 P
0.41 (clients sending the server their recovery information, and Figure 3-2 shows the server once again) 72 144.68 P
-0.11 (in normal operation, with its distributed cache state complete. A client indicates that it has \336nished) 72 131.68 P
(reopening its \336le system state by sending a \336nal) 72 118.68 T
2 F
(end r) 285.31 118.68 T
(ecovery) 307.79 118.68 T
1 F
( RPC to the server) 341.95 118.68 T
(.) 421.9 118.68 T
(Figure 3-1. Client-driven recovery in Sprite.) 190.82 295.68 T
1 10 Q
1.29 (This \336gure illustrates how the Sprite clients refresh the server) 108 273.35 P
1.29 (\325) 366.16 273.35 P
1.29 (s distributed cache state) 368.93 273.35 P
2.07 (information after a server failure. After a crash, the server has lost this information,) 108 262.35 P
0.68 (because the information was stored in its main memory) 108 251.35 P
0.68 (. However) 334.29 251.35 P
0.68 (, each client has infor-) 376.2 251.35 P
-0.17 (mation about which \336les it has open or cached. The clients reopen these \336les on the server) 108 240.35 P
-0.17 (,) 465.5 240.35 P
0.46 (and the server uses the information in the reopen requests to rebuild its distributed cache) 108 229.35 P
72 197.02 504 215.02 C
72 197.02 504 215.02 R
7 X
0 K
V
72 206.02 504 206.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(state.) 108 218.35 T
72 321.02 504 601 C
72 321.02 504 589 C
227 501.16 293.82 448 301.25 455.59 234.43 508.75 4 Y
2 X
0 K
V
7 X
90 450 45.38 45.88 220.62 518.12 G
1 H
0 Z
0 X
90 450 45.38 45.88 220.62 518.12 A
189 485.83 252.71 523 R
4 X
V
0.5 H
0 X
N
358.25 476 365 498 R
2 X
V
311.83 354 414.77 408 R
4 X
V
0 X
N
248.09 383.62 281.84 390.38 R
2 X
V
1 H
0 X
90 450 67.9 70.5 364.9 400.5 A
0 14 Q
(arson) 197.82 414.88 T
(allspice) 341.29 453.45 T
311.83 354 414.77 430.23 R
0.5 H
N
0 10 Q
(distributed cache state) 314.78 419.3 T
299.5 464 286 443.75 313 443.75 3 Y
2 X
V
276.84 401 297.09 387.5 276.84 374 3 Y
V
354 485.5 362.12 468 370.25 485.5 3 Y
V
0 12 Q
0 X
(r) 142 456.52 T
(eopen handle for \336le A) 147.11 456.52 T
(r) 386.93 487.52 T
(eopen handle for) 392.04 487.52 T
(\336le B) 392.67 472.52 T
(r) 239 343.96 T
(eopen handles) 244.11 343.96 T
(for \336les B and C) 238.88 331.46 T
0 10 Q
(modi\336ed \336le A) 190.25 503.05 T
7 X
90 450 45.38 45.88 210.62 389.12 G
1 H
0 X
90 450 45.38 45.88 210.62 389.12 A
179 356.83 242.71 394 R
4 X
V
0.5 H
0 X
N
179 356.83 242.71 413.5 R
N
(\336le B) 182.25 379.55 T
(\336le cache) 191 401.3 T
(modi\336ed \336le C) 180.25 368.55 T
0 24 Q
(?) 354.8 376.54 T
0 14 Q
(arson) 193 420.5 T
189 485.83 252.71 542.5 R
N
0 10 Q
(\336le cache) 201 530.3 T
0 14 Q
(gluttony) 196 546.5 T
(arson) 348.82 563.88 T
7 X
90 450 45.38 45.88 361.62 538.13 G
1 H
0 X
90 450 45.38 45.88 361.62 538.13 A
330 505.83 393.71 543 R
4 X
V
0.5 H
0 X
N
330 505.83 393.71 562.5 R
N
0 10 Q
(\336le B) 333.25 528.55 T
(\336le cache) 342 550.3 T
0 14 Q
(murder) 338 567.5 T
(\050\336le server\051) 328 438 T
72 321.02 504 601 C
72 321.02 504 589 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "37" 49
%%Page: "38" 49
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(38) 318 55 T
1 11 Q
0.39 (T) 118.8 327.67 P
0.39 (able 3-1 shows the state information a client sends to the server in its reopen requests for dif-) 124.74 327.67 P
0.77 (ferent types of \336le system objects. In the context of this dissertation, the \336le I/O handles are the) 108 314.67 P
-0.2 (most important objects reopened, since they form the server) 108 301.67 P
-0.2 (\325) 370.14 301.67 P
-0.2 (s distributed cache state. Recovery for) 373.19 301.67 P
0.5 (the other types of I/O handles is straight-forward. The state sent to the server for \336le I/O handles) 108 288.67 P
-0.22 (includes \336ve things. The \336le ID is a unique identi\336er for the \336le object on disk. The pre\336x ID is the) 108 275.67 P
0.97 (\336le ID for the \336le system storing the \336le. The use structure gives the number of open reference) 108 262.67 P
0.28 (streams to the \336le, sometimes called) 108 249.67 P
2 F
0.28 (use counts) 271.69 249.67 P
1 F
0.28 ( or) 318.04 249.67 P
2 F
0.28 (r) 333.23 249.67 P
0.28 (efer) 337.1 249.67 P
0.28 (ence counts) 353.78 249.67 P
1 F
0.28 (. This includes a count of how) 405.61 249.67 P
0.94 (many references are for writing or executing the \336le. The \337ags \336eld indicates whether there are) 108 236.67 P
-0.1 (dirty blocks for the \336le in the client\325) 108 223.67 P
-0.1 (s cache. The version number of a \336le is updated every time the) 265.68 223.67 P
-0.18 (\336le is opened for writing. The server stores a copy of the version number on disk. During recovery) 108 210.67 P
-0.18 (,) 537.25 210.67 P
0.03 (the server compares the version number from the client to the one on its disk to detect whether the) 108 197.67 P
(\336le has changed. If so, the server can respond to the client telling it to invalidate its cached copy) 108 184.67 T
(.) 529.58 184.67 T
0 12 Q
(3.1.3. Restarting Hung Client Pr) 108 153 T
(ocesses) 273.35 153 T
1 11 Q
0.21 (After recovering its \336le system state with a failed \336le server) 118.8 127.67 P
0.21 (, a client executes its second recov-) 383.46 127.67 P
0.82 (ery step: awakening all processes that are hung waiting for an RPC to complete with the server) 108 114.67 P
0.82 (.) 537.25 114.67 P
1.18 (When a server crashes, all client RPCs in progress with the server will hang until the server is) 108 101.67 P
0.08 (again available. When the client detects that the server is again available, it recovers is state infor-) 108 88.67 P
(Figure 3-2. The system after recovery) 240 419.67 T
(.) 405.26 419.67 T
1 10 Q
0.86 (This \336gure shows the Sprite system after recovery) 144 397.33 P
0.86 (. It is now in normal operation again,) 350.04 397.33 P
108 365 540 383 C
108 365 540 383 R
7 X
0 K
V
108 374 540 374 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(because the server has reconstructed its distributed cache state.) 144 386.33 T
108 445 540 720 C
108 445 540 708 C
241 619.7 307.82 566.54 315.25 574.13 248.43 627.29 4 Y
2 X
0 K
V
7 X
90 450 45.38 45.88 234.62 636.66 G
1 H
0 Z
0 X
90 450 45.38 45.88 234.62 636.66 A
203 604.37 266.71 641.54 R
4 X
V
0.5 H
0 X
N
372.25 594.54 379 616.54 R
2 X
V
325.83 472.54 428.77 526.54 R
4 X
V
0 X
N
262.09 502.16 295.84 508.91 R
2 X
V
1 H
0 X
90 450 67.9 70.5 378.9 519.04 A
0 14 Q
(arson) 211.82 533.41 T
(allspice) 355.29 571.99 T
325.83 472.54 428.77 548.77 R
0.5 H
N
0 10 Q
(distributed cache state) 328.78 537.84 T
313.5 582.54 300 562.29 327 562.29 3 Y
2 X
V
290.84 519.54 311.09 506.04 290.84 492.54 3 Y
V
368 604.04 376.12 586.54 384.25 604.04 3 Y
V
0 12 Q
0 X
(r) 156 575.06 T
(equest to open \336le Q) 161.11 575.06 T
(r) 400.93 606.06 T
(equest to r) 406.04 606.06 T
(ead a new) 459.79 606.06 T
(page fr) 406.67 591.06 T
(om \336le B) 442.76 591.06 T
(r) 269.14 471 T
(equest to) 274.25 471 T
(close \336le B) 267.88 459 T
0 10 Q
(modi\336ed \336le A) 204.25 621.59 T
7 X
90 450 45.38 45.88 224.62 507.66 G
1 H
0 X
90 450 45.38 45.88 224.62 507.66 A
193 475.37 256.71 512.54 R
4 X
V
0.5 H
0 X
N
193 475.37 256.71 532.04 R
N
(\336le B) 196.25 498.09 T
(\336le cache) 205 519.84 T
(modi\336ed \336le C) 194.25 487.09 T
0 14 Q
(arson) 207 539.04 T
203 604.37 266.71 661.04 R
N
0 10 Q
(\336le cache) 215 648.84 T
0 14 Q
(gluttony) 210 665.04 T
(arson) 362.82 682.41 T
7 X
90 450 45.38 45.88 375.62 656.66 G
1 H
0 X
90 450 45.38 45.88 375.62 656.66 A
344 624.37 407.71 661.54 R
4 X
V
0.5 H
0 X
N
344 624.37 407.71 681.04 R
N
0 10 Q
(\336le B) 347.25 647.09 T
(\336le cache) 356 668.84 T
0 14 Q
(murder) 352 686.04 T
(\050\336le server\051) 342 556.54 T
0 10 Q
(gluttony:) 331 488 T
(modi\336ed \336le A) 361 478 T
(murder: \336le B) 329 517 T
(arson: modi\336ed \336le C) 329 506 T
(\336le B) 361 497 T
108 445 540 720 C
108 445 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "38" 50
%%Page: "39" 50
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(39) 282 55 T
1 11 Q
0.8 (mation and then wakes up its hung processes. The processes automatically resend their RPCs to) 72 281.67 P
(the server) 72 268.67 T
(.) 114.41 268.67 T
0 12 Q
(3.1.4. File System State Recovery on the Server) 72 237 T
1 11 Q
0.72 (So far this chapter has described the client side of state recovery; we now look at the server) 82.8 211.67 P
0.72 (\325) 496.67 211.67 P
0.72 (s) 499.73 211.67 P
-0.25 (side. Its two basic activities are processing the cache state sent to it by clients and retrieving further) 72 198.67 P
(information from disk.) 72 185.67 T
0.3 (T) 82.8 160.67 P
0.3 (o regenerate most of its \336le system state, the server processes the state information it receives) 88.74 160.67 P
0.37 (from clients. When the server reboots, it turns on its RPC service and is then available for clients) 72 147.67 P
0.41 (to send it their state. For each I/O handle that a client reopens, the server creates a corresponding) 72 134.67 P
0.34 (I/O handle that records the client\325) 72 121.67 P
0.34 (s use of a \336le or other object. Likewise, for each stream a client) 221.06 121.67 P
0.16 (reopens, the server creates a corresponding stream that records the client\325) 72 108.67 P
0.16 (s open reference to a \336le) 395.5 108.67 P
(system object.) 72 95.67 T
72 81 504 720 C
72 289 504 720 C
72.99 292 503.99 712 R
7 X
0 K
V
1 10 Q
0 X
(T) 125.78 672.33 T
(ype) 131.19 672.33 T
(State information) 213.38 672.33 T
(Purpose) 384.91 672.33 T
(Pre\336x) 80.97 654.33 T
(pre\336x name) 198.43 654.33 T
(Server checks if it still services this domain) 306.01 654.33 T
(File I/O handle) 80.97 636.33 T
(\336le ID) 198.43 636.33 T
(pre\336x ID) 198.43 620.33 T
(use) 198.43 604.33 T
(\337ags) 198.43 588.33 T
(version number) 198.43 572.33 T
(Unique ID for \336le) 306.01 636.33 T
(Unique ID for \336le system) 306.01 620.33 T
(Number of read/write/execute references) 306.01 604.33 T
(Whether there are cached dirty blocks) 306.01 588.33 T
(Identi\336es version of the \336le) 306.01 572.33 T
(Device I/O handle) 80.97 554.33 T
(\336le ID) 198.43 554.33 T
(use) 198.43 538.33 T
(Unique ID for device object in \336le system) 306.01 554.33 T
(Number of read/write/execute references) 306.01 538.33 T
(Pipe I/O handle) 80.97 520.33 T
(\336le ID) 198.43 520.33 T
(use) 198.43 504.33 T
(Unique ID for pipe) 306.01 520.33 T
(Number of read/write references) 306.01 504.33 T
(Pseudo-device I/O handle) 80.97 486.33 T
(\336le ID) 198.43 486.33 T
(server ID) 198.43 470.33 T
(seed) 198.43 454.33 T
(Unique ID of control handle) 306.01 486.33 T
(ID of host running the pseudo-device code) 306.01 470.33 T
(Used to create the unique \336le ID) 306.01 454.33 T
(Stream) 80.97 436.33 T
(stream ID) 198.43 436.33 T
(I/O handle ID) 198.43 420.33 T
(\337ags) 198.43 404.33 T
(of) 198.43 388.33 T
(fset) 206.58 388.33 T
(Unique ID for stream) 306.01 436.33 T
(\336le ID of I/O handle stream references) 306.01 420.33 T
(Flags passed from open request) 306.01 404.33 T
(File access position for stream) 306.01 388.33 T
1 11 Q
(T) 130.73 363.67 T
(able 3-1. State information sent from clients to the server for recovery) 136.67 363.67 T
(.) 443.51 363.67 T
1 10 Q
0.6 (For each type of handle, this table gives the information sent by clients to the server for) 108.99 339.33 P
1.84 (crash recovery) 108.99 328.33 P
1.84 (. Important \336elds are described in the text. Pseudo-devices are devices) 168.73 328.33 P
72.99 296 503.99 314 C
72.99 296 503.99 314 R
7 X
0 K
V
72.99 305 504.99 305 2 L
V
0.5 H
2 Z
0 X
N
72 289 504 720 C
1 10 Q
0 X
0 K
(implemented by user) 108.99 317.33 T
(-level processes. Please see [W) 192.62 317.33 T
(elch88] for further details.) 316.44 317.33 T
76.97 682 76.97 382 2 L
V
2 H
0 Z
N
194.43 684 194.43 380 2 L
V
N
302.01 684 302.01 380 2 L
V
0.5 H
N
500.01 682 500.01 382 2 L
V
2 H
N
75.97 683 501.01 683 2 L
V
N
77.97 666.25 499.01 666.25 2 L
V
0.5 H
N
77.97 663.75 499.01 663.75 2 L
V
N
75.97 647 501.01 647 2 L
V
N
75.97 565 501.01 565 2 L
V
N
75.97 531 501.01 531 2 L
V
N
75.97 497 501.01 497 2 L
V
N
75.97 447 501.01 447 2 L
V
N
75.97 381 501.01 381 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "39" 51
%%Page: "40" 51
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(40) 318 55 T
1 11 Q
-0.11 (In particular) 118.8 712.67 P
-0.11 (, the purpose of the server) 172.25 712.67 P
-0.11 (\325) 286.2 712.67 P
-0.11 (s \336le I/O handles is to maintain cache consistency among) 289.26 712.67 P
0.77 (the clients. The server must know which clients have open references or cached dirty blocks for) 108 699.67 P
0.04 (\336les. During recovery) 108 686.67 P
0.04 (, the server builds a client list for every \336le that is reopened. The server adds) 203.47 686.67 P
(to this list each client that indicates it has an open reference or cached blocks for the \336le.) 108 673.67 T
0.29 (Although the server receives its cache state information from the clients, it also needs informa-) 118.8 648.67 P
-0 (tion from the) 108 635.67 P
2 F
-0 (\336le descriptor) 168.11 635.67 P
1 F
-0 ( for each reopened I/O handle. The \336le descriptor includes an objects\325) 229.44 635.67 P
-0 (s) 535.73 635.67 P
0.24 (last access and modify times, size, access permissions, and other data that the server needs before) 108 622.67 P
-0.08 (clients can access the object. Clients do not send descriptor information to the server) 108 609.67 P
-0.08 (, because they) 478.22 609.67 P
0.24 (do not necessarily have the most recent copy of it. The descriptors are stored on the server) 108 596.67 P
0.24 (\325) 508.62 596.67 P
0.24 (s disk.) 511.68 596.67 P
1.32 (The server also caches copies of these \336le descriptors in main memory) 108 583.67 P
1.32 (, to avoid going to disk) 432.08 583.67 P
1.01 (every time it refers to a descriptor) 108 570.67 P
1.01 (. During recovery the server reads the \336le descriptor for each) 262.35 570.67 P
0.12 (reopened I/O handle from disk into memory) 108 557.67 P
0.12 (. If more than one client reopens the object, the server) 302.06 557.67 P
(only performs the disk read for the \336rst client and uses the cached descriptor thereafter) 108 544.67 T
(.) 488.16 544.67 T
0.58 (Fortunately) 118.8 519.67 P
0.58 (, the server can overlap these disk I/O operations with the processing necessary for) 168.74 519.67 P
0.58 (reopening other handles. The server is able to do this because reopen requests from dif) 108 506.67 P
0.58 (ferent cli-) 496.41 506.67 P
0.5 (ents can be handled by dif) 108 493.67 P
0.5 (ferent RPC server processes. When one RPC server process blocks for) 225.32 493.67 P
(I/O, another can perform the processing necessary for its reopen request.) 108 480.67 T
0 14 Q
(3.2. Client Cache and File System State) 108 447.67 T
1 11 Q
0.5 (This section gives more detail about the cache and \336le system state maintained by clients. The) 118.8 421.67 P
0.47 (type and amount of state information determines the amount of work performed during recovery) 108 408.67 P
0.47 (.) 537.25 408.67 P
-0.24 (Understanding what is recovered enables us to create realistic recovery benchmarks. In this section) 108 395.67 P
0.25 (I show three things. First, \336le I/O handles and streams to \336les account for most of the client state.) 108 382.67 P
0.69 (Second, the clients only need to tell the server about a small part of their state. Third, the server) 108 369.67 P
0.21 (does not need to perform descriptor reads for all of the \336le I/O handles reopened, because about a) 108 356.67 P
0.28 (third of the \336le handles are to \336les shared on more than one client. The measurements in this sec-) 108 343.67 P
1.18 (tion were made on Sprite\325) 108 330.67 P
1.18 (s main Sun-4/280 \336le server) 226.22 330.67 P
1.18 (. The data was gathered on four separate) 354.21 330.67 P
0.91 (days, spanning a month, across all available Sprite clients, for a total of 50 state measurements,) 108 317.67 P
(each of a single client.) 108 304.67 T
-0.02 ( T) 118.8 279.67 P
-0.02 (able 3-2 demonstrates that \336le I/O handles and streams to \336les together are responsible for the) 127.47 279.67 P
0.91 (majority of state to recover) 108 266.67 P
0.91 (. The table shows the average number of \336le I/O handles, streams to) 230.04 266.67 P
0.64 (\336les, and other \336le system objects served by Sprite\325) 108 253.67 P
0.64 (s main \336le server per client. File I/O handles) 339.27 253.67 P
0.91 (and streams to \336les constitute about 97% of all handles. For this reason, the benchmarks in this) 108 240.67 P
(thesis use only I/O handles and streams for \336les.) 108 227.67 T
-0.13 (T) 118.8 202.67 P
-0.13 (able 3-3 shows that clients only need to reopen a small part of their total state information. The) 124.74 202.67 P
0.12 (table gives the average number of \336les per client that are neither open nor have dirty cache blocks) 108 189.67 P
-0.17 (to write back to the server) 108 176.67 P
-0.17 (. A client does not need to recover these \336les. Eighty-eight percent of \336le) 220.95 176.67 P
0.07 (I/O handles fall into this category) 108 163.67 P
0.07 (, thus a client only needs to reopen about 12% of its \336le I/O han-) 255 163.67 P
1.22 (dles. Counting streams and other I/O handles as well, this means a client only needs to reopen) 108 150.67 P
(about one quarter of the state it maintains.) 108 137.67 T
0.45 (T) 118.8 112.67 P
0.45 (able 3-3 also shows the number of \336les per client with dirty cache blocks. In any given snap-) 124.74 112.67 P
0.06 (shot of client state, a client is unlikely to have dirty blocks for many \336les in its cache. On average,) 108 99.67 P
0.26 (there are no dirty \336les per client. This information is useful for constructing realistic benchmarks.) 108 86.67 P
FMENDPAGE
%%EndPage: "40" 52
%%Page: "41" 52
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(41) 282 55 T
1 11 Q
0.58 (However) 72 189.66 P
0.58 (, if a server is down for a long time, more clients will accumulate dirty blocks that they) 111.82 189.66 P
(need to write back to the server) 72 176.66 T
(.) 209.3 176.66 T
0.39 (Note that it is not necessary for a client to reopen \336les that are closed, but for which it still has) 82.8 151.66 P
0.5 (clean cached blocks. The last entry in T) 72 138.66 P
0.5 (able 3-3 shows the number of \336les per client in this cate-) 249.23 138.66 P
0.76 (gory) 72 125.66 P
0.76 (. The server does not need to know about these \336les to maintain cache consistency) 91.42 125.66 P
0.76 (, because) 462.97 125.66 P
0.19 (the client will \336nd out of its own accord the next time it opens such a \336le whether or not its cache) 72 112.66 P
0.66 (blocks are still valid. It does so by comparing the new \336le version number against the one it has) 72 99.66 P
0.22 (saved in the \336le I/O handle. But to save the \336le\325) 72 86.66 P
0.22 (s version number) 283.87 86.66 P
0.22 (, the client must keep around the) 359.55 86.66 P
72 81 504 720 C
73.12 489.99 502.88 720 C
73.12 496 500.62 715 R
7 X
0 K
V
1 10 Q
0 X
(Handle type) 149.12 687.33 T
(A) 248.88 687.33 T
(verage number per client) 255.35 687.33 T
(Percent of total) 384.86 687.33 T
(File I/O handles) 114.14 669.33 T
(636 \05068-2103\051) 305.74 669.33 T
1 11 Q
(85.5) 382 668.67 T
1 10 Q
(File streams) 114.14 650.33 T
(77 \05032-135\051) 315.73 650.33 T
1 11 Q
(10.3) 382 649.67 T
1 10 Q
(Other handles and streams) 114.14 631.33 T
(31 \05014-80\051) 320.73 631.33 T
1 11 Q
(4.2) 382 630.67 T
1 10 Q
(T) 114.14 612.33 T
(otal) 119.55 612.33 T
(744) 348.2 612.33 T
1 11 Q
(100.0) 382 611.67 T
(T) 176.63 586.67 T
(able 3-2. Amount of state information on clients.) 182.58 586.67 T
1 10 Q
1.82 (This table shows the average number of handles and streams referencing objects on) 109.12 562.33 P
0.47 (Sprite\325) 109.12 551.33 P
0.47 (s main Sun-4/280 \336le server for each client. The data was gathered on four sepa-) 135.77 551.33 P
-0.18 (rate days spanning a month across all available workstations, excluding the server) 109.12 540.33 P
-0.18 (, giving) 434.25 540.33 P
-0.01 (50 measurements, each of a single client. Numbers in parentheses give the minimum and) 109.12 529.33 P
73.12 497 500.62 515 C
73.12 497 500.62 515 R
7 X
0 K
V
73.12 506 505.12 506 2 L
V
0.5 H
2 Z
0 X
N
73.12 489.99 502.88 720 C
1 10 Q
0 X
0 K
(maximum values recorded.) 109.12 518.33 T
110.14 697 110.14 605 2 L
V
2 H
0 Z
N
236.66 699 236.66 603 2 L
V
N
367.2 699 367.2 603 2 L
V
0.5 H
N
463.59 697 463.59 605 2 L
V
2 H
N
109.14 698 464.59 698 2 L
V
N
111.14 681.25 462.59 681.25 2 L
V
0.5 H
N
111.14 678.75 462.59 678.75 2 L
V
N
109.14 661 464.59 661 2 L
V
N
109.14 642 464.59 642 2 L
V
N
111.14 624.25 462.59 624.25 2 L
V
N
111.14 621.75 462.59 621.75 2 L
V
N
109.14 604 464.59 604 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
72 81 504 720 C
73.01 196.99 502.99 489.99 C
73.01 207.99 500.51 485.99 R
7 X
0 K
V
1 11 Q
0 X
(T) 171.49 333.66 T
(able 3-3. Status of \336le I/O handles on Sprite clients) 177.43 333.66 T
1 10 Q
0.58 (This table gives the status of the \336le I/O handles on clients referencing \336les on Sprite\325) 109.01 309.33 P
0.58 (s) 460.62 309.33 P
0.43 (main Sun-4/280 \336le server) 109.01 298.33 P
0.43 (. The \336rst category shows \336les that are neither open nor have) 216.07 298.33 P
0.39 (dirty cached blocks on the client. The second category shows \336le I/O handles for which) 109.01 287.33 P
-0.21 (the client does have dirty cache blocks. The last category shows closed \336les for which the) 109.01 276.33 P
0.59 (client has clean cached blocks. Eliminating the recovery of the \336rst category of \336le I/O) 109.01 265.33 P
1.34 (handles reduces the number of \336le I/O handles recovered by 88%, and the total state) 109.01 254.33 P
0.47 (recovered by more than three-quarters. Numbers in parentheses show the minimum and) 109.01 243.33 P
73.01 210.99 500.51 228.99 C
73.01 210.99 500.51 228.99 R
7 X
0 K
V
73.01 219.99 505.01 219.99 2 L
V
0.5 H
2 Z
0 X
N
73.01 196.99 502.99 489.99 C
1 10 Q
0 X
0 K
(maximum values recorded.) 109.01 232.33 T
(Status of \336le I/O handle) 93.21 458.33 T
(A) 202.33 458.33 T
(verage number) 208.81 458.33 T
(Percent of \336le I/O handles) 281.39 458.33 T
(Percent of total state) 399.59 458.33 T
(Unopen \336le I/O handles) 89.64 440.33 T
(with no dirty blocks) 89.64 428.33 T
(560 \05036-1968\051) 213.06 440.33 T
(88.0) 371.69 440.33 T
(75.3) 466.39 440.33 T
(File I/O handles with) 89.64 410.33 T
(dirty blocks) 89.64 398.33 T
(0 \0500-2\051) 243.05 410.33 T
(0.0) 376.69 410.33 T
(0.0) 471.39 410.33 T
(Unopen \336le I/O handles) 89.64 380.33 T
(with clean blocks) 89.64 368.33 T
(362 \0506-1702\051) 218.06 380.33 T
(57.0) 371.69 380.33 T
(48.7) 466.39 380.33 T
85.64 467.99 85.64 361.99 2 L
V
2 H
0 Z
N
196.29 469.99 196.29 359.99 2 L
V
N
274.52 469.99 274.52 359.99 2 L
V
0.5 H
N
393.18 469.99 393.18 359.99 2 L
V
N
487.88 467.99 487.88 361.99 2 L
V
2 H
N
84.64 468.99 488.88 468.99 2 L
V
N
86.64 452.24 486.88 452.24 2 L
V
0.5 H
N
86.64 449.74 486.88 449.74 2 L
V
N
84.64 420.99 488.88 420.99 2 L
V
N
84.64 390.99 488.88 390.99 2 L
V
N
84.64 360.99 488.88 360.99 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "41" 53
%%Page: "42" 53
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(42) 318 55 T
1 11 Q
0.74 (\336le I/O handle, even if the \336le is closed. The client can only garbage collect \336le I/O handles for) 108 466.67 P
(\336les that are closed and have no blocks left in the cache.) 108 453.67 T
0.84 (There is one other factor that determines how much work is performed during \336le I/O handle) 118.8 428.67 P
-0.03 (recovery) 108 415.67 P
-0.03 (, and that is the degree of \336le sharing between clients. The server performs setup work for) 145.72 415.67 P
-0 (a \336le the \336rst time it is reopened, and it can skip this work when other clients reopen the same \336le.) 108 402.67 P
-0.25 (Reading a handle\325) 108 389.67 P
-0.25 (s \336le descriptor is the most costly example of such setup work. T) 186.84 389.67 P
-0.25 (able 3-4 lists the) 468.42 389.67 P
0.05 (amount of \336le sharing \050both read- and write-sharing\051 amongst clients for \336les on Sprite\325) 108 376.67 P
0.05 (s main \336le) 494.11 376.67 P
0.78 (server) 108 363.67 P
0.78 (. Over a third of references to open \336les are to \336les that are shared by another client. This) 134.24 363.67 P
0.55 (means that the server will not need to perform a descriptor read for at least a third of the \336le I/O) 108 350.67 P
(handles it reopens.) 108 337.67 T
0.47 (The table also includes this information for \336les that are not currently open on a client, but for) 118.8 312.67 P
0.12 (which the client still has handles because it referenced the \336les in the past. \050The \336les may be open) 108 299.67 P
0.71 (on other clients, however) 108 286.67 P
0.71 (.\051 Over 40% of these unopen references are to \336les referenced by more) 220.59 286.67 P
0.29 (than one client. I include this information for use with later measurements; as explained later) 108 273.67 P
0.29 (, cli-) 519.57 273.67 P
(ents in the past recovered even these unopen handles.) 108 260.67 T
0 14 Q
(3.3. Measur) 108 227.67 T
(ement Setup) 178.09 227.67 T
1 11 Q
0.62 (This section describes the test environments and methodology used for the measurements pre-) 118.8 201.67 P
0.26 (sented in this and the following chapters. There are three setups, because Sprite has changed over) 108 188.67 P
0.56 (time, and some earlier measurements cannot be reproduced easily on the current Sprite system. I) 108 175.67 P
(call the setups) 108 162.67 T
2 F
(old Sun-3) 172.99 162.67 T
1 F
(,) 215.41 162.67 T
2 F
(pr) 220.91 162.67 T
(oduction system) 230.27 162.67 T
1 F
(, and) 300.76 162.67 T
2 F
(testbed) 324.86 162.67 T
1 F
(.) 355.98 162.67 T
0.15 (Several of the measurements in this chapter are from an old Sun-3 setup. This was a past Sprite) 118.8 137.67 P
0.93 (system that used a Sun-3 with about \336ve gigabytes of disk space for the main \336le server) 108 124.67 P
0.93 (. There) 507.96 124.67 P
(were about 40 clients consisting of Sun-3 and DECstation 3100 workstations.) 108 111.67 T
108 81 540 720 C
109.01 474 538.99 720 C
109.01 485.5 536.51 720 R
7 X
0 K
V
1 11 Q
0 X
(T) 225.34 607.67 T
(able 3-4. Amount of \336le sharing on clients.) 231.29 607.67 T
1 10 Q
1.12 (This table shows the amount of \336le sharing amongst the clients of Sprite\325) 145.01 583.33 P
1.12 (s main Sun-) 450.51 583.33 P
0.08 (4/280 \336le server) 145.01 572.33 P
0.08 (. This includes \336les that are shared for reading or for writing.) 209.57 572.33 P
2 F
0.08 (Refer) 457.03 572.33 P
0.08 (ences) 478.31 572.33 P
0.73 (to open shar) 145.01 561.33 P
0.73 (ed \336les) 196.07 561.33 P
1 F
0.73 ( gives the percentage of \336le streams for \336les that are open on more) 224.84 561.33 P
0.01 (than one client.) 145.01 550.33 P
2 F
0.01 (Refer) 208.88 550.33 P
0.01 (ences to unopen shar) 230.16 550.33 P
0.01 (ed \336les) 314.47 550.33 P
1 F
0.01 ( gives the percentage of unopen \336le I/O) 342.52 550.33 P
-0 (handles on a client that are referenced by more than one client. The data was gathered on) 145.01 539.33 P
1.18 (four separate days, spanning a month, across all available workstations, excluding the) 145.01 528.33 P
0.18 (server) 145.01 517.33 P
0.18 (. The percentage is an average across all the days\325 data. The last two columns pro-) 168.88 517.33 P
(Category) 186.39 680.33 T
(References \050%\051) 297.94 680.33 T
(Minimum \050%\051) 383.51 680.33 T
(Maximum \050%\051) 452.04 680.33 T
(References to open shared \336les) 133.23 662.33 T
1 11 Q
(37.1) 295 661.67 T
(35.0) 392.36 661.67 T
(56.0) 461.73 661.67 T
1 10 Q
(References to unopen shared \336les) 133.23 643.33 T
1 11 Q
(44.4) 295 642.67 T
(33.2) 392.36 642.67 T
(51.9) 461.73 642.67 T
129.23 690 129.23 636 2 L
V
2 H
0 Z
N
280.2 692 280.2 634 2 L
V
N
377.56 692 377.56 634 2 L
V
0.5 H
N
446.92 692 446.92 634 2 L
V
N
516.29 690 516.29 636 2 L
V
2 H
N
128.23 691 517.29 691 2 L
V
N
130.23 674.25 515.29 674.25 2 L
V
0.5 H
N
130.23 671.75 515.29 671.75 2 L
V
N
128.23 654 517.29 654 2 L
V
N
128.23 635 517.29 635 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "42" 54
%%Page: "43" 54
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(43) 282 55 T
1 11 Q
-0.11 (The production system setup is an updated Sprite system. In this system, both the server and cli-) 82.8 712.67 P
0.04 (ents have been replaced with faster processors. The server is a Sun-4/280 with about six gigabytes) 72 699.67 P
-0.19 (of disk space. The clients consist of SP) 72 686.67 P
-0.19 (ARCstation-1\325) 241.15 686.67 P
-0.19 (s, SP) 305.25 686.67 P
-0.19 (ARCstation-2\325) 326.03 686.67 P
-0.19 (s, and DECstation 5000\325) 390.13 686.67 P
-0.19 (s.) 496.98 686.67 P
0.24 (Although the system now has only about 20 clients, most of the measurements in this dissertation) 72 673.67 P
0.19 (were taken when the production system had 40 clients. As necessary) 72 660.67 P
0.19 (, I indicate the number of cli-) 374.38 660.67 P
0.75 (ents with the measurement results. The previous measurements of per) 72 647.67 P
0.75 (-client state information in) 384.88 647.67 P
(this chapter and a few measurements in later chapters are from this setup.) 72 634.67 T
1.28 (Most of the measurements in this thesis are from a testbed with its own server) 82.8 609.67 P
1.28 (. This testbed) 442.53 609.67 P
0.23 (makes recovery experiments much less painful for our users, since my experiments require crash-) 72 596.67 P
0.3 (ing and rebooting a server) 72 583.67 P
0.3 (. Also, I can control the resources on the server and the state on the cli-) 187.33 583.67 P
2.08 (ents, so the testbed provides a much more controlled measurement environment. The testbed) 72 570.67 P
0.92 (includes a SP) 72 557.67 P
0.92 (ARCstation-2 \336le server \05040 megahertz, 20 integer SPECmarks\051 with a WREN IV) 132.03 557.67 P
-0.02 (disk \05029.5 millisecond average access delay) 72 544.67 P
-0.02 (, 1.3 Megabyte/second maximum transfer rate\051 and ten) 263.4 544.67 P
0.55 (clients consisting of SP) 72 531.67 P
0.55 (ARCstation-1\325) 175.5 531.67 P
0.55 (s, SP) 239.59 531.67 P
0.55 (ARCstation-2\325) 261.12 531.67 P
0.55 (s and DECstation 5000\325) 325.21 531.67 P
0.55 (s. The testbed is) 431.55 531.67 P
0.28 (actually a part of the production Sprite system, because all the hosts are on the same network and) 72 518.67 P
0.26 (use the root \336le server from the production system. But for experiments using the testbed, the cli-) 72 505.67 P
(ents only recover state from the testbed server) 72 492.67 T
(, because it is the only server I rebooted.) 273.84 492.67 T
0.07 (Most of the measurements from the testbed system, including those in later chapters, use what I) 82.8 467.67 P
1.47 (call the) 72 454.67 P
2 F
1.47 (basic) 109.71 454.67 P
1 F
1.47 ( state setup. When measurements in the testbed use a variation of the basic state) 132.9 454.67 P
0.5 (setup, I describe the dif) 72 441.67 P
0.5 (ferences explicitly) 176.6 441.67 P
0.5 (. T) 257.23 441.67 P
0.5 (able 3-5 gives more detail about the \336le system state) 269.16 441.67 P
0.23 (for this setup. I chose the number and types of streams and \336le handles, and the degree of sharing) 72 428.67 P
-0.02 (and other \336le system activities, with the following goals in mind. The setup should be easy to con-) 72 415.67 P
0.14 (trol, realistic, and at least as aggressive per client as the averages reported in T) 72 402.67 P
0.14 (able 3-2, T) 418 402.67 P
0.14 (able 3-3,) 465.42 402.67 P
0.17 (and T) 72 389.67 P
0.17 (able 3-4. Each client has state for 790 \336le I/O handles. Ninety of the \336les are open, and one-) 96.72 389.67 P
1.58 (third of these open \336le references are to \336les shared by other clients. The rest of the \336les are) 72 376.67 P
0.57 (unopened and have no dirty cache blocks that need to be recovered. Of these unopen \336les, about) 72 363.67 P
0.12 (40% are \336le I/O handles also shared by another client. In addition, two clients each have the same) 72 350.67 P
0.12 (\336le open for writing. The clients truncate and rewrite the \336le every two seconds. This helps to test) 72 337.67 P
0.23 (for cache inconsistencies during recovery) 72 324.67 P
0.23 (. T) 254.63 324.67 P
0.23 (o simulate the on-going activity of \336le system clients,) 266.29 324.67 P
0.61 (one client repeatedly creates and unlinks a \336le every second. The create and unlink requests will) 72 311.67 P
0.81 (hang when the server fails, but will start up again as soon as the client recovers with the server) 72 298.67 P
0.81 (.) 501.25 298.67 P
1 (Finally) 72 285.67 P
1 (, all the clients have an I/O handle for the pre\336x of the \336le system served by the testbed) 102.42 285.67 P
(server) 72 272.67 T
(.) 98.24 272.67 T
0.18 (For most of the timings in this thesis, I provide only \336ve or six data points. There are three rea-) 82.8 247.67 P
0.06 (sons why this is a suf) 72 234.67 P
0.06 (\336cient number of tests. First, the variation in the results is small \320 only a few) 165.82 234.67 P
0.68 (percent. Second, I am not measuring truly random processes. The experiments are controlled, so) 72 221.67 P
0.76 (that the results should be the same for each repeated experiment, within some positive perturba-) 72 208.67 P
0.59 (tion. The error in the results is always positive, because the tests cannot run any faster than their) 72 195.67 P
0.64 (minimum value. By averaging the results of the tests, I report how long one should expect crash) 72 182.67 P
1.04 (recovery to take, and not the minimum amount of time it could possibly take. Third, I measure) 72 169.67 P
0.22 (how the results scale with dif) 72 156.67 P
0.22 (ferent numbers of clients and dif) 201.37 156.67 P
0.22 (ferent amounts of state information.) 345.37 156.67 P
-0.04 (This means that the \336ve or six data points from each experiment are actually a part of a continuum) 72 143.67 P
(of other data points that support the results.) 72 130.67 T
FMENDPAGE
%%EndPage: "43" 55
%%Page: "44" 55
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(44) 318 55 T
0 14 Q
(3.4. Sour) 108 319.67 T
(ces of and Solutions to File Server Contention) 161 319.67 T
1 11 Q
1.53 (This section now turns to problems with client-driven recovery and some solutions to those) 118.8 293.67 P
0.26 (problems. Recovery is one of the most stressful of a system\325) 108 280.67 P
0.26 (s activities. It places a very high load) 375.21 280.67 P
1.29 (on the system and often requires executing special-purpose code that is never exercised during) 108 267.67 P
0.93 (normal system operation. It is hardly surprising then that many system bugs, design limitations,) 108 254.67 P
(and other \337aws are likely to be discovered during crash recovery) 108 241.67 T
(.) 391.63 241.67 T
1.54 (There are three general problems for client-driven recovery: contention for resources on the) 118.8 216.67 P
0.81 (server) 108 203.67 P
0.81 (, cache consistency violations, and limited recovery speed. This chapter includes solutions) 134.4 203.67 P
1.73 (for the contention problems and several recovery protocol optimizations. These improvements) 108 190.67 P
-0.09 (reduce recovery times from as much as ten to \336fteen minutes, to about 20 to 30 seconds. However) 108 177.67 P
-0.09 (,) 537.25 177.67 P
0.25 (\336xing the cache consistency violations and further improving recovery speed require switching to) 108 164.67 P
(server) 108 151.67 T
(-driven or transparent recovery) 134.62 151.67 T
(, the subjects of following chapters.) 270.27 151.67 T
108 81 540 720 C
108 329 540 720 C
106.99 339.5 538.99 720 R
7 X
0 K
V
1 11 Q
0 X
(T) 223.91 429.67 T
(able 3-5. Basic testbed recovery state setup.) 229.85 429.67 T
1 10 Q
1.3 (This table shows the per) 142.99 405.33 P
1.3 (-client experimental setup for the basic testbed measurements.) 245.16 405.33 P
1.11 (The \336rst column indicates a category of state. The second column gives the amount of) 142.99 394.33 P
0.65 (state in that category per client. The third column indicates if any single client has extra) 142.99 383.33 P
0.07 (state in that category) 142.99 372.33 P
0.07 (. The last column indicates if two clients have extra state in that cate-) 225.56 372.33 P
108 340 538.99 358 C
106.99 340 538.99 358 R
7 X
0 K
V
106.99 349 538.99 349 2 L
V
0.5 H
2 Z
0 X
N
108 329 540 720 C
1 10 Q
0 X
0 K
(gory) 142.99 361.33 T
(.) 160.66 361.33 T
(Handle State) 165.74 680.33 T
(For each client) 265.3 680.33 T
-0.32 (Additional for one) 347.21 680.33 P
(client) 373.02 668.33 T
-0.41 (Additional for two) 431.83 680.33 P
(clients) 455.98 668.33 T
(Unshared unopen \336le I/O) 138.5 650.33 T
(handles) 138.5 638.33 T
(420) 322.68 650.33 T
(0) 417.58 650.33 T
(0) 502.49 650.33 T
(Shared unopen \336le I/O) 138.5 620.33 T
(handles) 138.5 608.33 T
(280) 322.68 620.33 T
(0) 417.58 620.33 T
(0) 502.49 620.33 T
(Unshared \336le I/O handles) 138.5 590.33 T
(open for reading) 138.5 578.33 T
(60) 327.68 590.33 T
(0) 417.58 590.33 T
(0) 502.49 590.33 T
(Shared \336le I/O handles) 138.5 560.33 T
(open for reading) 138.5 548.33 T
(30) 327.68 560.33 T
(0) 417.58 560.33 T
(0) 502.49 560.33 T
(File I/O handles open for) 138.5 530.33 T
(writing \050shared\051) 138.5 518.33 T
(0) 332.67 530.33 T
(0) 417.58 530.33 T
(1) 502.49 530.33 T
-0.1 (Associated stream handles) 138.5 500.33 P
(90) 327.68 500.33 T
(0) 417.58 500.33 T
(1) 502.49 500.33 T
(Files created and unlinked) 138.5 482.33 T
(0) 332.67 482.33 T
(1) 417.58 482.33 T
(0) 502.49 482.33 T
(Pre\336x handle) 138.5 464.33 T
(1) 332.67 464.33 T
(0) 417.58 464.33 T
(0) 502.49 464.33 T
134.5 690 134.5 458 2 L
V
2 H
0 Z
N
248.32 692 248.32 456 2 L
V
N
341.67 692 341.67 456 2 L
V
0.5 H
N
426.58 692 426.58 456 2 L
V
N
511.48 690 511.48 458 2 L
V
2 H
N
133.5 691 512.48 691 2 L
V
N
135.5 662.25 510.48 662.25 2 L
V
0.5 H
N
135.5 659.75 510.48 659.75 2 L
V
N
133.5 631 512.48 631 2 L
V
N
133.5 601 512.48 601 2 L
V
N
133.5 571 512.48 571 2 L
V
N
133.5 541 512.48 541 2 L
V
N
133.5 511 512.48 511 2 L
V
N
133.5 493 512.48 493 2 L
V
N
133.5 475 512.48 475 2 L
V
N
133.5 457 512.48 457 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "44" 56
%%Page: "45" 56
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(45) 282 55 T
0 F
(3.4.1. Server Contention) 72 712 T
1 11 Q
0.58 (As the Sprite network grew from fewer than ten client workstations to more than 40, recovery) 82.8 686.67 P
1.22 (was the \336rst part of the system that ceased to work. The increased recovery load on the server) 72 673.67 P
-0.27 (exposed a \337aw in Sprite\325) 72 660.67 P
-0.27 (s RPC system: a lack of contention control that caused clients to re-initiate) 179.54 660.67 P
1.27 (recovery unnecessarily) 72 647.67 P
1.27 (. Congestion control is a problem during any period of high load, but in) 173.53 647.67 P
(Sprite it \336rst surfaced during client-driven recovery) 72 634.67 T
(. This section describes the problem.) 297.68 634.67 T
0.69 (The contention problem arose because the server has limited processing power and the clients) 82.8 609.67 P
0.88 (did not reduce their demands as the server became overloaded. As a result, the server could not) 72 596.67 P
2.02 (process all the reopen requests from clients in a timely manner) 72 583.67 P
2.02 (. Some client reopen requests) 366.84 583.67 P
1.15 (arrived at the server and were dropped in its low-level network interrupt routine, because there) 72 570.67 P
1.26 (were no more available RPC server processes to pick up the requests. Other requests might be) 72 557.67 P
1.61 (picked up by server processes, but they could not be handled quickly) 72 544.67 P
1.61 (, because the server was) 391.7 544.67 P
1.1 (already processing as much as it could. Creating new RPC server processes to absorb the extra) 72 531.67 P
0.65 (reopen requests did not help beyond a certain point, because the extra processing load just made) 72 518.67 P
(the server even slower) 72 505.67 T
(.) 169.93 505.67 T
1.15 (These dropped RPC requests caused the system to become unstable. Client workstations that) 82.8 480.67 P
-0.08 (received no response or acknowledgment of their request within the RPC time-out period assumed) 72 467.67 P
0.04 (that the server had crashed again and therefore lost their distributed cache state. These clients then) 72 454.67 P
0.3 (reopened their \336le system state all over again. Under these circumstances, recovery of \336le system) 72 441.67 P
-0.04 (state often took ten or \336fteen minutes in the old Sun-3 system. In some cases, recovery did not \336n-) 72 428.67 P
0.5 (ish at all. W) 72 415.67 P
0.5 (e had no choice but to reboot some of the client workstations manually to reduce the) 125.73 415.67 P
-0.09 (load on the server so that the other workstations could recover) 72 402.67 P
-0.09 (. I call this sort of recovery session a) 343.9 402.67 P
2 F
(r) 72 389.67 T
(ecovery storm) 75.87 389.67 T
1 F
(, as represented in Figure 3-3.) 137.8 389.67 T
0.67 (Figure 3-4 shows the unstable behavior of the system in a particular recovery storm. T) 82.8 364.67 P
0.67 (o begin) 470.68 364.67 P
-0.18 (with, clients are all in the) 72 351.67 P
2 F
-0.18 (unstarted) 184.72 351.67 P
1 F
-0.18 ( state, waiting for the server to become available. When a client) 226.23 351.67 P
-0.25 (detects that the server is available, it enters the) 72 338.67 P
2 F
-0.25 (r) 277.24 338.67 P
-0.25 (ecovering) 281.11 338.67 P
1 F
-0.25 ( state, during which it sends the server its) 324.43 338.67 P
0.58 (reopen requests. For some clients, the reopen RPCs time out, and the clients enter the) 72 325.67 P
2 F
0.58 (timing out) 458.55 325.67 P
1 F
0.57 (state, until the server responds to their next ping requests. When the server responds to a client\325) 72 312.67 P
0.57 (s) 499.73 312.67 P
1.46 (ping request, the client re-enters the recovering state and starts sending the server its recovery) 72 299.67 P
-0.15 (information again. Clients may alternate between recovering and timing out inde\336nitely) 72 286.67 P
-0.15 (. The num-) 455.79 286.67 P
0.66 (ber of clients recovering oscillates up and down during the recovery storm. Finally) 72 273.67 P
0.66 (, some clients) 442.57 273.67 P
0.03 (manage to complete recovery for the last time enter the) 72 260.67 P
2 F
0.03 (\336nished) 317.64 260.67 P
1 F
0.03 ( state. This reduces the load on the) 351.81 260.67 P
0.51 (server and enables other clients to complete recovery) 72 247.67 P
0.51 (. These measurements were taken in the old) 308.23 247.67 P
-0.06 (Sun-3 setup with 41 clients. In this recovery storm, distributed cache state recovery takes over 500) 72 234.67 P
(seconds to complete. This recovery storm may seem severe, but it was not an unusual example.) 72 221.67 T
0 12 Q
(3.4.2. Solving the Contention Pr) 72 190 T
(oblem) 234.7 190 T
1 11 Q
-0.13 (T) 82.8 164.67 P
-0.13 (o solve the contention problem, clients must reduce their demands on the server during periods) 88.74 164.67 P
0.55 (of high load. All distributed systems need this ability) 72 151.67 P
0.55 (, unless they have a lar) 308.52 151.67 P
0.55 (ge amount of wasted) 411.13 151.67 P
0.61 (capacity during normal processing. Contention control is useful during any period of high server) 72 138.67 P
1.27 (demand, and not just during recovery) 72 125.67 P
1.27 (. This section describes two ways to reduce contention in) 241.78 125.67 P
0.77 (Sprite and explains why I chose the second. It then shows the improved system behavior during) 72 112.67 P
(recovery as a result of reducing server contention.) 72 99.67 T
FMENDPAGE
%%EndPage: "45" 57
%%Page: "46" 57
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(46) 318 55 T
1 11 Q
0.42 (One way to reduce client demands during periods of high load is to reduce the number of con-) 118.8 317.69 P
0.83 (current requests each individual client can make of the server) 108 304.69 P
0.83 (. W) 384.31 304.69 P
0.83 (e can do this by decreasing the) 400.13 304.69 P
0.18 (number of) 108 291.69 P
2 F
0.18 (RPC channels) 156.57 291.69 P
1 F
0.18 ( per client. An RPC channel is a set of data structures that keeps track of) 219.31 291.69 P
2.07 (the state of an RPC request. A client process that wishes to communicate with the server is) 108 278.69 P
-0.22 (assigned an RPC channel. Each client has a set number of RPC channels which permit that number) 108 265.69 P
-0.26 (of RPCs to progress concurrently) 108 252.69 P
-0.26 (. A process usually reuses the same channel for subsequent RPCs,) 252.72 252.69 P
0.49 (but the channel may be reassigned if there are more processes than there are channels. T) 108 239.69 P
0.49 (o reduce) 501.99 239.69 P
0.63 (the load on the server) 108 226.69 P
0.63 (, we could ramp down the number of channels per client. For example, the) 204.68 226.69 P
-0.19 (client could automatically reduce its channels if the server fails to respond to some number of RPC) 108 213.69 P
(requests.) 108 200.69 T
0.15 (I discarded this solution for two reasons. First, even if each client has only one channel, the cli-) 118.8 175.69 P
0.12 (ents can still overload the server if they each make a single request at the same time. In fact, a cli-) 108 162.69 P
0.17 (ent uses only one channel to issue its recovery requests, because only a single process handles the) 108 149.69 P
0.08 (client\325) 108 136.69 P
0.08 (s recovery activities. This means that reducing the number of channels to one per client will) 135.47 136.69 P
0.14 (not reduce the load due to reopen requests. Second, this solution is complicated. If all of a client\325) 108 123.69 P
0.14 (s) 535.73 123.69 P
0.67 (channels are in use, this solution requires shutting down active channels and redirecting the pro-) 108 110.69 P
(cesses associated with them to wait for another channel.) 108 97.69 T
1 12 Q
(Figure 3-3. Recovery storm in Sprite.) 234.22 399.02 T
108 355.02 540 373.02 C
108 355.02 540 373.02 R
7 X
0 K
V
108 364.02 540 364.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(In a recovery storm, the server is overwhelmed by reopen traf) 144 376.36 T
(\336c from recovering clients.) 390.55 376.36 T
108 425.02 540 720 C
108.5 425.02 539.5 708 C
347.93 476.01 450.87 530.01 R
4 X
0 K
V
0.5 H
0 Z
0 X
N
1 H
90 450 67.9 70.5 401 522.51 A
0 14 Q
(allspice) 379.39 572.46 T
347.93 476.01 450.87 552.24 R
0.5 H
N
0 10 Q
(distributed cache state) 350.88 541.32 T
0 24 Q
(?!) 390.9 498.55 T
0 14 Q
(\050\336le server\051) 366 559.51 T
554 590.04 487.17 536.89 479.75 544.48 546.58 597.64 4 Y
2 X
V
501 647.04 434.17 593.89 426.75 601.48 493.58 654.64 4 Y
V
264.75 587.04 331.58 533.89 339 541.48 272.17 594.64 4 Y
V
0 X
(arson) 188.57 684.76 T
7 X
90 450 45.38 45.88 201.38 659.01 G
1 H
0 X
90 450 45.38 45.88 201.38 659.01 A
169.75 626.72 233.46 663.89 R
4 X
V
0.5 H
0 X
N
169.75 626.72 233.46 683.39 R
N
0 10 Q
(\336le cache) 181.75 671.19 T
0 14 Q
(apathy) 177.75 688.39 T
0 10 Q
(various \336les) 175.75 644.3 T
0 14 Q
(arson) 309.57 687.76 T
7 X
90 450 45.38 45.88 322.38 662.01 G
1 H
0 X
90 450 45.38 45.88 322.38 662.01 A
290.75 629.72 354.46 666.89 R
4 X
V
0.5 H
0 X
N
290.75 629.72 354.46 686.39 R
N
0 10 Q
(\336le cache) 302.75 674.19 T
0 14 Q
(jaywalk) 298.75 691.39 T
0 10 Q
(various \336les) 296.75 647.3 T
0 14 Q
(arson) 461.57 671.76 T
7 X
90 450 45.38 45.88 474.38 646.01 G
1 H
0 X
90 450 45.38 45.88 474.38 646.01 A
442.75 613.72 506.46 650.89 R
4 X
V
0.5 H
0 X
N
442.75 613.72 506.46 670.39 R
N
0 10 Q
(\336le cache) 454.75 658.19 T
0 14 Q
(forgery) 450.75 675.39 T
0 10 Q
(various \336les) 448.75 631.3 T
0 14 Q
(arson) 423.57 442.76 T
7 X
90 450 45.38 45.88 436.38 417.01 G
1 H
0 X
90 450 45.38 45.88 436.38 417.01 A
404.75 384.72 468.46 441.39 R
0.5 H
N
0 10 Q
(\336le cache) 416.75 429.19 T
0 14 Q
(gr) 417.75 446.39 T
(eed) 430.71 446.39 T
(arson) 483.57 494.76 T
7 X
90 450 45.38 45.88 496.38 469.01 G
1 H
0 X
90 450 45.38 45.88 496.38 469.01 A
464.75 436.72 528.46 473.89 R
4 X
V
0.5 H
0 X
N
464.75 436.72 528.46 493.39 R
N
0 10 Q
(\336le cache) 476.75 481.19 T
0 14 Q
(vagrancy) 469.75 496.39 T
0 10 Q
(various \336les) 470.75 454.3 T
263.75 621.04 330.58 567.89 338 575.48 271.17 628.64 4 Y
2 X
V
7 X
90 450 45.38 45.88 257.38 638.01 G
1 H
0 X
90 450 45.38 45.88 257.38 638.01 A
225.75 605.72 289.46 642.89 R
4 X
V
0.5 H
0 X
N
395 595.89 401.75 617.89 R
2 X
V
284.84 503.51 318.59 510.26 R
V
336.25 583.89 322.75 563.64 349.75 563.64 3 Y
V
313.59 520.89 333.84 507.39 313.59 493.89 3 Y
V
390.75 605.39 398.88 587.89 407 605.39 3 Y
V
0 X
(modi\336ed \336le A) 227 622.94 T
225.75 605.72 289.46 662.39 R
N
(\336le cache) 237.75 650.19 T
0 14 Q
(gluttony) 232.75 666.39 T
(arson) 385.57 683.76 T
7 X
90 450 45.38 45.88 398.38 658.01 G
1 H
0 X
90 450 45.38 45.88 398.38 658.01 A
366.75 625.72 430.46 662.89 R
4 X
V
0.5 H
0 X
N
366.75 625.72 430.46 682.39 R
N
0 10 Q
(\336le B) 370 648.44 T
(\336le cache) 378.75 670.19 T
0 14 Q
(murder) 374.75 687.39 T
(arson) 197.57 626.76 T
7 X
90 450 45.38 45.88 210.38 601.01 G
1 H
0 X
90 450 45.38 45.88 210.38 601.01 A
178.75 568.72 242.46 605.89 R
4 X
V
0.5 H
0 X
N
178.75 568.72 242.46 625.39 R
N
0 10 Q
(\336le cache) 190.75 613.19 T
0 14 Q
(terr) 183.75 627.39 T
(orism) 206.79 627.39 T
0 10 Q
(various \336les) 184.75 586.3 T
0 14 Q
(arson) 322.95 645.64 T
7 X
90 450 45.38 45.88 335.75 619.89 G
1 H
0 X
90 450 45.38 45.88 335.75 619.89 A
304.12 587.6 367.83 624.76 R
4 X
V
0.5 H
0 X
N
304.12 587.6 367.83 644.26 R
N
0 10 Q
(\336le cache) 316.12 632.07 T
0 14 Q
(dr) 309.12 647.26 T
(ooling) 322.87 647.26 T
0 10 Q
(various \336les) 310.12 605.18 T
0 14 Q
(arson) 262.57 589.76 T
7 X
90 450 45.38 45.88 275.38 564.01 G
1 H
0 X
90 450 45.38 45.88 275.38 564.01 A
243.75 531.72 307.46 568.89 R
4 X
V
0.5 H
0 X
N
243.75 531.72 307.46 588.39 R
N
0 10 Q
(\336le cache) 255.75 576.19 T
0 14 Q
(sabotage) 248.75 591.39 T
0 10 Q
(various \336les) 249.75 549.3 T
0 14 Q
(arson) 234.57 534.76 T
7 X
90 450 45.38 45.88 247.38 509.01 G
1 H
0 X
90 450 45.38 45.88 247.38 509.01 A
215.75 476.72 279.46 513.89 R
4 X
V
0.5 H
0 X
N
215.75 476.72 279.46 533.39 R
N
0 10 Q
(\336le B) 219 499.44 T
(\336le cache) 227.75 521.19 T
(modi\336ed \336le C) 217 488.44 T
0 14 Q
(arson) 229.75 540.39 T
332.25 551.89 318.75 531.64 345.75 531.64 3 Y
2 X
V
426.25 609.89 439.75 589.64 412.75 589.64 3 Y
V
0 X
(arson) 492.57 622.76 T
7 X
90 450 45.38 45.88 505.38 597.01 G
1 H
0 X
90 450 45.38 45.88 505.38 597.01 A
473.75 564.72 537.46 601.89 R
4 X
V
0.5 H
0 X
N
473.75 564.72 537.46 621.39 R
N
0 10 Q
(\336le cache) 485.75 609.19 T
0 14 Q
(tr) 481.75 626.39 T
(eason) 492.37 626.39 T
0 10 Q
(various \336les) 479.75 582.3 T
479.25 553.89 465.75 531.64 492.75 531.64 3 Y
2 X
V
0 14 Q
0 X
(arson) 145.57 606.76 T
7 X
90 450 45.38 45.88 158.38 581.01 G
1 H
0 X
90 450 45.38 45.88 158.38 581.01 A
126.75 548.72 190.46 585.89 R
4 X
V
0.5 H
0 X
N
126.75 548.72 190.46 605.39 R
N
0 10 Q
(\336le cache) 138.75 593.19 T
0 14 Q
(bribery) 134.75 609.39 T
0 10 Q
(various \336les) 132.75 566.3 T
0 14 Q
(arson) 164.57 547.76 T
7 X
90 450 45.38 45.88 177.38 522.01 G
1 H
0 X
90 450 45.38 45.88 177.38 522.01 A
145.75 489.72 209.46 526.89 R
4 X
V
0.5 H
0 X
N
145.75 489.72 209.46 546.39 R
N
0 10 Q
(\336le cache) 157.75 534.19 T
0 14 Q
(assault) 155.75 551.39 T
0 10 Q
(various \336les) 151.75 507.3 T
0 14 Q
(arson) 149.57 478.76 T
7 X
90 450 45.38 45.88 162.38 453.01 G
1 H
0 X
90 450 45.38 45.88 162.38 453.01 A
130.75 420.72 194.46 477.39 R
0.5 H
N
0 10 Q
(\336le cache) 142.75 465.19 T
(various \336les) 136.75 438.3 T
130.75 420.72 194.46 457.89 R
4 X
V
0 X
N
0 14 Q
(loiter) 146.75 482.39 T
(arson) 227.95 499.64 T
7 X
90 450 45.38 45.88 240.75 473.89 G
1 H
0 X
90 450 45.38 45.88 240.75 473.89 A
209.12 441.6 272.83 478.76 R
4 X
V
0.5 H
0 X
N
209.12 441.6 272.83 498.26 R
N
0 10 Q
(\336le cache) 221.12 486.07 T
0 14 Q
(adultery) 214.12 501.26 T
0 10 Q
(various \336les) 215.12 459.18 T
0 14 Q
(arson) 293.57 471.76 T
7 X
90 450 45.38 45.88 306.38 446.01 G
1 H
0 X
90 450 45.38 45.88 306.38 446.01 A
274.75 413.72 338.46 450.89 R
4 X
V
0.5 H
0 X
N
274.75 413.72 338.46 470.39 R
N
0 10 Q
(\336le cache) 286.75 458.19 T
0 14 Q
(joyride) 285.75 474.39 T
0 10 Q
(various \336les) 280.75 431.3 T
0 14 Q
(arson) 339.57 455.76 T
7 X
90 450 45.38 45.88 352.38 430.01 G
1 H
0 X
90 450 45.38 45.88 352.38 430.01 A
320.75 397.72 384.46 434.89 R
4 X
V
0.5 H
0 X
N
320.75 397.72 384.46 454.39 R
N
0 10 Q
(\336le cache) 332.75 442.19 T
0 14 Q
(kvetching) 324.75 456.39 T
0 10 Q
(various \336les) 136.12 438.18 T
108 425.02 540 720 C
108.5 425.02 539.5 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "46" 58
%%Page: "47" 58
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(47) 282 55 T
1 11 Q
0.18 (Instead, I chose a solution that both reduces the client load and eliminates instability in the sys-) 82.8 253.69 P
0.58 (tem. I added congestion control in the form of) 72 240.69 P
2 F
0.58 (negative acknowledgments) 282.29 240.69 P
1 F
0.58 ( to Sprite\325) 400.95 240.69 P
0.58 (s RPC proto-) 445.45 240.69 P
-0.19 (col. A negative acknowledgment is an immediate response from the server to a client RPC request.) 72 227.69 P
1.49 (The response merely informs the client that the server is still alive but too busy to handle the) 72 214.69 P
-0.1 (request. The server detects it is overloaded when no RPC server processes are available. Instead of) 72 201.69 P
-0.1 (ignoring a client request under this circumstance, the server responds with a negative acknowledg-) 72 188.69 P
(ment \050NACK\051.) 72 175.69 T
0.65 (NACKs allow the server to shed load without causing instability) 82.8 150.69 P
0.65 (, because they tell clients that) 371.39 150.69 P
0.57 (the server has not crashed) 72 137.69 P
3 F
0.57 (-) 191.07 137.69 P
1 F
0.57 ( it is just too busy) 197.1 137.69 P
0.57 (. The clients can then back of) 277.07 137.69 P
0.57 (f for a period of time) 409.33 137.69 P
0.28 (\050using an exponential back-of) 72 124.69 P
0.28 (f scheme\051 and continue their requests later) 203.54 124.69 P
0.28 (, reducing the load on the) 390.91 124.69 P
1.27 (server) 72 111.69 P
1.27 (. NACKs also eliminate the source of instability) 98.24 111.69 P
1.27 (, because they indicate to clients that the) 317.55 111.69 P
0.4 (server has not lost their state again, since it has not crashed again. The clients then know it is not) 72 98.69 P
(necessary to reissue all their reopen requests.) 72 85.69 T
(Figure 3-4. Recovery storm behavior) 205.61 411.69 T
(.) 367.64 411.69 T
1 10 Q
0.47 (This \336gure illustrates the states clients pass through during a recovery storm. The X axis) 108 389.36 P
-0.13 (shows time progressing. The Y axis gives the number of clients. The dif) 108 378.36 P
-0.13 (ferent regions rep-) 394.43 378.36 P
1.06 (resent dif) 108 367.36 P
1.06 (ferent states. T) 146.35 367.36 P
1.06 (o read the graph, take a vertical slice at any point in time. The) 206.89 367.36 P
0.1 (height of the dif) 108 356.36 P
0.1 (ferent regions along that slice gives the number of clients in each of those) 172.24 356.36 P
-0.22 (states at that time. For example, at time 0 the clients all begin in the) 108 345.36 P
2 F
-0.22 (unstarted) 377.6 345.36 P
1 F
-0.22 ( state. At 200) 415.36 345.36 P
0.12 (seconds, 33 clients are recovering, eight are timing out and none has \336nished. This recov-) 108 334.36 P
0.78 (ery storm was measured in the old Sun-3 setup with 41 clients and took 515 seconds to) 108 323.36 P
72 291.02 504 309.02 C
72 291.02 504 309.02 R
7 X
0 K
V
72 300.02 504 300.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(complete.) 108 312.36 T
72 437.02 504 720 C
72 437.02 504 708 C
0 26 24 359 266 346 256.99 114.5 442.01 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/oldRecovStates.ps
%!PS-Adobe-2.0 EPSF-1.2
%%Title: oldRecovStates.g
%%Creator: gr2ps (Gremlin to PostScript)
%%BoundingBox: 26 24 359 266
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Courier-Bold
%%Pages: 1
%%EndComments

gsave
%%EndProlog
















0.550 setgray
newpath
    297.8 255 moveto
    297.8 255 lineto
    359 255 lineto
    359 50 lineto
    357.8 50 lineto
    357.8 55 lineto
    353 55 lineto
    351.2 60 lineto
    347 60 lineto
    346.4 70 lineto
    345.2 75 lineto
    345.2 90 lineto
    341 100 lineto
    341 100 lineto
    339.8 105 lineto
    339.8 105 lineto
    338 120 lineto
    336.8 125 lineto
    336.8 130 lineto
    336.2 140 lineto
    335.6 145 lineto
    332.6 150 lineto
    330.2 150 lineto
    329.6 160 lineto
    328.4 160 lineto
    327.8 165 lineto
    327.2 180 lineto
    327.2 190 lineto
    326 195 lineto
    324.8 210 lineto
    323 210 lineto
    321.8 210 lineto
    320.6 215 lineto
    316.4 215 lineto
    315.2 220 lineto
    314.6 230 lineto
    314.6 235 lineto
    308 235 lineto
    308 240 lineto
    305.6 240 lineto
    305.6 245 lineto
    299.6 245 lineto
    299.6 250 lineto
    298.4 250 lineto
    297.8 255 lineto
closepath fill
0.8 setlinewidth
0 setgray
newpath
    297.8 255 moveto
    297.8 255 lineto
    359 255 lineto
    359 50 lineto
    357.8 50 lineto
    357.8 55 lineto
    353 55 lineto
    351.2 60 lineto
    347 60 lineto
    346.4 70 lineto
    345.2 75 lineto
    345.2 90 lineto
    341 100 lineto
    341 100 lineto
    339.8 105 lineto
    339.8 105 lineto
    338 120 lineto
    336.8 125 lineto
    336.8 130 lineto
    336.2 140 lineto
    335.6 145 lineto
    332.6 150 lineto
    330.2 150 lineto
    329.6 160 lineto
    328.4 160 lineto
    327.8 165 lineto
    327.2 180 lineto
    327.2 190 lineto
    326 195 lineto
    324.8 210 lineto
    323 210 lineto
    321.8 210 lineto
    320.6 215 lineto
    316.4 215 lineto
    315.2 220 lineto
    314.6 230 lineto
    314.6 235 lineto
    308 235 lineto
    308 240 lineto
    305.6 240 lineto
    305.6 245 lineto
    299.6 245 lineto
    299.6 250 lineto
    298.4 250 lineto
    297.8 255 lineto
closepath stroke

0.700 setgray
newpath
    359 50 moveto
    105.2 50 lineto
    104 55 lineto
    96.8 55 lineto
    96.8 60 lineto
    86 60 lineto
    86 65 lineto
    84.2 70 lineto
    84.2 75 lineto
    82.4 80 lineto
    81.8 90 lineto
    79.4 90 lineto
    77.6 95 lineto
    75.8 95 lineto
    75.8 100 lineto
    74 100 lineto
    73.4 105 lineto
    72.8 110 lineto
    67.4 115 lineto
    65 115 lineto
    64.4 120 lineto
    63.2 125 lineto
    62.6 130 lineto
    61.4 140 lineto
    60.8 145 lineto
    60.2 160 lineto
    59 170 lineto
    56 180 lineto
    56 185 lineto
    56 195 lineto
    56 200 lineto
    54.8 210 lineto
    54.2 220 lineto
    54.2 225 lineto
    53.6 230 lineto
    52.4 235 lineto
    51.8 245 lineto
    50.6 250 lineto
    50 255 lineto
    50.6 255 lineto
    51.8 255 lineto
    52.4 250 lineto
    53.6 250 lineto
    54.2 245 lineto
    54.2 245 lineto
    54.8 235 lineto
    57.8 235 lineto
    58.4 230 lineto
    63.2 230 lineto
    64.4 220 lineto
    65 220 lineto
    67.4 215 lineto
    73.4 215 lineto
    74 210 lineto
    75.8 215 lineto
    75.8 210 lineto
    77 215 lineto
    77.6 205 lineto
    77.6 210 lineto
    79.4 205 lineto
    80 200 lineto
    80.6 195 lineto
    81.8 190 lineto
    82.4 190 lineto
    84.2 190 lineto
    84.2 190 lineto
    86 190 lineto
    86 185 lineto
    86.6 180 lineto
    87.8 175 lineto
    90.8 180 lineto
    92.6 175 lineto
    92.6 170 lineto
    93.2 175 lineto
    94.4 190 lineto
    95.6 195 lineto
    96.8 190 lineto
    96.8 190 lineto
    97.4 190 lineto
    99.2 185 lineto
    101 180 lineto
    104 185 lineto
    105.2 185 lineto
    107 180 lineto
    107.6 185 lineto
    114.2 190 lineto
    116 195 lineto
    117.8 200 lineto
    117.8 195 lineto
    119 190 lineto
    120.2 190 lineto
    122 195 lineto
    122.6 185 lineto
    123.2 180 lineto
    124.4 190 lineto
    124.4 185 lineto
    126.2 180 lineto
    126.2 175 lineto
    126.8 180 lineto
    129.8 185 lineto
    131.6 190 lineto
    132.8 195 lineto
    132.8 190 lineto
    133.4 185 lineto
    134 195 lineto
    137.6 190 lineto
    139.4 185 lineto
    139.4 185 lineto
    143.6 180 lineto
    143.6 175 lineto
    144.2 170 lineto
    145.4 175 lineto
    146.6 170 lineto
    147.8 190 lineto
    149 185 lineto
    150.8 190 lineto
    152 185 lineto
    153.2 185 lineto
    155 180 lineto
    156.2 185 lineto
    156.8 205 lineto
    157.4 200 lineto
    157.4 205 lineto
    158.6 200 lineto
    160.4 205 lineto
    161.6 200 lineto
    162.8 200 lineto
    165.2 205 lineto
    165.8 210 lineto
    170 215 lineto
    171.2 210 lineto
    171.8 215 lineto
    172.4 210 lineto
    172.4 215 lineto
    173.6 220 lineto
    175.4 225 lineto
    177.8 220 lineto
    179.6 215 lineto
    182.6 210 lineto
    183.2 215 lineto
    186.2 210 lineto
    186.8 215 lineto
    189.2 210 lineto
    189.2 220 lineto
    193.4 215 lineto
    195.2 210 lineto
    197.6 215 lineto
    201.8 220 lineto
    202.4 215 lineto
    204.2 215 lineto
    206 220 lineto
    206.6 225 lineto
    209.6 220 lineto
    210.2 215 lineto
    210.8 215 lineto
    212.6 210 lineto
    212.6 225 lineto
    213.8 220 lineto
    214.4 220 lineto
    216.2 210 lineto
    216.8 205 lineto
    218 205 lineto
    218.6 200 lineto
    219.2 195 lineto
    219.2 185 lineto
    220.4 180 lineto
    221 195 lineto
    221.6 190 lineto
    222.8 195 lineto
    225.2 190 lineto
    227 185 lineto
    227.6 185 lineto
    229.4 180 lineto
    229.4 170 lineto
    231.2 165 lineto
    231.8 175 lineto
    233.6 170 lineto
    235.4 160 lineto
    236 165 lineto
    236 165 lineto
    238.4 170 lineto
    239.6 180 lineto
    240.2 175 lineto
    240.2 180 lineto
    240.8 180 lineto
    242.6 185 lineto
    242.6 200 lineto
    245 195 lineto
    246.2 190 lineto
    246.8 185 lineto
    248.6 175 lineto
    248.6 170 lineto
    249.2 160 lineto
    250.4 185 lineto
    251 190 lineto
    251 185 lineto
    252.8 180 lineto
    253.4 195 lineto
    255.2 200 lineto
    257 195 lineto
    257 200 lineto
    259.4 195 lineto
    261.2 190 lineto
    263.6 190 lineto
    263.6 195 lineto
    265.4 200 lineto
    266 210 lineto
    267.2 220 lineto
    267.8 225 lineto
    267.8 230 lineto
    269.6 225 lineto
    271.4 230 lineto
    272 235 lineto
    272.6 230 lineto
    274.4 235 lineto
    275 230 lineto
    278 220 lineto
    278.6 235 lineto
    278.6 225 lineto
    280.4 220 lineto
    280.4 215 lineto
    282.2 210 lineto
    282.8 205 lineto
    282.8 205 lineto
    283.4 200 lineto
    284.6 200 lineto
    284.6 195 lineto
    287 190 lineto
    287.6 195 lineto
    288.8 185 lineto
    288.8 190 lineto
    289.4 205 lineto
    290 195 lineto
    291.2 185 lineto
    291.8 175 lineto
    293 170 lineto
    294.2 165 lineto
    295.4 160 lineto
    295.4 160 lineto
    296 155 lineto
    297.2 160 lineto
    297.8 160 lineto
    298.4 155 lineto
    299.6 160 lineto
    299.6 155 lineto
    300.2 170 lineto
    301.4 165 lineto
    302 160 lineto
    303.8 155 lineto
    304.4 155 lineto
    305.6 155 lineto
    305.6 145 lineto
    306.2 150 lineto
    306.8 140 lineto
    308 135 lineto
    308 130 lineto
    308.6 140 lineto
    309.2 135 lineto
    313.4 140 lineto
    314.6 140 lineto
    314.6 135 lineto
    315.2 120 lineto
    316.4 115 lineto
    316.4 110 lineto
    317 105 lineto
    317.6 110 lineto
    318.8 115 lineto
    318.8 125 lineto
    320.6 130 lineto
    321.8 125 lineto
    323 130 lineto
    323 125 lineto
    323.6 130 lineto
    324.8 125 lineto
    326 110 lineto
    327.2 105 lineto
    327.2 95 lineto
    327.8 90 lineto
    328.4 90 lineto
    329.6 115 lineto
    330.2 105 lineto
    331.4 115 lineto
    331.4 120 lineto
    332.6 125 lineto
    332.6 120 lineto
    335.6 120 lineto
    336.2 115 lineto
    336.8 100 lineto
    336.8 100 lineto
    338 90 lineto
    339.8 65 lineto
    339.8 65 lineto
    341 70 lineto
    341 80 lineto
    345.2 70 lineto
    345.2 60 lineto
    346.4 60 lineto
    347 50 lineto
    351.2 55 lineto
    353 50 lineto
    357.8 55 lineto
closepath fill
0 setgray
newpath
    359 50 moveto
    105.2 50 lineto
    104 55 lineto
    96.8 55 lineto
    96.8 60 lineto
    86 60 lineto
    86 65 lineto
    84.2 70 lineto
    84.2 75 lineto
    82.4 80 lineto
    81.8 90 lineto
    79.4 90 lineto
    77.6 95 lineto
    75.8 95 lineto
    75.8 100 lineto
    74 100 lineto
    73.4 105 lineto
    72.8 110 lineto
    67.4 115 lineto
    65 115 lineto
    64.4 120 lineto
    63.2 125 lineto
    62.6 130 lineto
    61.4 140 lineto
    60.8 145 lineto
    60.2 160 lineto
    59 170 lineto
    56 180 lineto
    56 185 lineto
    56 195 lineto
    56 200 lineto
    54.8 210 lineto
    54.2 220 lineto
    54.2 225 lineto
    53.6 230 lineto
    52.4 235 lineto
    51.8 245 lineto
    50.6 250 lineto
    50 255 lineto
    50.6 255 lineto
    51.8 255 lineto
    52.4 250 lineto
    53.6 250 lineto
    54.2 245 lineto
    54.2 245 lineto
    54.8 235 lineto
    57.8 235 lineto
    58.4 230 lineto
    63.2 230 lineto
    64.4 220 lineto
    65 220 lineto
    67.4 215 lineto
    73.4 215 lineto
    74 210 lineto
    75.8 215 lineto
    75.8 210 lineto
    77 215 lineto
    77.6 205 lineto
    77.6 210 lineto
    79.4 205 lineto
    80 200 lineto
    80.6 195 lineto
    81.8 190 lineto
    82.4 190 lineto
    84.2 190 lineto
    84.2 190 lineto
    86 190 lineto
    86 185 lineto
    86.6 180 lineto
    87.8 175 lineto
    90.8 180 lineto
    92.6 175 lineto
    92.6 170 lineto
    93.2 175 lineto
    94.4 190 lineto
    95.6 195 lineto
    96.8 190 lineto
    96.8 190 lineto
    97.4 190 lineto
    99.2 185 lineto
    101 180 lineto
    104 185 lineto
    105.2 185 lineto
    107 180 lineto
    107.6 185 lineto
    114.2 190 lineto
    116 195 lineto
    117.8 200 lineto
    117.8 195 lineto
    119 190 lineto
    120.2 190 lineto
    122 195 lineto
    122.6 185 lineto
    123.2 180 lineto
    124.4 190 lineto
    124.4 185 lineto
    126.2 180 lineto
    126.2 175 lineto
    126.8 180 lineto
    129.8 185 lineto
    131.6 190 lineto
    132.8 195 lineto
    132.8 190 lineto
    133.4 185 lineto
    134 195 lineto
    137.6 190 lineto
    139.4 185 lineto
    139.4 185 lineto
    143.6 180 lineto
    143.6 175 lineto
    144.2 170 lineto
    145.4 175 lineto
    146.6 170 lineto
    147.8 190 lineto
    149 185 lineto
    150.8 190 lineto
    152 185 lineto
    153.2 185 lineto
    155 180 lineto
    156.2 185 lineto
    156.8 205 lineto
    157.4 200 lineto
    157.4 205 lineto
    158.6 200 lineto
    160.4 205 lineto
    161.6 200 lineto
    162.8 200 lineto
    165.2 205 lineto
    165.8 210 lineto
    170 215 lineto
    171.2 210 lineto
    171.8 215 lineto
    172.4 210 lineto
    172.4 215 lineto
    173.6 220 lineto
    175.4 225 lineto
    177.8 220 lineto
    179.6 215 lineto
    182.6 210 lineto
    183.2 215 lineto
    186.2 210 lineto
    186.8 215 lineto
    189.2 210 lineto
    189.2 220 lineto
    193.4 215 lineto
    195.2 210 lineto
    197.6 215 lineto
    201.8 220 lineto
    202.4 215 lineto
    204.2 215 lineto
    206 220 lineto
    206.6 225 lineto
    209.6 220 lineto
    210.2 215 lineto
    210.8 215 lineto
    212.6 210 lineto
    212.6 225 lineto
    213.8 220 lineto
    214.4 220 lineto
    216.2 210 lineto
    216.8 205 lineto
    218 205 lineto
    218.6 200 lineto
    219.2 195 lineto
    219.2 185 lineto
    220.4 180 lineto
    221 195 lineto
    221.6 190 lineto
    222.8 195 lineto
    225.2 190 lineto
    227 185 lineto
    227.6 185 lineto
    229.4 180 lineto
    229.4 170 lineto
    231.2 165 lineto
    231.8 175 lineto
    233.6 170 lineto
    235.4 160 lineto
    236 165 lineto
    236 165 lineto
    238.4 170 lineto
    239.6 180 lineto
    240.2 175 lineto
    240.2 180 lineto
    240.8 180 lineto
    242.6 185 lineto
    242.6 200 lineto
    245 195 lineto
    246.2 190 lineto
    246.8 185 lineto
    248.6 175 lineto
    248.6 170 lineto
    249.2 160 lineto
    250.4 185 lineto
    251 190 lineto
    251 185 lineto
    252.8 180 lineto
    253.4 195 lineto
    255.2 200 lineto
    257 195 lineto
    257 200 lineto
    259.4 195 lineto
    261.2 190 lineto
    263.6 190 lineto
    263.6 195 lineto
    265.4 200 lineto
    266 210 lineto
    267.2 220 lineto
    267.8 225 lineto
    267.8 230 lineto
    269.6 225 lineto
    271.4 230 lineto
    272 235 lineto
    272.6 230 lineto
    274.4 235 lineto
    275 230 lineto
    278 220 lineto
    278.6 235 lineto
    278.6 225 lineto
    280.4 220 lineto
    280.4 215 lineto
    282.2 210 lineto
    282.8 205 lineto
    282.8 205 lineto
    283.4 200 lineto
    284.6 200 lineto
    284.6 195 lineto
    287 190 lineto
    287.6 195 lineto
    288.8 185 lineto
    288.8 190 lineto
    289.4 205 lineto
    290 195 lineto
    291.2 185 lineto
    291.8 175 lineto
    293 170 lineto
    294.2 165 lineto
    295.4 160 lineto
    295.4 160 lineto
    296 155 lineto
    297.2 160 lineto
    297.8 160 lineto
    298.4 155 lineto
    299.6 160 lineto
    299.6 155 lineto
    300.2 170 lineto
    301.4 165 lineto
    302 160 lineto
    303.8 155 lineto
    304.4 155 lineto
    305.6 155 lineto
    305.6 145 lineto
    306.2 150 lineto
    306.8 140 lineto
    308 135 lineto
    308 130 lineto
    308.6 140 lineto
    309.2 135 lineto
    313.4 140 lineto
    314.6 140 lineto
    314.6 135 lineto
    315.2 120 lineto
    316.4 115 lineto
    316.4 110 lineto
    317 105 lineto
    317.6 110 lineto
    318.8 115 lineto
    318.8 125 lineto
    320.6 130 lineto
    321.8 125 lineto
    323 130 lineto
    323 125 lineto
    323.6 130 lineto
    324.8 125 lineto
    326 110 lineto
    327.2 105 lineto
    327.2 95 lineto
    327.8 90 lineto
    328.4 90 lineto
    329.6 115 lineto
    330.2 105 lineto
    331.4 115 lineto
    331.4 120 lineto
    332.6 125 lineto
    332.6 120 lineto
    335.6 120 lineto
    336.2 115 lineto
    336.8 100 lineto
    336.8 100 lineto
    338 90 lineto
    339.8 65 lineto
    339.8 65 lineto
    341 70 lineto
    341 80 lineto
    345.2 70 lineto
    345.2 60 lineto
    346.4 60 lineto
    347 50 lineto
    351.2 55 lineto
    353 50 lineto
    357.8 55 lineto
closepath stroke

0.875 setgray
newpath
    50 255 moveto
    50.6 255 lineto
    51.8 255 lineto
    52.4 250 lineto
    53.6 250 lineto
    54.2 245 lineto
    54.2 245 lineto
    54.8 235 lineto
    57.8 235 lineto
    58.4 230 lineto
    63.2 230 lineto
    64.4 220 lineto
    65 220 lineto
    67.4 215 lineto
    73.4 215 lineto
    74 210 lineto
    75.8 215 lineto
    75.8 210 lineto
    77 215 lineto
    77.6 205 lineto
    77.6 210 lineto
    79.4 205 lineto
    80 200 lineto
    80.6 195 lineto
    81.8 190 lineto
    82.4 190 lineto
    84.2 190 lineto
    84.2 190 lineto
    86 190 lineto
    86 185 lineto
    86.6 180 lineto
    87.8 175 lineto
    90.8 180 lineto
    92.6 175 lineto
    92.6 170 lineto
    93.2 175 lineto
    94.4 190 lineto
    95.6 195 lineto
    96.8 190 lineto
    96.8 190 lineto
    97.4 190 lineto
    99.2 185 lineto
    101 180 lineto
    104 185 lineto
    105.2 185 lineto
    107 180 lineto
    107.6 185 lineto
    114.2 190 lineto
    116 195 lineto
    117.8 200 lineto
    117.8 195 lineto
    119 190 lineto
    120.2 190 lineto
    122 195 lineto
    122.6 185 lineto
    123.2 180 lineto
    124.4 190 lineto
    124.4 185 lineto
    126.2 180 lineto
    126.2 175 lineto
    126.8 180 lineto
    129.8 185 lineto
    131.6 190 lineto
    132.8 195 lineto
    132.8 190 lineto
    133.4 185 lineto
    134 195 lineto
    137.6 190 lineto
    139.4 185 lineto
    139.4 185 lineto
    143.6 180 lineto
    143.6 175 lineto
    144.2 170 lineto
    145.4 175 lineto
    146.6 170 lineto
    147.8 190 lineto
    149 185 lineto
    150.8 190 lineto
    152 185 lineto
    153.2 185 lineto
    155 180 lineto
    156.2 185 lineto
    156.8 205 lineto
    157.4 200 lineto
    157.4 205 lineto
    158.6 200 lineto
    160.4 205 lineto
    161.6 200 lineto
    162.8 200 lineto
    165.2 205 lineto
    165.8 210 lineto
    170 215 lineto
    171.2 210 lineto
    171.8 215 lineto
    172.4 210 lineto
    172.4 215 lineto
    173.6 220 lineto
    175.4 225 lineto
    177.8 220 lineto
    179.6 215 lineto
    182.6 210 lineto
    183.2 215 lineto
    186.2 210 lineto
    186.8 215 lineto
    189.2 210 lineto
    189.2 220 lineto
    193.4 215 lineto
    195.2 210 lineto
    197.6 215 lineto
    201.8 220 lineto
    202.4 215 lineto
    204.2 215 lineto
    206 220 lineto
    206.6 225 lineto
    209.6 220 lineto
    210.2 215 lineto
    210.8 215 lineto
    212.6 210 lineto
    212.6 225 lineto
    213.8 220 lineto
    214.4 220 lineto
    216.2 210 lineto
    216.8 205 lineto
    218 205 lineto
    218.6 200 lineto
    219.2 195 lineto
    219.2 185 lineto
    220.4 180 lineto
    221 195 lineto
    221.6 190 lineto
    222.8 195 lineto
    225.2 190 lineto
    227 185 lineto
    227.6 185 lineto
    229.4 180 lineto
    229.4 170 lineto
    231.2 165 lineto
    231.8 175 lineto
    233.6 170 lineto
    235.4 160 lineto
    236 165 lineto
    236 165 lineto
    238.4 170 lineto
    239.6 180 lineto
    240.2 175 lineto
    240.2 180 lineto
    240.8 180 lineto
    242.6 185 lineto
    242.6 200 lineto
    245 195 lineto
    246.2 190 lineto
    246.8 185 lineto
    248.6 175 lineto
    248.6 170 lineto
    249.2 160 lineto
    250.4 185 lineto
    251 190 lineto
    251 185 lineto
    252.8 180 lineto
    253.4 195 lineto
    255.2 200 lineto
    257 195 lineto
    257 200 lineto
    259.4 195 lineto
    261.2 190 lineto
    263.6 190 lineto
    263.6 195 lineto
    265.4 200 lineto
    266 210 lineto
    267.2 220 lineto
    267.8 225 lineto
    267.8 230 lineto
    269.6 225 lineto
    271.4 230 lineto
    272 235 lineto
    272.6 230 lineto
    274.4 235 lineto
    275 230 lineto
    278 220 lineto
    278.6 235 lineto
    278.6 225 lineto
    280.4 220 lineto
    280.4 215 lineto
    282.2 210 lineto
    282.8 205 lineto
    282.8 205 lineto
    283.4 200 lineto
    284.6 200 lineto
    284.6 195 lineto
    287 190 lineto
    287.6 195 lineto
    288.8 185 lineto
    288.8 190 lineto
    289.4 205 lineto
    290 195 lineto
    291.2 185 lineto
    291.8 175 lineto
    293 170 lineto
    294.2 165 lineto
    295.4 160 lineto
    295.4 160 lineto
    296 155 lineto
    297.2 160 lineto
    297.8 160 lineto
    298.4 155 lineto
    299.6 160 lineto
    299.6 155 lineto
    300.2 170 lineto
    301.4 165 lineto
    302 160 lineto
    303.8 155 lineto
    304.4 155 lineto
    305.6 155 lineto
    305.6 145 lineto
    306.2 150 lineto
    306.8 140 lineto
    308 135 lineto
    308 130 lineto
    308.6 140 lineto
    309.2 135 lineto
    313.4 140 lineto
    314.6 140 lineto
    314.6 135 lineto
    315.2 120 lineto
    316.4 115 lineto
    316.4 110 lineto
    317 105 lineto
    317.6 110 lineto
    318.8 115 lineto
    318.8 125 lineto
    320.6 130 lineto
    321.8 125 lineto
    323 130 lineto
    323 125 lineto
    323.6 130 lineto
    324.8 125 lineto
    326 110 lineto
    327.2 105 lineto
    327.2 95 lineto
    327.8 90 lineto
    328.4 90 lineto
    329.6 115 lineto
    330.2 105 lineto
    331.4 115 lineto
    331.4 120 lineto
    332.6 125 lineto
    332.6 120 lineto
    335.6 120 lineto
    336.2 115 lineto
    336.8 100 lineto
    336.8 100 lineto
    338 90 lineto
    339.8 65 lineto
    339.8 65 lineto
    341 70 lineto
    341 80 lineto
    345.2 70 lineto
    345.2 60 lineto
    346.4 60 lineto
    347 50 lineto
    351.2 55 lineto
    353 50 lineto
    357.8 55 lineto
    359 50 lineto
    359 50 lineto
    357.8 55 lineto
    353 55 lineto
    351.2 60 lineto
    347 60 lineto
    346.4 70 lineto
    345.2 75 lineto
    345.2 90 lineto
    341 100 lineto
    341 100 lineto
    339.8 105 lineto
    339.8 105 lineto
    338 120 lineto
    336.8 125 lineto
    336.8 130 lineto
    336.2 140 lineto
    335.6 145 lineto
    332.6 150 lineto
    330.2 150 lineto
    329.6 160 lineto
    328.4 160 lineto
    327.8 165 lineto
    327.2 180 lineto
    327.2 190 lineto
    326 195 lineto
    324.8 210 lineto
    323 210 lineto
    321.8 210 lineto
    320.6 215 lineto
    316.4 215 lineto
    315.2 220 lineto
    314.6 230 lineto
    314.6 235 lineto
    308 235 lineto
    308 240 lineto
    305.6 240 lineto
    305.6 245 lineto
    299.6 245 lineto
    299.6 250 lineto
    298.4 250 lineto
    297.8 255 lineto
closepath fill
0 setgray
newpath
    50 255 moveto
    50.6 255 lineto
    51.8 255 lineto
    52.4 250 lineto
    53.6 250 lineto
    54.2 245 lineto
    54.2 245 lineto
    54.8 235 lineto
    57.8 235 lineto
    58.4 230 lineto
    63.2 230 lineto
    64.4 220 lineto
    65 220 lineto
    67.4 215 lineto
    73.4 215 lineto
    74 210 lineto
    75.8 215 lineto
    75.8 210 lineto
    77 215 lineto
    77.6 205 lineto
    77.6 210 lineto
    79.4 205 lineto
    80 200 lineto
    80.6 195 lineto
    81.8 190 lineto
    82.4 190 lineto
    84.2 190 lineto
    84.2 190 lineto
    86 190 lineto
    86 185 lineto
    86.6 180 lineto
    87.8 175 lineto
    90.8 180 lineto
    92.6 175 lineto
    92.6 170 lineto
    93.2 175 lineto
    94.4 190 lineto
    95.6 195 lineto
    96.8 190 lineto
    96.8 190 lineto
    97.4 190 lineto
    99.2 185 lineto
    101 180 lineto
    104 185 lineto
    105.2 185 lineto
    107 180 lineto
    107.6 185 lineto
    114.2 190 lineto
    116 195 lineto
    117.8 200 lineto
    117.8 195 lineto
    119 190 lineto
    120.2 190 lineto
    122 195 lineto
    122.6 185 lineto
    123.2 180 lineto
    124.4 190 lineto
    124.4 185 lineto
    126.2 180 lineto
    126.2 175 lineto
    126.8 180 lineto
    129.8 185 lineto
    131.6 190 lineto
    132.8 195 lineto
    132.8 190 lineto
    133.4 185 lineto
    134 195 lineto
    137.6 190 lineto
    139.4 185 lineto
    139.4 185 lineto
    143.6 180 lineto
    143.6 175 lineto
    144.2 170 lineto
    145.4 175 lineto
    146.6 170 lineto
    147.8 190 lineto
    149 185 lineto
    150.8 190 lineto
    152 185 lineto
    153.2 185 lineto
    155 180 lineto
    156.2 185 lineto
    156.8 205 lineto
    157.4 200 lineto
    157.4 205 lineto
    158.6 200 lineto
    160.4 205 lineto
    161.6 200 lineto
    162.8 200 lineto
    165.2 205 lineto
    165.8 210 lineto
    170 215 lineto
    171.2 210 lineto
    171.8 215 lineto
    172.4 210 lineto
    172.4 215 lineto
    173.6 220 lineto
    175.4 225 lineto
    177.8 220 lineto
    179.6 215 lineto
    182.6 210 lineto
    183.2 215 lineto
    186.2 210 lineto
    186.8 215 lineto
    189.2 210 lineto
    189.2 220 lineto
    193.4 215 lineto
    195.2 210 lineto
    197.6 215 lineto
    201.8 220 lineto
    202.4 215 lineto
    204.2 215 lineto
    206 220 lineto
    206.6 225 lineto
    209.6 220 lineto
    210.2 215 lineto
    210.8 215 lineto
    212.6 210 lineto
    212.6 225 lineto
    213.8 220 lineto
    214.4 220 lineto
    216.2 210 lineto
    216.8 205 lineto
    218 205 lineto
    218.6 200 lineto
    219.2 195 lineto
    219.2 185 lineto
    220.4 180 lineto
    221 195 lineto
    221.6 190 lineto
    222.8 195 lineto
    225.2 190 lineto
    227 185 lineto
    227.6 185 lineto
    229.4 180 lineto
    229.4 170 lineto
    231.2 165 lineto
    231.8 175 lineto
    233.6 170 lineto
    235.4 160 lineto
    236 165 lineto
    236 165 lineto
    238.4 170 lineto
    239.6 180 lineto
    240.2 175 lineto
    240.2 180 lineto
    240.8 180 lineto
    242.6 185 lineto
    242.6 200 lineto
    245 195 lineto
    246.2 190 lineto
    246.8 185 lineto
    248.6 175 lineto
    248.6 170 lineto
    249.2 160 lineto
    250.4 185 lineto
    251 190 lineto
    251 185 lineto
    252.8 180 lineto
    253.4 195 lineto
    255.2 200 lineto
    257 195 lineto
    257 200 lineto
    259.4 195 lineto
    261.2 190 lineto
    263.6 190 lineto
    263.6 195 lineto
    265.4 200 lineto
    266 210 lineto
    267.2 220 lineto
    267.8 225 lineto
    267.8 230 lineto
    269.6 225 lineto
    271.4 230 lineto
    272 235 lineto
    272.6 230 lineto
    274.4 235 lineto
    275 230 lineto
    278 220 lineto
    278.6 235 lineto
    278.6 225 lineto
    280.4 220 lineto
    280.4 215 lineto
    282.2 210 lineto
    282.8 205 lineto
    282.8 205 lineto
    283.4 200 lineto
    284.6 200 lineto
    284.6 195 lineto
    287 190 lineto
    287.6 195 lineto
    288.8 185 lineto
    288.8 190 lineto
    289.4 205 lineto
    290 195 lineto
    291.2 185 lineto
    291.8 175 lineto
    293 170 lineto
    294.2 165 lineto
    295.4 160 lineto
    295.4 160 lineto
    296 155 lineto
    297.2 160 lineto
    297.8 160 lineto
    298.4 155 lineto
    299.6 160 lineto
    299.6 155 lineto
    300.2 170 lineto
    301.4 165 lineto
    302 160 lineto
    303.8 155 lineto
    304.4 155 lineto
    305.6 155 lineto
    305.6 145 lineto
    306.2 150 lineto
    306.8 140 lineto
    308 135 lineto
    308 130 lineto
    308.6 140 lineto
    309.2 135 lineto
    313.4 140 lineto
    314.6 140 lineto
    314.6 135 lineto
    315.2 120 lineto
    316.4 115 lineto
    316.4 110 lineto
    317 105 lineto
    317.6 110 lineto
    318.8 115 lineto
    318.8 125 lineto
    320.6 130 lineto
    321.8 125 lineto
    323 130 lineto
    323 125 lineto
    323.6 130 lineto
    324.8 125 lineto
    326 110 lineto
    327.2 105 lineto
    327.2 95 lineto
    327.8 90 lineto
    328.4 90 lineto
    329.6 115 lineto
    330.2 105 lineto
    331.4 115 lineto
    331.4 120 lineto
    332.6 125 lineto
    332.6 120 lineto
    335.6 120 lineto
    336.2 115 lineto
    336.8 100 lineto
    336.8 100 lineto
    338 90 lineto
    339.8 65 lineto
    339.8 65 lineto
    341 70 lineto
    341 80 lineto
    345.2 70 lineto
    345.2 60 lineto
    346.4 60 lineto
    347 50 lineto
    351.2 55 lineto
    353 50 lineto
    357.8 55 lineto
    359 50 lineto
    359 50 lineto
    357.8 55 lineto
    353 55 lineto
    351.2 60 lineto
    347 60 lineto
    346.4 70 lineto
    345.2 75 lineto
    345.2 90 lineto
    341 100 lineto
    341 100 lineto
    339.8 105 lineto
    339.8 105 lineto
    338 120 lineto
    336.8 125 lineto
    336.8 130 lineto
    336.2 140 lineto
    335.6 145 lineto
    332.6 150 lineto
    330.2 150 lineto
    329.6 160 lineto
    328.4 160 lineto
    327.8 165 lineto
    327.2 180 lineto
    327.2 190 lineto
    326 195 lineto
    324.8 210 lineto
    323 210 lineto
    321.8 210 lineto
    320.6 215 lineto
    316.4 215 lineto
    315.2 220 lineto
    314.6 230 lineto
    314.6 235 lineto
    308 235 lineto
    308 240 lineto
    305.6 240 lineto
    305.6 245 lineto
    299.6 245 lineto
    299.6 250 lineto
    298.4 250 lineto
    297.8 255 lineto
closepath stroke

1.000 setgray
newpath
    50 255 moveto
    50 255 lineto
    50.6 250 lineto
    51.8 245 lineto
    52.4 235 lineto
    53.6 230 lineto
    54.2 225 lineto
    54.2 220 lineto
    54.8 210 lineto
    56 200 lineto
    56 195 lineto
    56 185 lineto
    56 180 lineto
    59 170 lineto
    60.2 160 lineto
    60.8 145 lineto
    61.4 140 lineto
    62.6 130 lineto
    63.2 125 lineto
    64.4 120 lineto
    65 115 lineto
    67.4 115 lineto
    72.8 110 lineto
    73.4 105 lineto
    74 100 lineto
    75.8 100 lineto
    75.8 95 lineto
    77.6 95 lineto
    79.4 90 lineto
    81.8 90 lineto
    82.4 80 lineto
    84.2 75 lineto
    84.2 70 lineto
    86 65 lineto
    86 60 lineto
    96.8 60 lineto
    96.8 55 lineto
    104 55 lineto
    105.2 50 lineto
    359 50 lineto
    50 50 lineto
    50 255 lineto
closepath fill
0 setgray
newpath
    50 255 moveto
    50 255 lineto
    50.6 250 lineto
    51.8 245 lineto
    52.4 235 lineto
    53.6 230 lineto
    54.2 225 lineto
    54.2 220 lineto
    54.8 210 lineto
    56 200 lineto
    56 195 lineto
    56 185 lineto
    56 180 lineto
    59 170 lineto
    60.2 160 lineto
    60.8 145 lineto
    61.4 140 lineto
    62.6 130 lineto
    63.2 125 lineto
    64.4 120 lineto
    65 115 lineto
    67.4 115 lineto
    72.8 110 lineto
    73.4 105 lineto
    74 100 lineto
    75.8 100 lineto
    75.8 95 lineto
    77.6 95 lineto
    79.4 90 lineto
    81.8 90 lineto
    82.4 80 lineto
    84.2 75 lineto
    84.2 70 lineto
    86 65 lineto
    86 60 lineto
    96.8 60 lineto
    96.8 55 lineto
    104 55 lineto
    105.2 50 lineto
    359 50 lineto
    50 50 lineto
    50 255 lineto
closepath stroke






















/Times-Roman findfont 10 scalefont setfont
321.2 238 moveto
0 1 rmoveto (finished) show

54.8 62 moveto
0 1 rmoveto (unstarted) show

150.8 236 moveto
0 1 rmoveto (timing out) show

165.2 120 moveto
0 1 rmoveto (recovering) show

143.6 24 moveto
0 1 rmoveto (Time in seconds) show

26 266 moveto
0 1 rmoveto (Number of clients) show




















344 32.5 moveto
0 1 rmoveto (500) show

284 32.5 moveto
0 1 rmoveto (400) show

224 32.5 moveto
0 1 rmoveto (300) show

164 32.5 moveto
0 1 rmoveto (200) show

104 32.5 moveto
0 1 rmoveto (100) show

47.6 32.5 moveto
0 1 rmoveto (0) show

36.8 98 moveto
(10) dup stringwidth pop -1 mul 1 rmoveto show

36.8 73 moveto
(5) dup stringwidth pop -1 mul 1 rmoveto show

36.8 123 moveto
(15) dup stringwidth pop -1 mul 1 rmoveto show

36.8 148 moveto
(20) dup stringwidth pop -1 mul 1 rmoveto show

36.8 173 moveto
(25) dup stringwidth pop -1 mul 1 rmoveto show

36.8 48 moveto
(0) dup stringwidth pop -1 mul 1 rmoveto show

36.8 198 moveto
(30) dup stringwidth pop -1 mul 1 rmoveto show

36.8 223 moveto
(35) dup stringwidth pop -1 mul 1 rmoveto show

36.8 248 moveto
(40) dup stringwidth pop -1 mul 1 rmoveto show







0.3 setlinewidth
newpath
    44 250 moveto
    50 250 lineto
stroke

newpath
    44 225 moveto
    50 225 lineto
stroke

newpath
    44 200 moveto
    50 200 lineto
stroke

newpath
    44 175 moveto
    50 175 lineto
stroke

newpath
    44 150 moveto
    50 150 lineto
stroke

newpath
    44 125 moveto
    50 125 lineto
stroke

newpath
    44 100 moveto
    50 100 lineto
stroke

newpath
    44 75 moveto
    50 75 lineto
stroke

newpath
    44 50 moveto
    50 50 lineto
stroke





newpath
    50 50 moveto
    50 45 lineto
stroke

newpath
    110 50 moveto
    110 45 lineto
stroke

newpath
    170 50 moveto
    170 45 lineto
stroke

newpath
    230 50 moveto
    230 45 lineto
stroke

newpath
    290 50 moveto
    290 45 lineto
stroke

newpath
    350 50 moveto
    350 45 lineto
stroke
















%%Trailer
grestore

%%EndDocument
FMENDEPSF
72 437.02 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "47" 59
%%Page: "48" 59
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(48) 318 55 T
1 11 Q
1.29 (Negative acknowledgments are a general mechanism for congestion control. They are useful) 118.8 712.67 P
0.66 (during normal processing and not just during recovery) 108 699.67 P
0.66 (. Any time the server becomes overloaded) 350.83 699.67 P
-0.15 (with client requests, negative acknowledgments allow it to shed load without destabilizing the sys-) 108 686.67 P
0.29 (tem. For example, NACKS provide congestion control during lar) 108 673.67 P
0.29 (ge system compiles, when many) 396.34 673.67 P
0.66 (clients simultaneously run migrated compilation processes. Even during periods of lighter server) 108 660.67 P
(loads, we often see more than ten NACKS issued by the server in one day) 108 647.67 T
(.) 432.24 647.67 T
0.4 (It is important, though, that the congestion control mechanism use very little processing on the) 118.8 622.67 P
0.77 (server) 108 609.67 P
0.77 (, or else it will make the server loading problem even worse. NACKs are a good solution,) 134.4 609.67 P
0.46 (because they do not add much overhead on the server) 108 596.67 P
0.46 (. T) 346.73 596.67 P
0.46 (o respond with a NACK, the server does) 358.62 596.67 P
0.19 (not need to interpret the client\325) 108 583.67 P
0.19 (s request in any way) 244.12 583.67 P
0.19 (. An RPC server process is not needed to issue) 333.86 583.67 P
0.86 (the NACK. The NACK can thus be executed at a very low level \050at interrupt level in most sys-) 108 570.67 P
(tems\051, without using much CPU processing or other server resources.) 108 557.67 T
0.39 ( Figure 3-5 shows the changed recovery behavior of the system with a server that can generate) 118.8 532.67 P
1.05 (negative acknowledgments. This measurement is also from the old Sun-3 setup with 41 clients.) 108 519.67 P
0.7 (The \336rst feature to note is that no clients enter a timing-out phase during which they believe the) 108 506.67 P
0.65 (server is down. Instead, the clients progress directly from reopening their handles to the \336nished) 108 493.67 P
1.03 (state. The recovery phase may still take a while, especially if the clients receive many negative) 108 480.67 P
1.77 (acknowledgments and must wait for the server) 108 467.67 P
1.77 (, but the clients always make forward progress) 323.2 467.67 P
0.57 (recovering their cache state. The second feature to note is that recovery is shorter) 108 454.67 P
0.57 (. Clients do not) 471.14 454.67 P
1.48 (make repeated recovery attempts, so the overall recovery period takes only about 1) 108 441.67 P
1.48 (10 seconds) 490 441.67 P
(rather than the previous 500.) 108 428.67 T
-0.14 ( However) 118.8 403.67 P
-0.14 (, this speedup is also due to staggering client recovery requests, as described in section) 161.23 403.67 P
1.38 (3.4.4. The following experiment measures the bene\336t due alone to NACKS, without any other) 108 390.67 P
0.3 (variables. In the more controlled environment of the testbed setup, I measure recovery times with) 108 377.67 P
-0.24 (and without NACKS. T) 108 364.67 P
-0.24 (o initiate the recovery storm with only ten available clients I cause each cli-) 210.88 364.67 P
0.03 (ent to recover more state than in the basic state setup, and I restrict the number of RPC server pro-) 108 351.67 P
0.48 (cesses on the \336le server to three, thus simulating a server with less processing power) 108 338.67 P
0.48 (. I chose the) 485.47 338.67 P
1.6 (parameters to this experiment to ensure a high enough load on the server to cause a recovery) 108 325.67 P
0.81 (storm; they are otherwise arbitrary) 108 312.67 P
0.81 (. Each client recovers 3020 handles: 1000 \336le I/O handles for) 262.47 312.67 P
0.37 (unopened \336les, 1010 \336le I/O handles opened for reading and the corresponding 1010 stream han-) 108 299.67 P
0.34 (dles to those open \336les. T) 108 286.67 P
0.34 (en of the open \336les are shared between all the clients, but the other \336les) 221.24 286.67 P
0.86 (are all unique. In addition, two clients create and unlink three \336les every second, and one client) 108 273.67 P
0.26 (truncates and overwrites a \336le every second. In the \336rst set of measurements, the server could not) 108 260.67 P
0.26 (generate negative acknowledgments, while in the second it could. The setup for the two measure-) 108 247.67 P
(ments is otherwise identical.) 108 234.67 T
0.22 ( The following \336gures show the results of these experiments. While not as chaotic as the previ-) 118.8 209.67 P
-0.08 (ous recovery storm, Figure 3-6 shows similar behavior) 108 196.67 P
-0.08 (. Clients alternate several times between the) 347.31 196.67 P
0.12 (recovering and timing-out states. Overall, the recovery storm requires over four minutes \050250 sec-) 108 183.67 P
0.73 (onds\051 to complete. Figure 3-7 shows the same scenario but with a server that generates negative) 108 170.67 P
1.05 (acknowledgments. There is no longer a phase during which client RPCs time-out, because they) 108 157.67 P
0.58 (receive negative acknowledgments instead. Eliminating the instability cuts recovery time in half,) 108 144.67 P
0.33 (to two minutes. These measurements show that negative acknowledgments alone are a successful) 108 131.67 P
(form of congestion control.) 108 118.67 T
FMENDPAGE
%%EndPage: "48" 60
%%Page: "49" 60
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(49) 282 55 T
0 F
(3.4.3. Synchr) 72 252.02 T
(onized Client Recovery Requests) 138.42 252.02 T
1 11 Q
0.09 (A second problem that contributes to recovery storms is that many clients may initiate recovery) 82.8 226.69 P
0.5 (with the server simultaneously) 72 213.69 P
0.5 (, rather than staggering their recovery requests. This puts a sudden) 207.35 213.69 P
0.05 (recovery load on the server) 72 200.69 P
0.05 (. I found that the reason for this behavior is that \336le server reboots syn-) 191.18 200.69 P
0.69 (chronize the clients over time and cause them to initiate recovery together) 72 187.69 P
0.69 (. This is an interesting) 403.9 187.69 P
0.91 (example of a phenomenon seen elsewhere in distributed systems: global events \050in this case the) 72 174.69 P
0.83 (server reboots\051 can cause unexpected and undesirable synchronization of dif) 72 161.69 P
0.83 (ferent elements of a) 414.56 161.69 P
(distributed system. The results are similar to those found in the) 72 148.69 T
2 F
(convoy phenomenon) 351.52 148.69 T
1 F
( [Blasge79].) 441.52 148.69 T
0.93 (Figure 3-8 shows this recovery synchronization problem. At 83 seconds through recovery) 82.8 123.69 P
0.93 (, 15) 486.59 123.69 P
0.22 (clients initiate recovery with the server during the same second. At 84 seconds, another 15 clients) 72 110.69 P
0.07 (initiate recovery with the server) 72 97.69 P
0.07 (. These clients place a sudden load on the server when they all ini-) 211.41 97.69 P
(Figure 3-5. Recovery with server NACKs.) 194.79 421.69 T
1 10 Q
-0.02 (This \336gure illustrates the states clients pass through during recovery with a server that can) 108 399.36 P
0.21 (respond with negative acknowledgments. The X axis shows time progressing. The Y axis) 108 388.36 P
0.94 (gives the number of clients. The dif) 108 377.36 P
0.94 (ferent regions represent dif) 255.84 377.36 P
0.94 (ferent states. T) 366.43 377.36 P
0.94 (o read the) 426.72 377.36 P
0.51 (graph, take a vertical slice at any point in time. The height of the dif) 108 366.36 P
0.51 (ferent regions along) 387.04 366.36 P
0.49 (that slice gives the number of clients in each of those states at that time. For example, at) 108 355.36 P
0.52 (time 0 the clients all begin in the) 108 344.36 P
2 F
0.52 (unstarted) 245.4 344.36 P
1 F
0.52 ( state. At 40 seconds, 14 clients still have not) 283.16 344.36 P
0.76 (started recovery) 108 333.36 P
0.76 (, three are recovering, and 24 have \336nished recovery) 172.21 333.36 P
0.76 (. This recovery ses-) 387.45 333.36 P
0.7 (sion was measured in the old Sun-3 setup with 41 clients and took 1) 108 322.36 P
0.7 (10 seconds to com-) 388.46 322.36 P
72 290.02 504 308.02 C
72 290.02 504 308.02 R
7 X
0 K
V
72 299.02 504 299.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(plete.) 108 311.36 T
72 447.02 504 720 C
72 447.02 504 708 C
0 20.6 20.5 363.8 266 346 246.49 115.5 452.51 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/newRecovStates.ps
%!PS-Adobe-2.0 EPSF-1.2
%%Title: newRecovStates.g
%%Creator: gr2ps (Gremlin to PostScript)
%%BoundingBox: 20.6 20.5 363.8 266
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Courier-Bold
%%Pages: 1
%%EndComments

gsave
%%EndProlog





































0.550 setgray
newpath
    50 255 moveto
    116 255 lineto
    359 255 lineto
    359 50 lineto
    116 50 lineto
    110.6 55 lineto
    110 65 lineto
    105.8 70 lineto
    101.6 75 lineto
    99.8 80 lineto
    96.8 85 lineto
    96.2 90 lineto
    95 90 lineto
    92.6 95 lineto
    90.8 100 lineto
    90.2 100 lineto
    87.2 105 lineto
    86.6 110 lineto
    85.4 115 lineto
    84.2 115 lineto
    83.6 120 lineto
    80.6 125 lineto
    80 130 lineto
    79.4 130 lineto
    78.8 130 lineto
    78.2 130 lineto
    77.6 135 lineto
    74 135 lineto
    72.2 135 lineto
    70.4 145 lineto
    69.2 150 lineto
    68.6 150 lineto
    66.2 160 lineto
    66.2 170 lineto
    64.4 175 lineto
    64.4 180 lineto
    63.8 185 lineto
    62 190 lineto
    61.4 190 lineto
    60.8 190 lineto
    59.6 190 lineto
    59 195 lineto
    58.4 200 lineto
    56.6 205 lineto
    56 205 lineto
    55.4 210 lineto
    54.8 215 lineto
    54.2 220 lineto
    53.6 220 lineto
    53 230 lineto
    51.8 255 lineto
    50.6 255 lineto
    50 255 lineto
closepath fill
0.8 setlinewidth
0 setgray
newpath
    50 255 moveto
    116 255 lineto
    359 255 lineto
    359 50 lineto
    116 50 lineto
    110.6 55 lineto
    110 65 lineto
    105.8 70 lineto
    101.6 75 lineto
    99.8 80 lineto
    96.8 85 lineto
    96.2 90 lineto
    95 90 lineto
    92.6 95 lineto
    90.8 100 lineto
    90.2 100 lineto
    87.2 105 lineto
    86.6 110 lineto
    85.4 115 lineto
    84.2 115 lineto
    83.6 120 lineto
    80.6 125 lineto
    80 130 lineto
    79.4 130 lineto
    78.8 130 lineto
    78.2 130 lineto
    77.6 135 lineto
    74 135 lineto
    72.2 135 lineto
    70.4 145 lineto
    69.2 150 lineto
    68.6 150 lineto
    66.2 160 lineto
    66.2 170 lineto
    64.4 175 lineto
    64.4 180 lineto
    63.8 185 lineto
    62 190 lineto
    61.4 190 lineto
    60.8 190 lineto
    59.6 190 lineto
    59 195 lineto
    58.4 200 lineto
    56.6 205 lineto
    56 205 lineto
    55.4 210 lineto
    54.8 215 lineto
    54.2 220 lineto
    53.6 220 lineto
    53 230 lineto
    51.8 255 lineto
    50.6 255 lineto
    50 255 lineto
closepath stroke

0.700 setgray
newpath
    50 255 moveto
    50.6 255 lineto
    51.8 255 lineto
    53 230 lineto
    53.6 220 lineto
    54.2 220 lineto
    54.8 215 lineto
    55.4 210 lineto
    56 205 lineto
    56.6 205 lineto
    58.4 200 lineto
    59 195 lineto
    59.6 190 lineto
    60.8 190 lineto
    61.4 190 lineto
    62 190 lineto
    63.8 185 lineto
    64.4 180 lineto
    64.4 175 lineto
    66.2 170 lineto
    66.2 160 lineto
    68.6 150 lineto
    69.2 150 lineto
    70.4 145 lineto
    72.2 135 lineto
    74 135 lineto
    77.6 135 lineto
    78.2 130 lineto
    78.8 130 lineto
    79.4 130 lineto
    80 130 lineto
    80.6 125 lineto
    83.6 120 lineto
    84.2 115 lineto
    85.4 115 lineto
    86.6 110 lineto
    87.2 105 lineto
    90.2 100 lineto
    90.8 100 lineto
    92.6 95 lineto
    95 90 lineto
    96.2 90 lineto
    96.8 85 lineto
    99.8 80 lineto
    101.6 75 lineto
    105.8 70 lineto
    110 65 lineto
    110.6 55 lineto
    116 50 lineto
    116 50 lineto
    110.6 50 lineto
    110 50 lineto
    105.8 50 lineto
    101.6 50 lineto
    99.8 60 lineto
    96.8 60 lineto
    96.2 60 lineto
    95 65 lineto
    92.6 65 lineto
    90.8 65 lineto
    90.2 75 lineto
    85.4 75 lineto
    84.2 85 lineto
    80 85 lineto
    79.4 90 lineto
    78.8 100 lineto
    78.2 110 lineto
    77.6 115 lineto
    74 120 lineto
    72.2 130 lineto
    70.4 130 lineto
    69.2 130 lineto
    68.6 145 lineto
    66.2 145 lineto
    66.2 160 lineto
    64.4 160 lineto
    64.4 165 lineto
    63.8 165 lineto
    62 165 lineto
    61.4 170 lineto
    60.8 175 lineto
    59.6 180 lineto
    59 185 lineto
    58.4 185 lineto
    56.6 185 lineto
    56 190 lineto
    55.4 190 lineto
    54.8 190 lineto
    54.2 190 lineto
    53.6 205 lineto
    53 215 lineto
    51.8 225 lineto
    50.6 230 lineto
    50 255 lineto
closepath fill
0 setgray
newpath
    50 255 moveto
    50.6 255 lineto
    51.8 255 lineto
    53 230 lineto
    53.6 220 lineto
    54.2 220 lineto
    54.8 215 lineto
    55.4 210 lineto
    56 205 lineto
    56.6 205 lineto
    58.4 200 lineto
    59 195 lineto
    59.6 190 lineto
    60.8 190 lineto
    61.4 190 lineto
    62 190 lineto
    63.8 185 lineto
    64.4 180 lineto
    64.4 175 lineto
    66.2 170 lineto
    66.2 160 lineto
    68.6 150 lineto
    69.2 150 lineto
    70.4 145 lineto
    72.2 135 lineto
    74 135 lineto
    77.6 135 lineto
    78.2 130 lineto
    78.8 130 lineto
    79.4 130 lineto
    80 130 lineto
    80.6 125 lineto
    83.6 120 lineto
    84.2 115 lineto
    85.4 115 lineto
    86.6 110 lineto
    87.2 105 lineto
    90.2 100 lineto
    90.8 100 lineto
    92.6 95 lineto
    95 90 lineto
    96.2 90 lineto
    96.8 85 lineto
    99.8 80 lineto
    101.6 75 lineto
    105.8 70 lineto
    110 65 lineto
    110.6 55 lineto
    116 50 lineto
    116 50 lineto
    110.6 50 lineto
    110 50 lineto
    105.8 50 lineto
    101.6 50 lineto
    99.8 60 lineto
    96.8 60 lineto
    96.2 60 lineto
    95 65 lineto
    92.6 65 lineto
    90.8 65 lineto
    90.2 75 lineto
    85.4 75 lineto
    84.2 85 lineto
    80 85 lineto
    79.4 90 lineto
    78.8 100 lineto
    78.2 110 lineto
    77.6 115 lineto
    74 120 lineto
    72.2 130 lineto
    70.4 130 lineto
    69.2 130 lineto
    68.6 145 lineto
    66.2 145 lineto
    66.2 160 lineto
    64.4 160 lineto
    64.4 165 lineto
    63.8 165 lineto
    62 165 lineto
    61.4 170 lineto
    60.8 175 lineto
    59.6 180 lineto
    59 185 lineto
    58.4 185 lineto
    56.6 185 lineto
    56 190 lineto
    55.4 190 lineto
    54.8 190 lineto
    54.2 190 lineto
    53.6 205 lineto
    53 215 lineto
    51.8 225 lineto
    50.6 230 lineto
    50 255 lineto
closepath stroke

1.000 setgray
newpath
    50 255 moveto
    50.6 230 lineto
    51.8 225 lineto
    53 215 lineto
    53.6 205 lineto
    54.2 190 lineto
    54.8 190 lineto
    55.4 190 lineto
    56 190 lineto
    56.6 185 lineto
    58.4 185 lineto
    59 185 lineto
    59.6 180 lineto
    60.8 175 lineto
    61.4 170 lineto
    62 165 lineto
    63.8 165 lineto
    64.4 165 lineto
    64.4 160 lineto
    66.2 160 lineto
    66.2 145 lineto
    68.6 145 lineto
    69.2 130 lineto
    70.4 130 lineto
    72.2 130 lineto
    74 120 lineto
    77.6 115 lineto
    78.2 110 lineto
    78.8 100 lineto
    79.4 90 lineto
    80 85 lineto
    84.2 85 lineto
    85.4 75 lineto
    90.2 75 lineto
    90.8 65 lineto
    92.6 65 lineto
    95 65 lineto
    96.2 60 lineto
    96.8 60 lineto
    99.8 60 lineto
    101.6 50 lineto
    105.8 50 lineto
    110 50 lineto
    110.6 50 lineto
    116 50 lineto
    50 50 lineto
    50 255 lineto
closepath fill
0 setgray
newpath
    50 255 moveto
    50.6 230 lineto
    51.8 225 lineto
    53 215 lineto
    53.6 205 lineto
    54.2 190 lineto
    54.8 190 lineto
    55.4 190 lineto
    56 190 lineto
    56.6 185 lineto
    58.4 185 lineto
    59 185 lineto
    59.6 180 lineto
    60.8 175 lineto
    61.4 170 lineto
    62 165 lineto
    63.8 165 lineto
    64.4 165 lineto
    64.4 160 lineto
    66.2 160 lineto
    66.2 145 lineto
    68.6 145 lineto
    69.2 130 lineto
    70.4 130 lineto
    72.2 130 lineto
    74 120 lineto
    77.6 115 lineto
    78.2 110 lineto
    78.8 100 lineto
    79.4 90 lineto
    80 85 lineto
    84.2 85 lineto
    85.4 75 lineto
    90.2 75 lineto
    90.8 65 lineto
    92.6 65 lineto
    95 65 lineto
    96.2 60 lineto
    96.8 60 lineto
    99.8 60 lineto
    101.6 50 lineto
    105.8 50 lineto
    110 50 lineto
    110.6 50 lineto
    116 50 lineto
    50 50 lineto
    50 255 lineto
closepath stroke


/Times-Roman findfont 10 scalefont setfont
36.8 248 moveto
(40) dup stringwidth pop -1 mul 1 rmoveto show

36.8 223 moveto
(35) dup stringwidth pop -1 mul 1 rmoveto show

36.8 198 moveto
(30) dup stringwidth pop -1 mul 1 rmoveto show

36.8 48 moveto
(0) dup stringwidth pop -1 mul 1 rmoveto show

36.8 173 moveto
(25) dup stringwidth pop -1 mul 1 rmoveto show

36.8 148 moveto
(20) dup stringwidth pop -1 mul 1 rmoveto show

36.8 123 moveto
(15) dup stringwidth pop -1 mul 1 rmoveto show

36.8 73 moveto
(5) dup stringwidth pop -1 mul 1 rmoveto show

36.8 98 moveto
(10) dup stringwidth pop -1 mul 1 rmoveto show

47.6 32.5 moveto
0 1 rmoveto (0) show

104 32.5 moveto
0 1 rmoveto (100) show

164 32.5 moveto
0 1 rmoveto (200) show

224 32.5 moveto
0 1 rmoveto (300) show

284 32.5 moveto
0 1 rmoveto (400) show

344 32.5 moveto
0 1 rmoveto (500) show
















26 266 moveto
0 1 rmoveto (Number of clients) show

143.6 20.5 moveto
0 1 rmoveto (Time in seconds) show

102.8 106 moveto
0 1 rmoveto (recovering) show

54.8 62 moveto
0 1 rmoveto (unstarted) show

225.2 184 moveto
0 1 rmoveto (finished) show




newpath
    122 104 moveto
    83.6 92 lineto
stroke
















0.3 setlinewidth
newpath
    350 50 moveto
    350 45 lineto
stroke

newpath
    290 50 moveto
    290 45 lineto
stroke

newpath
    230 50 moveto
    230 45 lineto
stroke

newpath
    170 50 moveto
    170 45 lineto
stroke

newpath
    110 50 moveto
    110 45 lineto
stroke

newpath
    50 50 moveto
    50 45 lineto
stroke

newpath
    44 50 moveto
    50 50 lineto
stroke

newpath
    44 75 moveto
    50 75 lineto
stroke

newpath
    44 100 moveto
    50 100 lineto
stroke

newpath
    44 125 moveto
    50 125 lineto
stroke

newpath
    44 150 moveto
    50 150 lineto
stroke

newpath
    44 175 moveto
    50 175 lineto
stroke

newpath
    44 200 moveto
    50 200 lineto
stroke

newpath
    44 225 moveto
    50 225 lineto
stroke

newpath
    44 250 moveto
    50 250 lineto
stroke









%%Trailer
grestore

%%EndDocument
FMENDEPSF
72 447.02 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "49" 61
%%Page: "50" 61
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(50) 318 55 T
1 11 Q
0.56 (tiate recovery together) 108 308.69 P
0.56 (. Unfortunately) 207.36 308.69 P
0.56 (, once a group of clients caravans this way) 274.33 308.69 P
0.56 (, the caravans do) 464.5 308.69 P
(not break up; after the next server crash, the same clients will initiate recovery together again.) 108 295.69 T
0.25 (This synchronization was caused by the implementation of the reboot detection mechanism. T) 118.8 270.69 P
0.25 (o) 534.51 270.69 P
-0.08 (detect when a server reboots, each client pings the server every 30 seconds, as described in section) 108 257.69 P
1.54 (3.1.1. While the server is still unavailable, the ping RPCs time out, because the server cannot) 108 244.69 P
0.41 (acknowledge them. But before the client\325) 108 231.69 P
0.41 (s RPC system actually considers the RPC to have timed) 291.28 231.69 P
0.34 (out, it re-issues it several times, in case the \336rst attempts failed due to a temporary network prob-) 108 218.69 P
0.41 (lem. In Sprite, the RPC is retried six times over the course of \336ve seconds. If any of the attempts) 108 205.69 P
-0.2 (receives a response from the server) 108 192.69 P
-0.2 (, this means the server is available and the RPC need not be fur-) 261.24 192.69 P
0.22 (ther retried. Because clients ping a crashed server every 30 seconds, and spend \336ve seconds ping-) 108 179.69 P
0.38 (ing it on each attempt, there is a one-sixth probability that a client will be in the midst of pinging) 108 166.69 P
0.14 (when the server \336nally becomes available and responds to the client. Because of this, one-sixth of) 108 153.69 P
0.44 (the clients are likely to detect the server reboot within the same second. This phenomenon is fur-) 108 140.69 P
(ther illustrated in Figure 3-9.) 108 127.69 T
-0.26 (Once a set of clients becomes synchronized this way) 118.8 102.69 P
-0.26 (, the group does not split up. This is because) 347.31 102.69 P
0.49 (clients reset their ping timers when they detect the server reboot. While the server remains avail-) 108 89.69 P
(Figure 3-6. Recovery storm in testbed setup.) 226.35 422.69 T
1 10 Q
0.47 (This \336gure illustrates the states clients pass through during a recovery storm. The X axis) 144 400.36 P
0.18 (shows time progressing. The Y axis gives the number of clients, using the same approach) 144 389.36 P
1.02 (as used in Figure 3-4. This recovery storm was measured in the testbed setup and took) 144 378.36 P
108 346.02 540 364.02 C
108 346.02 540 364.02 R
7 X
0 K
V
108 355.02 540 355.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(about 254 seconds to complete.) 144 367.36 T
108 448.02 540 720 C
108 448.02 540 708 C
0 12 2 347.5 242 344 245.49 152.5 453.51 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/newStorm.ps
%!PS-Adobe-2.0 EPSF-1.2
%%Title: newStorm.g
%%Creator: gr2ps (Gremlin to PostScript)
%%BoundingBox: 12 2 347.5 242
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Courier-Bold
%%Pages: 1
%%EndComments

gsave
%%EndProlog

1.000 setgray
newpath
    30 230 moveto
    40 230 lineto
    40 210 lineto
    40 210 lineto
    42.815 210 lineto
    42.815 190 lineto
    42.815 190 lineto
    61.565 190 lineto
    61.565 170 lineto
    61.565 170 lineto
    61.875 170 lineto
    61.875 150 lineto
    61.875 150 lineto
    65.315 150 lineto
    65.315 130 lineto
    65.315 130 lineto
    103.125 130 lineto
    103.125 90 lineto
    103.125 90 lineto
    105.625 90 lineto
    105.625 70 lineto
    105.625 70 lineto
    149.69 70 lineto
    149.69 50 lineto
    149.69 50 lineto
    158.125 50 lineto
    158.125 30 lineto
    158.125 30 lineto
    30 30 lineto
    30 230 lineto
closepath fill
0.8 setlinewidth
0 setgray
newpath
    30 230 moveto
    40 230 lineto
    40 210 lineto
    40 210 lineto
    42.815 210 lineto
    42.815 190 lineto
    42.815 190 lineto
    61.565 190 lineto
    61.565 170 lineto
    61.565 170 lineto
    61.875 170 lineto
    61.875 150 lineto
    61.875 150 lineto
    65.315 150 lineto
    65.315 130 lineto
    65.315 130 lineto
    103.125 130 lineto
    103.125 90 lineto
    103.125 90 lineto
    105.625 90 lineto
    105.625 70 lineto
    105.625 70 lineto
    149.69 70 lineto
    149.69 50 lineto
    149.69 50 lineto
    158.125 50 lineto
    158.125 30 lineto
    158.125 30 lineto
    30 30 lineto
    30 230 lineto
closepath stroke

0.700 setgray
newpath
    30 230 moveto
    54.065 230 lineto
    54.065 190 lineto
    80 190 lineto
    80.315 190 lineto
    80.315 170 lineto
    81.25 170 lineto
    81.25 150 lineto
    86.25 150 lineto
    86.25 130 lineto
    87.815 130 lineto
    100.94 130 lineto
    100.94 130 lineto
    123.75 130 lineto
    124.065 130 lineto
    124.065 110 lineto
    124.065 110 lineto
    124.375 110 lineto
    124.375 90 lineto
    124.375 90 lineto
    124.69 90 lineto
    126.25 70 lineto
    126.565 70 lineto
    150.94 70 lineto
    150.94 90 lineto
    150.94 90 lineto
    151.25 90 lineto
    190.625 90 lineto
    239.065 90 lineto
    239.065 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    240 90 lineto
    240 70 lineto
    240 70 lineto
    240.315 70 lineto
    248.75 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    249.375 70 lineto
    249.375 50 lineto
    249.375 50 lineto
    249.69 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    253.125 50 lineto
    253.125 70 lineto
    253.125 70 lineto
    253.44 70 lineto
    257.19 70 lineto
    257.5 70 lineto
    257.5 50 lineto
    259.065 50 lineto
    259.065 30 lineto
    259.375 30 lineto
    259.69 30 lineto
    259.69 50 lineto
    262.19 50 lineto
    262.19 50 lineto
    262.5 50 lineto
    262.5 70 lineto
    262.5 70 lineto
    264.69 70 lineto
    265 70 lineto
    265 90 lineto
    265 90 lineto
    265.94 90 lineto
    265.94 70 lineto
    267.815 70 lineto
    268.125 70 lineto
    268.125 50 lineto
    273.125 50 lineto
    273.44 50 lineto
    273.44 30 lineto
    273.44 30 lineto
    273.75 30 lineto
    287.815 30 lineto
    287.815 50 lineto
    287.815 50 lineto
    289.065 50 lineto
    289.065 70 lineto
    294.065 70 lineto
    294.375 70 lineto
    294.375 50 lineto
    294.375 50 lineto
    295.94 50 lineto
    295.94 70 lineto
    298.44 70 lineto
    298.75 70 lineto
    298.75 90 lineto
    298.75 90 lineto
    303.44 90 lineto
    303.75 90 lineto
    303.75 70 lineto
    303.75 70 lineto
    304.065 70 lineto
    305.625 70 lineto
    305.625 50 lineto
    305.625 50 lineto
    305.94 50 lineto
    306.565 50 lineto
    306.565 70 lineto
    306.875 70 lineto
    307.19 70 lineto
    307.19 50 lineto
    312.19 50 lineto
    312.5 50 lineto
    312.5 30 lineto
    344.065 30 lineto
    344.065 30 lineto
    344.375 30 lineto
    344.375 50 lineto
    344.375 50 lineto
    344.69 50 lineto
    344.69 50 lineto
    347.5 50 lineto
    347.5 30 lineto
    158.125 30 lineto
    158.125 30 lineto
    158.125 50 lineto
    149.69 50 lineto
    149.69 50 lineto
    149.69 70 lineto
    105.625 70 lineto
    105.625 70 lineto
    105.625 90 lineto
    103.125 90 lineto
    103.125 90 lineto
    103.125 130 lineto
    65.315 130 lineto
    65.315 130 lineto
    65.315 150 lineto
    61.875 150 lineto
    61.875 150 lineto
    61.875 170 lineto
    61.565 170 lineto
    61.565 170 lineto
    61.565 190 lineto
    42.815 190 lineto
    42.815 190 lineto
    42.815 210 lineto
    40 210 lineto
    40 210 lineto
    40 230 lineto
    30 230 lineto
closepath fill
0 setgray
newpath
    30 230 moveto
    54.065 230 lineto
    54.065 190 lineto
    80 190 lineto
    80.315 190 lineto
    80.315 170 lineto
    81.25 170 lineto
    81.25 150 lineto
    86.25 150 lineto
    86.25 130 lineto
    87.815 130 lineto
    100.94 130 lineto
    100.94 130 lineto
    123.75 130 lineto
    124.065 130 lineto
    124.065 110 lineto
    124.065 110 lineto
    124.375 110 lineto
    124.375 90 lineto
    124.375 90 lineto
    124.69 90 lineto
    126.25 70 lineto
    126.565 70 lineto
    150.94 70 lineto
    150.94 90 lineto
    150.94 90 lineto
    151.25 90 lineto
    190.625 90 lineto
    239.065 90 lineto
    239.065 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    240 90 lineto
    240 70 lineto
    240 70 lineto
    240.315 70 lineto
    248.75 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    249.375 70 lineto
    249.375 50 lineto
    249.375 50 lineto
    249.69 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    253.125 50 lineto
    253.125 70 lineto
    253.125 70 lineto
    253.44 70 lineto
    257.19 70 lineto
    257.5 70 lineto
    257.5 50 lineto
    259.065 50 lineto
    259.065 30 lineto
    259.375 30 lineto
    259.69 30 lineto
    259.69 50 lineto
    262.19 50 lineto
    262.19 50 lineto
    262.5 50 lineto
    262.5 70 lineto
    262.5 70 lineto
    264.69 70 lineto
    265 70 lineto
    265 90 lineto
    265 90 lineto
    265.94 90 lineto
    265.94 70 lineto
    267.815 70 lineto
    268.125 70 lineto
    268.125 50 lineto
    273.125 50 lineto
    273.44 50 lineto
    273.44 30 lineto
    273.44 30 lineto
    273.75 30 lineto
    287.815 30 lineto
    287.815 50 lineto
    287.815 50 lineto
    289.065 50 lineto
    289.065 70 lineto
    294.065 70 lineto
    294.375 70 lineto
    294.375 50 lineto
    294.375 50 lineto
    295.94 50 lineto
    295.94 70 lineto
    298.44 70 lineto
    298.75 70 lineto
    298.75 90 lineto
    298.75 90 lineto
    303.44 90 lineto
    303.75 90 lineto
    303.75 70 lineto
    303.75 70 lineto
    304.065 70 lineto
    305.625 70 lineto
    305.625 50 lineto
    305.625 50 lineto
    305.94 50 lineto
    306.565 50 lineto
    306.565 70 lineto
    306.875 70 lineto
    307.19 70 lineto
    307.19 50 lineto
    312.19 50 lineto
    312.5 50 lineto
    312.5 30 lineto
    344.065 30 lineto
    344.065 30 lineto
    344.375 30 lineto
    344.375 50 lineto
    344.375 50 lineto
    344.69 50 lineto
    344.69 50 lineto
    347.5 50 lineto
    347.5 30 lineto
    158.125 30 lineto
    158.125 30 lineto
    158.125 50 lineto
    149.69 50 lineto
    149.69 50 lineto
    149.69 70 lineto
    105.625 70 lineto
    105.625 70 lineto
    105.625 90 lineto
    103.125 90 lineto
    103.125 90 lineto
    103.125 130 lineto
    65.315 130 lineto
    65.315 130 lineto
    65.315 150 lineto
    61.875 150 lineto
    61.875 150 lineto
    61.875 170 lineto
    61.565 170 lineto
    61.565 170 lineto
    61.565 190 lineto
    42.815 190 lineto
    42.815 190 lineto
    42.815 210 lineto
    40 210 lineto
    40 210 lineto
    40 230 lineto
    30 230 lineto
closepath stroke

0.875 setgray
newpath
    30 230 moveto
    255.315 230 lineto
    255.625 230 lineto
    257.19 230 lineto
    257.5 230 lineto
    257.5 210 lineto
    257.815 210 lineto
    258.75 210 lineto
    259.065 210 lineto
    259.065 190 lineto
    259.065 190 lineto
    265.625 190 lineto
    265.625 190 lineto
    265.94 190 lineto
    265.94 170 lineto
    273.125 170 lineto
    273.125 170 lineto
    273.44 170 lineto
    273.44 150 lineto
    273.44 150 lineto
    294.065 150 lineto
    294.375 150 lineto
    294.375 130 lineto
    294.375 130 lineto
    294.69 130 lineto
    294.69 130 lineto
    295.315 130 lineto
    295.315 110 lineto
    303.75 110 lineto
    303.75 90 lineto
    303.75 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    306.565 90 lineto
    306.875 90 lineto
    306.875 90 lineto
    307.19 90 lineto
    307.19 70 lineto
    312.19 70 lineto
    312.5 70 lineto
    312.5 50 lineto
    347.5 50 lineto
    347.5 230 lineto
    347.5 50 lineto
    344.69 50 lineto
    344.69 50 lineto
    344.375 50 lineto
    344.375 50 lineto
    344.375 30 lineto
    344.065 30 lineto
    344.065 30 lineto
    312.5 30 lineto
    312.5 50 lineto
    312.19 50 lineto
    307.19 50 lineto
    307.19 70 lineto
    306.875 70 lineto
    306.565 70 lineto
    306.565 50 lineto
    305.94 50 lineto
    305.625 50 lineto
    305.625 50 lineto
    305.625 70 lineto
    304.065 70 lineto
    303.75 70 lineto
    303.75 70 lineto
    303.75 90 lineto
    303.44 90 lineto
    298.75 90 lineto
    298.75 90 lineto
    298.75 70 lineto
    298.44 70 lineto
    295.94 70 lineto
    295.94 50 lineto
    294.375 50 lineto
    294.375 50 lineto
    294.375 70 lineto
    294.065 70 lineto
    289.065 70 lineto
    289.065 50 lineto
    287.815 50 lineto
    287.815 50 lineto
    287.815 30 lineto
    273.75 30 lineto
    273.44 30 lineto
    273.44 30 lineto
    273.44 50 lineto
    273.125 50 lineto
    268.125 50 lineto
    268.125 70 lineto
    267.815 70 lineto
    265.94 70 lineto
    265.94 90 lineto
    265 90 lineto
    265 90 lineto
    265 70 lineto
    264.69 70 lineto
    262.5 70 lineto
    262.5 70 lineto
    262.5 50 lineto
    262.19 50 lineto
    262.19 50 lineto
    259.69 50 lineto
    259.69 30 lineto
    259.375 30 lineto
    259.065 30 lineto
    259.065 50 lineto
    257.5 50 lineto
    257.5 70 lineto
    257.19 70 lineto
    253.44 70 lineto
    253.125 70 lineto
    253.125 70 lineto
    253.125 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    249.69 50 lineto
    249.375 50 lineto
    249.375 50 lineto
    249.375 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    248.75 70 lineto
    240.315 70 lineto
    240 70 lineto
    240 70 lineto
    240 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.065 90 lineto
    239.065 90 lineto
    190.625 90 lineto
    151.25 90 lineto
    150.94 90 lineto
    150.94 90 lineto
    150.94 70 lineto
    126.565 70 lineto
    126.25 70 lineto
    124.69 90 lineto
    124.375 90 lineto
    124.375 90 lineto
    124.375 110 lineto
    124.065 110 lineto
    124.065 110 lineto
    124.065 130 lineto
    123.75 130 lineto
    100.94 130 lineto
    100.94 130 lineto
    87.815 130 lineto
    86.25 130 lineto
    86.25 150 lineto
    81.25 150 lineto
    81.25 170 lineto
    80.315 170 lineto
    80.315 190 lineto
    80 190 lineto
    54.065 190 lineto
    54.065 230 lineto
    30 230 lineto
closepath fill
0 setgray
newpath
    30 230 moveto
    255.315 230 lineto
    255.625 230 lineto
    257.19 230 lineto
    257.5 230 lineto
    257.5 210 lineto
    257.815 210 lineto
    258.75 210 lineto
    259.065 210 lineto
    259.065 190 lineto
    259.065 190 lineto
    265.625 190 lineto
    265.625 190 lineto
    265.94 190 lineto
    265.94 170 lineto
    273.125 170 lineto
    273.125 170 lineto
    273.44 170 lineto
    273.44 150 lineto
    273.44 150 lineto
    294.065 150 lineto
    294.375 150 lineto
    294.375 130 lineto
    294.375 130 lineto
    294.69 130 lineto
    294.69 130 lineto
    295.315 130 lineto
    295.315 110 lineto
    303.75 110 lineto
    303.75 90 lineto
    303.75 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    306.565 90 lineto
    306.875 90 lineto
    306.875 90 lineto
    307.19 90 lineto
    307.19 70 lineto
    312.19 70 lineto
    312.5 70 lineto
    312.5 50 lineto
    347.5 50 lineto
    347.5 230 lineto
    347.5 50 lineto
    344.69 50 lineto
    344.69 50 lineto
    344.375 50 lineto
    344.375 50 lineto
    344.375 30 lineto
    344.065 30 lineto
    344.065 30 lineto
    312.5 30 lineto
    312.5 50 lineto
    312.19 50 lineto
    307.19 50 lineto
    307.19 70 lineto
    306.875 70 lineto
    306.565 70 lineto
    306.565 50 lineto
    305.94 50 lineto
    305.625 50 lineto
    305.625 50 lineto
    305.625 70 lineto
    304.065 70 lineto
    303.75 70 lineto
    303.75 70 lineto
    303.75 90 lineto
    303.44 90 lineto
    298.75 90 lineto
    298.75 90 lineto
    298.75 70 lineto
    298.44 70 lineto
    295.94 70 lineto
    295.94 50 lineto
    294.375 50 lineto
    294.375 50 lineto
    294.375 70 lineto
    294.065 70 lineto
    289.065 70 lineto
    289.065 50 lineto
    287.815 50 lineto
    287.815 50 lineto
    287.815 30 lineto
    273.75 30 lineto
    273.44 30 lineto
    273.44 30 lineto
    273.44 50 lineto
    273.125 50 lineto
    268.125 50 lineto
    268.125 70 lineto
    267.815 70 lineto
    265.94 70 lineto
    265.94 90 lineto
    265 90 lineto
    265 90 lineto
    265 70 lineto
    264.69 70 lineto
    262.5 70 lineto
    262.5 70 lineto
    262.5 50 lineto
    262.19 50 lineto
    262.19 50 lineto
    259.69 50 lineto
    259.69 30 lineto
    259.375 30 lineto
    259.065 30 lineto
    259.065 50 lineto
    257.5 50 lineto
    257.5 70 lineto
    257.19 70 lineto
    253.44 70 lineto
    253.125 70 lineto
    253.125 70 lineto
    253.125 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    252.815 50 lineto
    249.69 50 lineto
    249.375 50 lineto
    249.375 50 lineto
    249.375 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    249.065 70 lineto
    248.75 70 lineto
    240.315 70 lineto
    240 70 lineto
    240 70 lineto
    240 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    239.69 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.375 90 lineto
    239.065 90 lineto
    239.065 90 lineto
    190.625 90 lineto
    151.25 90 lineto
    150.94 90 lineto
    150.94 90 lineto
    150.94 70 lineto
    126.565 70 lineto
    126.25 70 lineto
    124.69 90 lineto
    124.375 90 lineto
    124.375 90 lineto
    124.375 110 lineto
    124.065 110 lineto
    124.065 110 lineto
    124.065 130 lineto
    123.75 130 lineto
    100.94 130 lineto
    100.94 130 lineto
    87.815 130 lineto
    86.25 130 lineto
    86.25 150 lineto
    81.25 150 lineto
    81.25 170 lineto
    80.315 170 lineto
    80.315 190 lineto
    80 190 lineto
    54.065 190 lineto
    54.065 230 lineto
    30 230 lineto
closepath stroke

0.550 setgray
newpath
    30 230 moveto
    347.5 230 lineto
    347.5 30 lineto
    347.5 50 lineto
    312.5 50 lineto
    312.5 70 lineto
    312.19 70 lineto
    307.19 70 lineto
    307.19 90 lineto
    306.875 90 lineto
    306.875 90 lineto
    306.565 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    303.75 90 lineto
    303.75 90 lineto
    303.75 110 lineto
    295.315 110 lineto
    295.315 130 lineto
    294.69 130 lineto
    294.69 130 lineto
    294.375 130 lineto
    294.375 130 lineto
    294.375 150 lineto
    294.065 150 lineto
    273.44 150 lineto
    273.44 150 lineto
    273.44 170 lineto
    273.125 170 lineto
    273.125 170 lineto
    265.94 170 lineto
    265.94 190 lineto
    265.625 190 lineto
    265.625 190 lineto
    259.065 190 lineto
    259.065 190 lineto
    259.065 210 lineto
    258.75 210 lineto
    257.815 210 lineto
    257.5 210 lineto
    257.5 230 lineto
    257.19 230 lineto
    255.625 230 lineto
    255.315 230 lineto
    30 230 lineto
closepath fill
0 setgray
newpath
    30 230 moveto
    347.5 230 lineto
    347.5 30 lineto
    347.5 50 lineto
    312.5 50 lineto
    312.5 70 lineto
    312.19 70 lineto
    307.19 70 lineto
    307.19 90 lineto
    306.875 90 lineto
    306.875 90 lineto
    306.565 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    304.065 90 lineto
    303.75 90 lineto
    303.75 90 lineto
    303.75 110 lineto
    295.315 110 lineto
    295.315 130 lineto
    294.69 130 lineto
    294.69 130 lineto
    294.375 130 lineto
    294.375 130 lineto
    294.375 150 lineto
    294.065 150 lineto
    273.44 150 lineto
    273.44 150 lineto
    273.44 170 lineto
    273.125 170 lineto
    273.125 170 lineto
    265.94 170 lineto
    265.94 190 lineto
    265.625 190 lineto
    265.625 190 lineto
    259.065 190 lineto
    259.065 190 lineto
    259.065 210 lineto
    258.75 210 lineto
    257.815 210 lineto
    257.5 210 lineto
    257.5 230 lineto
    257.19 230 lineto
    255.625 230 lineto
    255.315 230 lineto
    30 230 lineto
closepath stroke

























































/Times-Roman findfont 10 scalefont setfont
330 15 moveto
0 1 rmoveto (250) show

274 15 moveto
0 1 rmoveto (200) show

212 15 moveto
0 1 rmoveto (150) show

150 15 moveto
0 1 rmoveto (100) show

90 15 moveto
0 1 rmoveto (50) show

30 15 moveto
0 1 rmoveto (0) show

21 27.5 moveto
(0) dup stringwidth pop -1 mul 1 rmoveto show

21 67.5 moveto
(2) dup stringwidth pop -1 mul 1 rmoveto show

21 107.5 moveto
(4) dup stringwidth pop -1 mul 1 rmoveto show

21 147.5 moveto
(6) dup stringwidth pop -1 mul 1 rmoveto show

21 187.5 moveto
(8) dup stringwidth pop -1 mul 1 rmoveto show

21 227.5 moveto
(10) dup stringwidth pop -1 mul 1 rmoveto show

62 76 moveto
0 1 rmoveto (unstarted) show

168 62 moveto
0 1 rmoveto (recovering) show

238 128 moveto
0 1 rmoveto (timing out) show

302 184 moveto
0 1 rmoveto (finished) show

140 2 moveto
0 1 rmoveto (Time in seconds) show

14 242 moveto
0 1 rmoveto (Number of clients) show





0.3 setlinewidth
newpath
    25 230 moveto
    30 230 lineto
stroke

newpath
    25 210 moveto
    30 210 lineto
stroke

newpath
    25 190 moveto
    30 190 lineto
stroke

newpath
    25 170 moveto
    30 170 lineto
stroke

newpath
    25 150 moveto
    30 150 lineto
stroke

newpath
    25 130 moveto
    30 130 lineto
stroke

newpath
    25 110 moveto
    30 110 lineto
stroke

newpath
    25 90 moveto
    30 90 lineto
stroke

newpath
    25 70 moveto
    30 70 lineto
stroke

newpath
    25 50 moveto
    30 50 lineto
stroke

newpath
    25 30 moveto
    30 30 lineto
stroke

newpath
    30 30 moveto
    30 25 lineto
stroke

newpath
    92.5 30 moveto
    92.5 25 lineto
stroke

newpath
    155 30 moveto
    155 25 lineto
stroke

newpath
    217.5 30 moveto
    217.5 25 lineto
stroke

newpath
    280 30 moveto
    280 25 lineto
stroke

newpath
    342.5 30 moveto
    342.5 25 lineto
stroke



















%%Trailer
grestore

%%EndDocument
FMENDEPSF
108 448.02 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "50" 62
%%Page: "51" 62
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(51) 282 55 T
1 11 Q
-0.04 (able, the pings are skipped, but they are still rescheduled at 30-second intervals. Because one sixth) 72 305.69 P
1.13 (of the clients detect the server reboot together) 72 292.69 P
1.13 (, one sixth of them set their timers to re-ping the) 280.57 292.69 P
0.98 (server together) 72 279.69 P
0.98 (. From this point on, the clients\325 reboot detection mechanism is synchronized, so) 137.96 279.69 P
0.28 (they will detect a server reboot simultaneously and will initiate recovery together) 72 266.69 P
0.28 (. Only rebooting) 431.12 266.69 P
(a client will desynchronize its ping timer) 72 253.69 T
(, until it again joins a caravan.) 250.99 253.69 T
0 12 Q
(3.4.4. Staggering Client Recovery Requests) 72 222.03 T
1 11 Q
0.95 (T) 82.8 196.69 P
0.95 (o \336x the synchronization problem it is necessary to stagger the clients\325 ping RPCs. An easy) 88.74 196.69 P
0.09 (way to do this is to set the client pings to occur at 30-second intervals after a random event, rather) 72 183.69 P
1.35 (than after the global event of the server reboot. I use a client\325) 72 170.69 P
1.35 (s own reboot time for the event.) 355.82 170.69 P
0.02 (While not really random, individual client reboots are well-enough staggered that it has solved the) 72 157.69 P
0.23 (synchronization problem, as seen in Figure 3-10. There are now no groups of more than three cli-) 72 144.69 P
0.1 (ents that detect the server reboot simultaneously) 72 131.69 P
0.1 (, so there are no more than three clients that begin) 283.64 131.69 P
(recovery within the same second.) 72 118.69 T
(Figure 3-7. Recovery with NACKS in testbed setup.) 173.11 419.69 T
1 10 Q
-0.02 (This \336gure illustrates the states clients pass through during recovery with a server that can) 108 397.36 P
0.21 (respond with negative acknowledgments. The X axis shows time progressing. The Y axis) 108 386.36 P
1.4 (gives the number of clients, using the same approach as was used in Figure 3-5. This) 108 375.36 P
72 343.02 504 361.02 C
72 343.02 504 361.02 R
7 X
0 K
V
72 352.02 504 352.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(recovery session was measured in the testbed setup and took 124 seconds to complete.) 108 364.36 T
72 445.02 504 720 C
72 445.02 504 708 C
0 12 2 347.5 242 344 247.49 117.5 451.51 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/newNacks.ps
%!PS-Adobe-2.0 EPSF-1.2
%%Title: newNacks.g
%%Creator: gr2ps (Gremlin to PostScript)
%%BoundingBox: 12 2 347.5 242
%%DocumentFonts: Times-Roman Times-Italic Times-Bold Courier-Bold
%%Pages: 1
%%EndComments

gsave
%%EndProlog



































0.550 setgray
newpath
    30 230 moveto
    185 230 lineto
    347.5 230 lineto
    347.5 30 lineto
    185 30 lineto
    185 50 lineto
    175.315 50 lineto
    175.315 70 lineto
    175 70 lineto
    159.69 70 lineto
    159.69 90 lineto
    159.375 90 lineto
    158.44 90 lineto
    158.44 110 lineto
    158.125 110 lineto
    156.25 110 lineto
    156.25 130 lineto
    74.375 130 lineto
    74.375 150 lineto
    73.44 150 lineto
    73.44 170 lineto
    60 170 lineto
    60 190 lineto
    59.69 190 lineto
    59.69 210 lineto
    59.375 210 lineto
    58.44 210 lineto
    58.44 230 lineto
    58.125 230 lineto
    30 230 lineto
closepath fill
0.8 setlinewidth
0 setgray
newpath
    30 230 moveto
    185 230 lineto
    347.5 230 lineto
    347.5 30 lineto
    185 30 lineto
    185 50 lineto
    175.315 50 lineto
    175.315 70 lineto
    175 70 lineto
    159.69 70 lineto
    159.69 90 lineto
    159.375 90 lineto
    158.44 90 lineto
    158.44 110 lineto
    158.125 110 lineto
    156.25 110 lineto
    156.25 130 lineto
    74.375 130 lineto
    74.375 150 lineto
    73.44 150 lineto
    73.44 170 lineto
    60 170 lineto
    60 190 lineto
    59.69 190 lineto
    59.69 210 lineto
    59.375 210 lineto
    58.44 210 lineto
    58.44 230 lineto
    58.125 230 lineto
    30 230 lineto
closepath stroke

0.700 setgray
newpath
    30 230 moveto
    58.125 230 lineto
    58.44 230 lineto
    58.44 210 lineto
    59.375 210 lineto
    59.69 210 lineto
    59.69 190 lineto
    60 190 lineto
    60 170 lineto
    73.125 170 lineto
    73.44 170 lineto
    73.44 150 lineto
    74.375 150 lineto
    74.375 130 lineto
    155.94 130 lineto
    156.25 130 lineto
    156.25 110 lineto
    158.44 110 lineto
    158.44 90 lineto
    159.375 90 lineto
    159.69 90 lineto
    159.69 70 lineto
    175.315 70 lineto
    175.315 50 lineto
    185 50 lineto
    185 30 lineto
    175 30 lineto
    175 50 lineto
    165.315 50 lineto
    165.315 70 lineto
    77.815 70 lineto
    77.815 90 lineto
    74.69 90 lineto
    74.69 110 lineto
    64.065 110 lineto
    64.065 130 lineto
    60.94 130 lineto
    60.94 130 lineto
    60.94 150 lineto
    59.065 150 lineto
    59.065 170 lineto
    46.875 170 lineto
    46.875 170 lineto
    46.875 190 lineto
    42.815 190 lineto
    42.815 190 lineto
    42.815 210 lineto
    40.315 210 lineto
    40.315 210 lineto
    40.315 230 lineto
    30 230 lineto
closepath fill
0 setgray
newpath
    30 230 moveto
    58.125 230 lineto
    58.44 230 lineto
    58.44 210 lineto
    59.375 210 lineto
    59.69 210 lineto
    59.69 190 lineto
    60 190 lineto
    60 170 lineto
    73.125 170 lineto
    73.44 170 lineto
    73.44 150 lineto
    74.375 150 lineto
    74.375 130 lineto
    155.94 130 lineto
    156.25 130 lineto
    156.25 110 lineto
    158.44 110 lineto
    158.44 90 lineto
    159.375 90 lineto
    159.69 90 lineto
    159.69 70 lineto
    175.315 70 lineto
    175.315 50 lineto
    185 50 lineto
    185 30 lineto
    175 30 lineto
    175 50 lineto
    165.315 50 lineto
    165.315 70 lineto
    77.815 70 lineto
    77.815 90 lineto
    74.69 90 lineto
    74.69 110 lineto
    64.065 110 lineto
    64.065 130 lineto
    60.94 130 lineto
    60.94 130 lineto
    60.94 150 lineto
    59.065 150 lineto
    59.065 170 lineto
    46.875 170 lineto
    46.875 170 lineto
    46.875 190 lineto
    42.815 190 lineto
    42.815 190 lineto
    42.815 210 lineto
    40.315 210 lineto
    40.315 210 lineto
    40.315 230 lineto
    30 230 lineto
closepath stroke

1.000 setgray
newpath
    30 230 moveto
    40.315 230 lineto
    40.315 210 lineto
    40.315 210 lineto
    42.815 210 lineto
    42.815 190 lineto
    42.815 190 lineto
    46.875 190 lineto
    46.875 170 lineto
    46.875 170 lineto
    59.065 170 lineto
    59.065 150 lineto
    60.94 150 lineto
    60.94 130 lineto
    60.94 130 lineto
    64.065 130 lineto
    64.065 110 lineto
    74.69 110 lineto
    74.69 90 lineto
    77.815 90 lineto
    77.815 70 lineto
    165.315 70 lineto
    165.315 50 lineto
    175 50 lineto
    175 30 lineto
    30 30 lineto
    30 230 lineto
closepath fill
0 setgray
newpath
    30 230 moveto
    40.315 230 lineto
    40.315 210 lineto
    40.315 210 lineto
    42.815 210 lineto
    42.815 190 lineto
    42.815 190 lineto
    46.875 190 lineto
    46.875 170 lineto
    46.875 170 lineto
    59.065 170 lineto
    59.065 150 lineto
    60.94 150 lineto
    60.94 130 lineto
    60.94 130 lineto
    64.065 130 lineto
    64.065 110 lineto
    74.69 110 lineto
    74.69 90 lineto
    77.815 90 lineto
    77.815 70 lineto
    165.315 70 lineto
    165.315 50 lineto
    175 50 lineto
    175 30 lineto
    30 30 lineto
    30 230 lineto
closepath stroke

/Times-Roman findfont 10 scalefont setfont
14 242 moveto
0 1 rmoveto (Number of clients) show

140 2 moveto
0 1 rmoveto (Time in seconds) show

218 180 moveto
0 1 rmoveto (finished) show

82 108 moveto
0 1 rmoveto (recovering) show

44 46 moveto
0 1 rmoveto (unstarted) show

21 227.5 moveto
(10) dup stringwidth pop -1 mul 1 rmoveto show

21 187.5 moveto
(8) dup stringwidth pop -1 mul 1 rmoveto show

21 147.5 moveto
(6) dup stringwidth pop -1 mul 1 rmoveto show

21 107.5 moveto
(4) dup stringwidth pop -1 mul 1 rmoveto show

21 67.5 moveto
(2) dup stringwidth pop -1 mul 1 rmoveto show

21 27.5 moveto
(0) dup stringwidth pop -1 mul 1 rmoveto show

30 15 moveto
0 1 rmoveto (0) show

90 15 moveto
0 1 rmoveto (50) show

150 15 moveto
0 1 rmoveto (100) show

212 15 moveto
0 1 rmoveto (150) show

274 15 moveto
0 1 rmoveto (200) show

330 15 moveto
0 1 rmoveto (250) show






































0.3 setlinewidth
newpath
    342.5 30 moveto
    342.5 25 lineto
stroke

newpath
    280 30 moveto
    280 25 lineto
stroke

newpath
    217.5 30 moveto
    217.5 25 lineto
stroke

newpath
    155 30 moveto
    155 25 lineto
stroke

newpath
    92.5 30 moveto
    92.5 25 lineto
stroke

newpath
    30 30 moveto
    30 25 lineto
stroke

newpath
    25 30 moveto
    30 30 lineto
stroke

newpath
    25 50 moveto
    30 50 lineto
stroke

newpath
    25 70 moveto
    30 70 lineto
stroke

newpath
    25 90 moveto
    30 90 lineto
stroke

newpath
    25 110 moveto
    30 110 lineto
stroke

newpath
    25 130 moveto
    30 130 lineto
stroke

newpath
    25 150 moveto
    30 150 lineto
stroke

newpath
    25 170 moveto
    30 170 lineto
stroke

newpath
    25 190 moveto
    30 190 lineto
stroke

newpath
    25 210 moveto
    30 210 lineto
stroke

newpath
    25 230 moveto
    30 230 lineto
stroke




%%Trailer
grestore

%%EndDocument
FMENDEPSF
72 445.02 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "51" 63
%%Page: "52" 63
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(52) 318 55 T
1 11 Q
0.19 (The combination of staggering client recovery and implementing negative acknowledgments in) 118.8 298.67 P
2.59 (the RPC system signi\336cantly improves recovery performance. In the old Sun-3 setup, these) 108 285.67 P
1.39 (improvements reduced client-driven recovery from many minutes to about two minutes. In the) 108 272.67 P
0.07 (testbed setup, negative acknowledgments alone reduced an arti\336cial recovery storm from 254 sec-) 108 259.67 P
(onds to 124 seconds.) 108 246.67 T
0.52 (Finally) 118.8 221.67 P
0.52 (, I include a further measurement as a base against which to compare later performance) 149.22 221.67 P
-0.06 (improvements in this chapter) 108 208.67 P
-0.06 (. This test uses the basic state setup in the testbed setup, with no extra) 235.07 208.67 P
1.76 (state to cause a recovery storm. The test also includes NACKS and staggered client recovery) 108 195.67 P
0.8 (attempts. W) 108 182.67 P
0.8 (ith this setup, client-driven recovery requires 25 seconds, on average. This measure-) 161.45 182.67 P
(ment was taken four times, with a standard deviation of 1.4 seconds.) 108 169.67 T
0 14 Q
(3.5. Other Performance Pr) 108 136.67 T
(oblems and Solutions) 267.44 136.67 T
1 11 Q
1.07 (Adding negative acknowledgments and staggering client recovery eliminates recovery storms) 118.8 110.67 P
-0.05 (by controlling server congestion, but there are two other performance problems I discovered while) 108 97.67 P
0.6 (examining client-driven recovery) 108 84.67 P
0.6 (. The \336rst is that it is easy to recover more state than necessary) 254.94 84.67 P
0.6 (.) 537.25 84.67 P
(Figure 3-8. Synchronization of client recovery) 221.07 434.67 T
(.) 424.18 434.67 T
1 10 Q
1.21 (This \336gure illustrates the grouping of client recovery attempts. The X axis shows time) 144 412.33 P
1.35 (through recovery) 144 401.33 P
1.35 (. The Y axis shows the number of clients initiating recovery with the) 213.25 401.33 P
0.43 (server during a one-second interval. For example, at 83 seconds 15 clients initiate recov-) 144 390.33 P
1.56 (ery) 144 379.33 P
1.56 (. Fifteen clients also initiate recovery at 84 seconds. Many clients initiate recovery) 156.11 379.33 P
0.65 (more than once, due to timing out during the recovery storm. This recovery session was) 144 368.33 P
108 336 540 354 C
108 336 540 354 R
7 X
0 K
V
108 345 540 345 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(measured in the old Sun-3 setup.) 144 357.33 T
108 460 540 720 C
108 460 540 708 C
0 0 0 539 539 297 241 180 463 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/old_num_recov.conv.short.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 539
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 8856 3 just-string
300 /Times-Roman choose-font
() 7821 7954 2 just-string
14 setlinewidth
[] 0 setdash
newpath
  7821 7986 moveto
  7821 7986 lineto
stroke
(Number of clients initiating recovery) 90 8496 2 just-string
(Seconds) 7821 480 1 just-string
(    0) 1245 820 5 just-string
(    2) 1245 1669 5 just-string
(    4) 1245 2519 5 just-string
(    6) 1245 3368 5 just-string
(    8) 1245 4218 5 just-string
(   10) 1245 5068 5 just-string
(   12) 1245 5917 5 just-string
(   14) 1245 6767 5 just-string
(   16) 1245 7616 5 just-string
(    0) 1626 90 7 just-string
(   50) 4269 90 7 just-string
(  100) 6912 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  1335 820 moveto
  1625 820 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 1669 moveto
  1625 1669 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 2519 moveto
  1625 2519 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 3368 moveto
  1625 3368 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 4218 moveto
  1625 4218 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 5068 moveto
  1625 5068 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 5917 moveto
  1625 5917 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 6767 moveto
  1625 6767 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 7616 moveto
  1625 7616 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1626 820 moveto
  1626 480 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4269 820 moveto
  4269 480 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6912 820 moveto
  6912 480 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1625 7617 moveto
  1625 820 lineto
  7440 820 lineto
  7440 7617 lineto
  1625 7617 lineto
stroke
14 setlinewidth
newpath
  1626 1245 moveto
  1626 1669 lineto
  1679 1669 lineto
  1679 1669 lineto
  1890 1669 lineto
  1890 2094 lineto
  1890 2094 lineto
  1890 2944 lineto
  1943 2944 lineto
  1943 1669 lineto
  2524 1669 lineto
  2524 1669 lineto
  2789 1669 lineto
  2789 1669 lineto
  3529 1669 lineto
  3529 1669 lineto
  3582 1669 lineto
  3582 1669 lineto
  4004 1669 lineto
  4004 1669 lineto
  4850 1669 lineto
  4850 2094 lineto
  4903 2094 lineto
  4903 1669 lineto
  5167 1669 lineto
  5167 1669 lineto
  6013 1669 lineto
  6013 7191 lineto
  6119 7191 lineto
  6119 2094 lineto
  6277 2094 lineto
  6277 1669 lineto
  6753 1669 lineto
  6753 1669 lineto
  7440 1669 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
108 460 540 720 C
108 460 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "52" 64
%%Page: "53" 64
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(53) 282 55 T
1 11 Q
0.62 (The second is that it is easy to recover the state using more RPCs than necessary) 72 205.69 P
0.62 (. Unfortunately) 434.22 205.69 P
0.62 (,) 501.25 205.69 P
-0.05 (these problems are likely to exist in any stateful system that uses a communication-based recovery) 72 192.69 P
1.54 (protocol. The following two sections describe how I\325ve modi\336ed Sprite\325) 72 179.69 P
1.54 (s recovery protocol to) 403.26 179.69 P
0.63 (reduce the amount of state recovered and the number of RPCs used. The third section shows the) 72 166.69 P
0.24 (performance improvement that results from these optimizations taken together; separate measure-) 72 153.69 P
1.07 (ments of the individual bene\336ts due to these optimizations are made in chapter 4, using server) 72 140.69 P
1.07 (-) 500.34 140.69 P
-0.09 (driven recovery) 72 127.69 P
-0.09 (. \050The optimizations apply equally well to server) 140.44 127.69 P
-0.09 (-driven recovery) 353.2 127.69 P
-0.09 (, and it is possible) 425.31 127.69 P
-0.21 (to gain more exact measurements using server) 72 114.69 P
-0.21 (-driven recovery; in client-driven recovery) 273.72 114.69 P
-0.21 (, there is a) 459.48 114.69 P
(high variability in times, because the server must wait for clients to contact it.\051) 72 101.69 T
(Figure 3-9. How client recovery becomes synchronized.) 164.74 396.69 T
1 10 Q
0.86 (This \336gure illustrates how the clients\325 server reboot detection mechanism becomes syn-) 108 374.36 P
0.14 (chronized over the course of two server reboots. The \336gure shows three clients, with time) 108 363.36 P
0.5 (progressing from left to right. T) 108 352.36 P
0.5 (ick marks indicate when a client is pinging the server) 237.3 352.36 P
0.5 (. In) 454.17 352.36 P
0.14 (the top half of the \336gure, the server is down, and the three clients all ping the server start-) 108 341.36 P
0.89 (ing at dif) 108 330.36 P
0.89 (ferent times. The server becomes available while both treason and poltroonery) 145.7 330.36 P
0.03 (are pinging it, so the two clients detect the server reboot at the same time and synchronize) 108 319.36 P
1.42 (their pings intervals. Single tick marks after the server is up indicate when the clients) 108 308.36 P
0.67 (would ping the server again if they needed to. For the second server reboot, treason and) 108 297.36 P
1.3 (poltroonery remain synchronized to ping the server at the same time. When the server) 108 286.36 P
0.83 (reboots, though, larceny is also pinging it, so all three clients become synchronized and) 108 275.36 P
72 243.02 504 261.02 C
72 243.02 504 261.02 R
7 X
0 K
V
72 252.02 504 252.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(will initiate recovery together) 108 264.36 T
(.) 225.98 264.36 T
72 422.02 504 720 C
72 422.02 504 708 C
279 523.5 279 433.5 2 L
3 H
2 Z
0 X
0 K
N
279 658.5 279 573 2 L
N
0 10 Q
(lar) 80.54 644.3 T
(ceny) 92.57 644.3 T
(tr) 80.54 617.1 T
(eason) 88.12 617.1 T
(poltr) 81 592 T
(oonery) 101.92 592 T
456.46 650.31 468 647 456.46 643.69 456.46 647 4 Y
V
135 647 456.46 647 2 L
0.5 H
N
456.46 623.31 468 620 456.46 616.69 456.46 620 4 Y
V
135 620 456.46 620 2 L
N
456.46 596.31 468 593 456.46 589.69 456.46 593 4 Y
V
135 593 456.46 593 2 L
N
(server down) 175.5 674.1 T
(server up) 337.75 674.3 T
333 676.5 283.5 676.5 2 L
1 H
N
456.46 679.81 468 676.5 456.46 673.19 456.46 676.5 4 Y
V
382.5 676.5 456.46 676.5 2 L
N
229.5 676.5 274.5 676.5 2 L
N
(lar) 82.54 503.3 T
(ceny) 94.57 503.3 T
(tr) 82.54 476.1 T
(eason) 90.12 476.1 T
(poltr) 83 451 T
(oonery) 103.92 451 T
458.46 509.31 470 506 458.46 502.69 458.46 506 4 Y
V
137 506 458.46 506 2 L
0.5 H
N
458.46 482.31 470 479 458.46 475.69 458.46 479 4 Y
V
137 479 458.46 479 2 L
N
458.46 455.31 470 452 458.46 448.69 458.46 452 4 Y
V
137 452 458.46 452 2 L
N
0 12 Q
(First server r) 80.31 690.96 T
(eboot:) 148.03 690.96 T
(Second server r) 81.81 551.46 T
(eboot:) 161.53 551.46 T
180 654 180 636 2 L
1 H
N
184.5 654 184.5 636 2 L
N
189 654 189 636 2 L
N
193.5 654 193.5 636 2 L
N
198 654 198 636 2 L
N
202.5 654 202.5 636 2 L
N
144 627 144 609 2 L
N
148.5 627 148.5 609 2 L
N
153 627 153 609 2 L
N
157.5 627 157.5 609 2 L
N
162 627 162 609 2 L
N
166.5 627 166.5 609 2 L
N
157.5 600 157.5 582 2 L
N
162 600 162 582 2 L
N
166.5 600 166.5 582 2 L
N
171 600 171 582 2 L
N
175.5 600 175.5 582 2 L
N
180 600 180 582 2 L
N
391.5 627 391.5 609 2 L
N
270 600 270 582 2 L
N
274.5 600 274.5 582 2 L
N
279 600 279 582 2 L
N
135 676.5 171 676.5 2 L
N
256.5 627 256.5 609 2 L
N
261 627 261 609 2 L
N
265.5 627 265.5 609 2 L
N
270 627 270 609 2 L
N
274.5 627 274.5 609 2 L
N
279 627 279 609 2 L
N
292.5 654 292.5 636 2 L
N
391.5 600 391.5 582 2 L
N
405 654 405 636 2 L
N
157.5 514.5 157.5 496.5 2 L
N
162 514.5 162 496.5 2 L
N
166.5 514.5 166.5 496.5 2 L
N
171 514.5 171 496.5 2 L
N
175.5 514.5 175.5 496.5 2 L
N
180 514.5 180 496.5 2 L
N
144 487.5 144 469.5 2 L
N
148.5 487.5 148.5 469.5 2 L
N
153 487.5 153 469.5 2 L
N
157.5 487.5 157.5 469.5 2 L
N
162 487.5 162 469.5 2 L
N
166.5 487.5 166.5 469.5 2 L
N
144 460.5 144 442.5 2 L
N
148.5 460.5 148.5 442.5 2 L
N
153 460.5 153 442.5 2 L
N
157.5 460.5 157.5 442.5 2 L
N
162 460.5 162 442.5 2 L
N
166.5 460.5 166.5 442.5 2 L
N
256.5 487.5 256.5 469.5 2 L
N
261 487.5 261 469.5 2 L
N
265.5 487.5 265.5 469.5 2 L
N
270 487.5 270 469.5 2 L
N
274.5 487.5 274.5 469.5 2 L
N
279 487.5 279 469.5 2 L
N
270 519 270 501 2 L
N
274.5 519 274.5 501 2 L
N
279 519 279 501 2 L
N
256.5 460.5 256.5 442.5 2 L
N
261 460.5 261 442.5 2 L
N
265.5 460.5 265.5 442.5 2 L
N
270 460.5 270 442.5 2 L
N
274.5 460.5 274.5 442.5 2 L
N
279 460.5 279 442.5 2 L
N
391.5 519 391.5 501 2 L
N
391.5 487.5 391.5 469.5 2 L
N
391.5 460.5 391.5 442.5 2 L
N
0 10 Q
(server down) 175.5 534.6 T
(server up) 337.75 534.8 T
333 537 283.5 537 2 L
N
456.46 540.31 468 537 456.46 533.69 456.46 537 4 Y
V
382.5 537 456.46 537 2 L
N
229.5 537 274.5 537 2 L
N
135 537 171 537 2 L
N
72 422.02 504 720 C
72 422.02 504 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "53" 65
%%Page: "54" 65
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(54) 318 55 T
0 F
(3.5.1. Eliminating Unnecessary State Recovery) 108 301 T
1 11 Q
0.38 (Sprite clients tend to recover more state than needed. Redundant state on the clients and server) 118.8 275.67 P
0.16 (is useful for recovery) 108 262.67 P
0.16 (, but too much state is not, because it takes extra time to recover) 201.43 262.67 P
0.16 (. It is impor-) 484.58 262.67 P
(tant to optimize the amount and type of state recovered in a stateful system.) 108 249.67 T
-0.07 (For simplicity) 118.8 224.67 P
-0.07 (, Sprite clients reopen all their handles and streams. This includes handles for \336les) 179.98 224.67 P
0.49 (that are neither open nor have cached dirty blocks. But to guarantee cache consistency the server) 108 211.67 P
0.06 (only needs to know about \336les that are currently open or that currently have dirty data located in a) 108 198.67 P
0.3 (client cache. If an unopen \336le merely has clean data in a client cache, the client will \336nd out with) 108 185.67 P
-0.17 (its next open request whether or not its cached blocks are stale, so there is no need to tell the server) 108 172.67 P
0.62 (about such a \336le. As shown in section 3.2, eliminating this extra state from recovery reduces the) 108 159.67 P
(information recovered to about one-fourth its previous amount.) 108 146.67 T
(Figure 3-10. Staggered client recovery) 238.32 437.67 T
(.) 406.94 437.67 T
1 10 Q
0.39 (This \336gure illustrates the grouping of client recovery attempts after staggering the client-) 144 415.33 P
0.78 (to-server ping RPC timing. The X axis shows time through recovery) 144 404.33 P
0.78 (. The Y axis shows) 424.56 404.33 P
0.15 (the number of clients initiating recovery with the server during a one-second interval. For) 144 393.33 P
-0.04 (example, at 14 seconds, three clients initiate recovery) 144 382.33 P
-0.04 (. Some clients initiate recovery more) 357.08 382.33 P
0.69 (than once, due to timing out during the recovery storm. This recovery session was mea-) 144 371.33 P
108 339 540 357 C
108 339 540 357 R
7 X
0 K
V
108 348 540 348 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(sured in the old Sun-3 setup.) 144 360.33 T
108 463 540 720 C
108 463 540 708 C
0 0 0 539 539 297 239 180 466 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/latest_num_recov.conv.short.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 539
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 8856 3 just-string
300 /Times-Roman choose-font
() 7821 7954 2 just-string
14 setlinewidth
[] 0 setdash
newpath
  7821 7986 moveto
  7821 7986 lineto
stroke
(Number of clients initiating recovery) 90 8496 2 just-string
(Seconds) 7821 480 1 just-string
(    0) 1245 820 5 just-string
(    2) 1245 1669 5 just-string
(    4) 1245 2519 5 just-string
(    6) 1245 3368 5 just-string
(    8) 1245 4218 5 just-string
(   10) 1245 5068 5 just-string
(   12) 1245 5917 5 just-string
(   14) 1245 6767 5 just-string
(   16) 1245 7616 5 just-string
(    0) 1626 90 7 just-string
(   50) 4269 90 7 just-string
(  100) 6912 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  1335 820 moveto
  1625 820 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 1669 moveto
  1625 1669 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 2519 moveto
  1625 2519 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 3368 moveto
  1625 3368 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 4218 moveto
  1625 4218 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 5068 moveto
  1625 5068 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 5917 moveto
  1625 5917 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 6767 moveto
  1625 6767 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1335 7616 moveto
  1625 7616 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1626 820 moveto
  1626 480 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4269 820 moveto
  4269 480 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6912 820 moveto
  6912 480 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1625 7617 moveto
  1625 820 lineto
  7440 820 lineto
  7440 7617 lineto
  1625 7617 lineto
stroke
14 setlinewidth
newpath
  1626 820 moveto
  1626 1245 lineto
  1679 1245 lineto
  1679 1245 lineto
  1731 1245 lineto
  1731 1245 lineto
  1784 1245 lineto
  1784 1245 lineto
  1837 1245 lineto
  1837 1669 lineto
  1890 1669 lineto
  1890 1245 lineto
  1996 1245 lineto
  1996 1245 lineto
  2101 1245 lineto
  2101 1245 lineto
  2260 1245 lineto
  2260 1669 lineto
  2366 1669 lineto
  2366 2094 lineto
  2419 2094 lineto
  2419 1245 lineto
  2471 1245 lineto
  2471 1669 lineto
  2524 1669 lineto
  2524 1245 lineto
  2577 1245 lineto
  2577 1245 lineto
  2630 1245 lineto
  2630 1245 lineto
  2683 1245 lineto
  2683 1669 lineto
  2736 1669 lineto
  2736 1669 lineto
  2789 1669 lineto
  2789 1245 lineto
  2841 1245 lineto
  2841 1669 lineto
  2894 1669 lineto
  2894 1245 lineto
  2947 1245 lineto
  2947 1245 lineto
  3159 1245 lineto
  3159 1245 lineto
  3317 1245 lineto
  3317 1669 lineto
  3370 1669 lineto
  3370 1245 lineto
  4057 1245 lineto
  4057 1245 lineto
  4269 1245 lineto
  4269 1245 lineto
  5220 1245 lineto
  5220 1669 lineto
  6225 1669 lineto
  6225 1245 lineto
  7440 1245 lineto
  7440 820 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
108 463 540 720 C
108 463 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "54" 66
%%Page: "55" 66
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(55) 282 55 T
0 F
(3.5.2. Batching Reopens) 72 712 T
1 11 Q
0.23 (A further optimization of the recovery protocol decreases the number of reopen RPCs by pack-) 82.8 686.67 P
-0.27 (ing many reopen requests into a single RPC. This reduces the overhead from extra communication.) 72 673.67 P
0.59 (Clients originally executed one reopen RPC per handle or stream to recover) 72 660.67 P
0.59 (. However) 410.82 660.67 P
0.59 (, given the) 456.73 660.67 P
0.14 (maximum size of a single handle\325) 72 647.67 P
0.14 (s or stream\325) 220.68 647.67 P
0.14 (s state information \05052 bytes\051 and the maximum size) 272.22 647.67 P
0.23 (of a Sprite RPC packet \05016 kilobytes\051, we can batch about 300 reopen requests into a single RPC.) 72 634.67 P
(Thus, it is only necessary to do 1/300 the number of RPCs for client-driven recovery) 72 621.67 T
(.) 443.25 621.67 T
-0.06 (T) 82.8 596.67 P
-0.06 (o batch together the reopen requests, the client collects the state information for all the handles) 88.74 596.67 P
0.52 (or streams that \336t in an RPC packet and sends the request to the server) 72 583.67 P
0.52 (. Because the client opens) 388.11 583.67 P
0.15 (I/O handles and streams in two separate steps, this necessitates at least two RPCs. The server iter-) 72 570.67 P
-0.15 (ates through the list of handles or streams, performing the same processing per item as it did previ-) 72 557.67 P
0.6 (ously) 72 544.67 P
0.6 (. It records the success or failure of the reopen for each item in an array of results. When it) 95.09 544.67 P
0.11 (\336nishes processing the reopen request, the server returns this array of results to the client. The cli-) 72 531.67 P
0.04 (ent then iterates through the array of results and updates its handle or stream information to re\337ect) 72 518.67 P
(the status of each reopen request.) 72 505.67 T
-0.09 (T) 82.8 480.67 P
-0.09 (wo additional RPCs are necessary) 88.74 480.67 P
-0.09 (, per client, for a total of at least four RPCs. Each client must) 237.2 480.67 P
-0.04 (reopen the pre\336x for the \336le system served by the recovering server) 72 467.67 P
-0.04 (. Finally) 367.88 467.67 P
-0.04 (, each client also sends) 403.76 467.67 P
(an) 72 454.67 T
2 F
(end r) 85.12 454.67 T
(ecovery) 107.6 454.67 T
1 F
( RPC to signal to the server that it has reopened all its state.) 141.75 454.67 T
0 12 Q
(3.5.3. Basic Client-Driven Recovery Performance) 72 423 T
1 11 Q
-0.27 (Combining all of the improvements to client-driven recovery discussed in this chapter \050NACKS,) 82.8 397.67 P
4.21 (staggered client recovery requests, reopening less state information, and batching reopen) 72 384.67 P
0.19 (requests\051, reduces client-driven recovery times in the testbed network with the basic state setup to) 72 371.67 P
0.68 (an average of 21 seconds. This test was run four times with a standard deviation of 1.4 seconds.) 72 358.67 P
0.95 (This result shows an average improvement of about four seconds when compared to the test on) 72 345.67 P
(page 52 that used only NACKS and staggered client recovery requests.) 72 332.67 T
-0.16 (I call this measurement the) 82.8 307.67 P
2 F
-0.16 (basic client-driven r) 203.13 307.67 P
-0.16 (ecovery measur) 291.51 307.67 P
-0.16 (ement) 360.19 307.67 P
1 F
-0.16 (, because I compare it with) 386.42 307.67 P
1.2 (the results of other recovery techniques in later chapters. The later measurements use the same) 72 294.67 P
0.06 (testbed and basic state setup and also include the recovery improvements due to NACKS, reduced) 72 281.67 P
(state information and batched reopen requests.) 72 268.67 T
0.7 (However) 82.8 243.67 P
0.7 (, this basic client-driven recovery time can vary signi\336cantly) 122.62 243.67 P
0.7 (. While staggering client) 393.88 243.67 P
0.58 (pings helps reduce server congestion, it also allows for a high variation in client-driven recovery) 72 230.67 P
1.32 (times, because clients ping the server at dif) 72 217.67 P
1.32 (ferent times over a 30-second interval. Thus client-) 270.21 217.67 P
(driven recovery can easily take 30 seconds.) 72 204.67 T
0.83 (Because the server must wait for clients to detect its reboot and recover their state, the server) 82.8 179.67 P
0.62 (spends most of its recovery time idle, waiting for clients to send it their state. Out of the 21 sec-) 72 166.67 P
0.88 (onds for this basic client-driven measurement, the server) 72 153.67 P
0.88 (\325) 327.57 153.67 P
0.88 (s CPU is idle 87% of the time, and its) 330.63 153.67 P
(disk is idle 93% of the time.) 72 140.67 T
FMENDPAGE
%%EndPage: "55" 67
%%Page: "56" 67
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(56) 318 55 T
0 14 Q
(3.6. Other Client-Driven Recovery Pr) 108 710.67 T
(oblems) 331.57 710.67 T
1 11 Q
1.37 (The preceding sections describe problems that are solvable within the client-driven recovery) 118.8 684.67 P
-0.13 (approach, but this section turns to two problems that are not: cache consistency violations and lim-) 108 671.67 P
(ited recovery speed.) 108 658.67 T
0 12 Q
(3.6.1. Cache Consistency V) 108 627 T
(iolations) 245.47 627 T
1 11 Q
1.15 (Client-driven recovery allows cache consistency violations to occur during recovery) 118.8 601.67 P
1.15 (, because) 498.58 601.67 P
-0.18 (the server does not know when recovery is over) 108 588.67 P
-0.18 (. The server knows that an individual client has \336n-) 315.84 588.67 P
0.04 (ished recovering when it receives the client\325) 108 575.67 P
0.04 (s) 301.68 575.67 P
2 F
0.04 (end r) 308.74 575.67 P
0.04 (ecovery) 331.26 575.67 P
1 F
0.04 ( RPC, but it does not know what clients) 365.41 575.67 P
0.28 (must recover with it to consider system-wide recovery complete. The server must allow clients to) 108 562.67 P
0.05 (continue their normal activities at some point, even if other clients have yet to recover) 108 549.67 P
0.05 (. If this hap-) 486.15 549.67 P
-0 (pens, one client may \336nish recovery before others and may open and read a \336le that is cached on a) 108 536.67 P
0.65 (slower client. If the slower client still has dirty data for the \336le in its cache, the faster client will) 108 523.67 P
-0.18 (read stale data from its cache or the server) 108 510.67 P
-0.18 (\325) 292.43 510.67 P
-0.18 (s. If the faster client closes the \336le before the slower cli-) 295.48 510.67 P
(ent recovers, the cache consistency violation will not be detected in time to signal the error) 108 497.67 T
(.) 506.5 497.67 T
0.29 (It is also possible for a cache consistency violation to cause data loss. A slow client will not be) 118.8 472.67 P
0.01 (allowed to write back dirty data for a \336le that another client is already using. When the slow client) 108 459.67 P
0.85 (contacts the server for recovery) 108 446.67 P
0.85 (, it will receive an error message. After a reboot of the main \336le) 249.18 446.67 P
1.35 (server in Sprite, there are usually between zero and \336ve cache consistency violations, with the) 108 433.67 P
(average number being one.) 108 420.67 T
0.37 (Interestingly) 118.8 395.67 P
0.37 (, as client-driven recovery has gotten faster in Sprite, the average number of cache) 173.62 395.67 P
0.72 (consistency violations due to recovery appears to have increased. I speculate that this is because) 108 382.67 P
0.24 (adding negative acknowledgments, staggering recovery requests, and batching reopens has serial-) 108 369.67 P
0.57 (ized client recovery somewhat. It is now more likely for one client to \336nish recovery completely) 108 356.67 P
(and begin other operations before another client begins recovery) 108 343.67 T
(.) 390.42 343.67 T
-0.25 (There are two ways to address the cache consistency problem. The \336rst is to give the server a list) 118.8 318.67 P
0.6 (of clients with which it must recover) 108 305.67 P
0.6 (. After all the clients on this list recover with the server) 272.09 305.67 P
0.6 (, the) 520.48 305.67 P
0.08 (server knows it is okay to allow clients to resume normal processing. This list must be kept in sta-) 108 292.67 P
0.79 (ble storage so that it is not lost across server failures. This technique is a modi\336cation of client-) 108 279.67 P
(driven recovery and is discussed in the following chapter on server) 108 266.67 T
(-driven recovery) 401.91 266.67 T
(.) 474.1 266.67 T
0.5 (The second solution is for the server to block all \336le requests, except those for recovery) 118.8 241.67 P
0.5 (, for at) 510.02 241.67 P
0.19 (least the length of a ping interval. Since clients ping the server every 30 seconds, all available cli-) 108 228.67 P
0.43 (ents should have contacted the server during the 30 seconds. The server can wait until all the cli-) 108 215.67 P
0.19 (ents that contact it during that time \336nish recovery) 108 202.67 P
0.19 (. At this point it knows that it has completed its) 330.31 202.67 P
(distributed state and can allow clients to carry on with their normal processing.) 108 189.67 T
0.31 (The problem with the second approach is that it guarantees that state recovery will always take) 118.8 164.67 P
0.09 (at least 30 seconds. Despite the extra time required by this approach, this is how the DEcorum \336le) 108 151.67 P
0.81 (system \050described in chapter 2\051 currently avoids cache consistency violations in its client-driven) 108 138.67 P
0.94 (recovery implementation [Kazar93]. But given our desire to provide very fast recovery times in) 108 125.67 P
1.56 (Sprite, I chose to discard this solution and opted instead to try server) 108 112.67 P
1.56 (-driven \050and transparent\051) 427.67 112.67 P
(recovery) 108 99.67 T
(.) 145.72 99.67 T
FMENDPAGE
%%EndPage: "56" 68
%%Page: "57" 68
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(57) 282 55 T
72 666 504 720 C
72 666 504 720 R
7 X
0 K
V
72 693 504 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
72 594 504 648 C
72 594 504 648 R
7 X
0 K
V
72 603 504 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(4) 108 638 T
0 18 Q
(Server) 144 654 T
(-Driven Recovery) 194.28 654 T
1 11 Q
-0.01 (This chapter describes server) 82.8 519.67 P
-0.01 (-driven recovery) 210.38 519.67 P
-0.01 (, a modi\336cation of client-driven recovery in which) 282.56 519.67 P
-0.04 (the server initiates and controls distributed cache state recovery) 72 506.67 P
-0.04 (. Rather than wait for clients to ini-) 349.86 506.67 P
0.28 (tiate recovery) 72 493.67 P
0.28 (, the server keeps track of its active clients and initiates recovery with them. Server) 131.67 493.67 P
0.28 (-) 500.34 493.67 P
0.75 (driven recovery eliminates cache consistency violations, is faster) 72 480.67 P
0.75 (, and permits more control over) 361.75 480.67 P
0.46 (server congestion and the order of client recovery) 72 467.67 P
0.46 (. Compared to the basic measurement of client-) 292.66 467.67 P
0.28 (driven recovery in chapter 3, server) 72 454.67 P
0.28 (-driven recovery in the testbed setup takes only about 2.0 sec-) 229.36 454.67 P
0.36 (onds rather than 21. The recovery time scales linearly with the number of clients; each additional) 72 441.67 P
-0.2 (client adds 130 milliseconds. The server spends this additional time per client fetching \336le descrip-) 72 428.67 P
0.43 (tors for the state reopened. Disk I/O is the limiting performance factor for server) 72 415.67 P
0.43 (-driven recovery) 430.67 415.67 P
(in Sprite.) 72 402.67 T
0.79 (The key element of server) 82.8 377.67 P
0.79 (-driven recovery is a list of active clients kept on the \336le server) 200.43 377.67 P
0.79 (. T) 486.28 377.67 P
0.79 (o) 498.51 377.67 P
-0.21 (avoid the cache consistency violations suf) 72 364.67 P
-0.21 (fered by client-driven recovery) 255.34 364.67 P
-0.21 (, the server needs to know) 390.35 364.67 P
1.6 (when its clients have \336nished recovering. W) 72 351.67 P
1.6 (ith this knowledge, the server can wait until after) 276.11 351.67 P
-0.12 (recovery to process new client requests that would change the distributed cache state. When all the) 72 338.67 P
(clients on its list have \336nished recovering, the server knows that recovery is done.) 72 325.67 T
0.55 (Server) 82.8 300.67 P
0.55 (-driven recovery has two further advantages over client-driven recovery: it is faster) 111.25 300.67 P
0.55 (, and) 482.09 300.67 P
0.17 (the server has more control over recovery) 72 287.67 P
0.17 (. It is faster) 255.32 287.67 P
0.17 (, because the server does not need to wait for) 304.81 287.67 P
0.03 (the clients to detect its reboot. It can initiate recovery with all of them when it chooses. The server) 72 274.67 P
0.14 (has more control over its recovery load, because it can decide to recover with a limited number of) 72 261.67 P
-0.27 (clients at a time. It can even choose the order of clients for recovery) 72 248.67 P
-0.27 (, which allows it to recover \336rst) 366.17 248.67 P
0.15 (with other \336le servers. This is helpful, because one \336le server can depend on resources on another) 72 235.67 P
-0.11 (\336le server) 72 222.67 P
-0.11 (. For example, in Sprite the root of the entire \336le system is served by only one \336le server) 114.91 222.67 P
-0.11 (,) 501.25 222.67 P
0.24 (so all other hosts in the system are clients of this server) 72 209.67 P
0.24 (. If the root server fails, some activities on) 316.59 209.67 P
0.66 (these other servers will hang until the root server recovers. W) 72 196.67 P
0.66 (ith server) 348.82 196.67 P
0.66 (-driven recovery) 390.45 196.67 P
0.66 (, the root) 463.31 196.67 P
(server can recover \336rst with the other servers, freeing up their resources more quickly) 72 183.67 T
(.) 447.77 183.67 T
-0.27 (These combined advantages are likely to make server) 82.8 158.67 P
-0.27 (-driven recovery the distributed cache state) 315.9 158.67 P
0.2 (recovery technique of choice for many systems. For example, Spritely NFS [Mogul92] [Sriniv89]) 72 145.67 P
(has chosen to implement server) 72 132.67 T
(-driven recovery) 210.31 132.67 T
(, as described in chapter 2.) 282.5 132.67 T
0.96 (This chapter has the following or) 82.8 107.67 P
0.96 (ganization. The \336rst section describes the design and imple-) 232.96 107.67 P
1.04 (mentation of server) 72 94.67 P
1.04 (-driven recovery) 159.29 94.67 P
1.04 (. Section 4.2 lists some disadvantages of this recovery tech-) 232.52 94.67 P
FMENDPAGE
%%EndPage: "57" 69
%%Page: "58" 69
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(58) 318 55 T
1 11 Q
0.67 (nique as compared to client-driven recovery) 108 712.67 P
0.67 (. For example, it requires more special-purpose code) 304.36 712.67 P
0.25 (and necessitates trickier synchronization and locking in the kernel. Section 4.3 gives performance) 108 699.67 P
-0.01 (measurements. These include timings of server) 108 686.67 P
-0.01 (-driven recovery and levels of server resource utili-) 314.61 686.67 P
0.5 (zation across varying numbers of clients to show how recovery will scale to a lar) 108 673.67 P
0.5 (ger system than) 470.03 673.67 P
2.8 (the testbed setup. Finally) 108 660.67 P
2.8 (, I measured the individual bene\336ts of two recovery optimizations) 225.54 660.67 P
-0.26 (described in the previous chapter: recovering only necessary state information and batching reopen) 108 647.67 P
(requests.) 108 634.67 T
0 14 Q
(4.1. Design and Implementation) 108 601.67 T
1 11 Q
0.08 (There were several issues involved in the design and implementation of server) 118.8 575.67 P
0.08 (-driven recovery:) 463.96 575.67 P
0.77 (where to store the active client list, how to update it, and how to make sure it is not lost or cor-) 108 562.67 P
0.19 (rupted. Where there are choices for resolving these issues, I opted for the simplest design if it had) 108 549.67 P
0.43 (no signi\336cant performance penalties. In particular) 108 536.67 P
0.43 (, I made as few modi\336cations to Sprite\325) 328.77 536.67 P
0.43 (s client-) 504.48 536.67 P
(driven recovery as possible.) 108 523.67 T
0 12 Q
(4.1.1. Performance Impact of Client List Updates) 108 492 T
1 11 Q
0.52 (The \336rst design issue is where to store the client list for good reliability and performance. The) 118.8 466.67 P
0.68 (list could be stored in the server) 108 453.67 P
0.68 (\325) 252.86 453.67 P
0.68 (s main memory and preserved across failures using a technique) 255.91 453.67 P
0.12 (such as the recovery box, described in chapter 5. Storing the list in main memory would allow the) 108 440.67 P
-0.11 (fastest possible list access, but would require care to prevent corruption or loss of the data during a) 108 427.67 P
-0.13 (failure. Alternatively) 108 414.67 P
-0.13 (, the list could be stored solely on the server) 199.3 414.67 P
-0.13 (\325) 391.99 414.67 P
-0.13 (s disk. This is the easiest place to) 395.05 414.67 P
0.38 (preserve the list across server failures, but it would be too slow if a disk I/O is required for every) 108 401.67 P
0.01 (list access. If the only copy of the list were on disk, the server would have to read the disk on each) 108 388.67 P
(RPC from a client to see if the client is already on the list or should be added to the list.) 108 375.67 T
0.7 ( Instead, I chose to store the list in both places: the copy in memory provides fast read access) 118.8 350.67 P
-0.03 (while the copy on disk survives failures. W) 108 337.67 P
-0.03 (ith this solution, the server reads the list from disk only) 297.73 337.67 P
-0.07 (once, after a failure, and all further read accesses use the copy in memory) 108 324.67 P
-0.07 (. This avoids overhead in) 429.5 324.67 P
-0.21 (the normal case where the client is already on the list. Keeping this main-memory copy requires no) 108 311.67 P
1 (extra complexity) 108 298.67 P
1 (, because servers and clients already maintain such main-memory host list data) 182.43 298.67 P
0.93 (structures for crash and reboot detection \050as described in chapter 3\051. I just make use of the data) 108 285.67 P
(structures already present.) 108 272.67 T
0.06 (However) 118.8 247.67 P
0.06 (, disk writes are still necessary whenever the server must update the list. There are two) 158.62 247.67 P
-0.24 (cases when the server updates the client list. In the \336rst case, the server should remove from the list) 108 234.67 P
-0.24 (any client that crashes. This prevents the server from leaving dead clients on the list. This is impor-) 108 221.67 P
-0.17 (tant, because the server would otherwise contact the dead clients for recovery) 108 208.67 P
-0.17 (. Contacting dead cli-) 445.91 208.67 P
-0.14 (ents slows recovery) 108 195.67 P
-0.14 (, since the server RPC to the dead client to initiate recovery will take about \336ve) 193.65 195.67 P
0.64 (seconds to time out. Fortunately) 108 182.67 P
0.64 (, the overhead of the disk I/O to delete a client does not hurt the) 251.16 182.67 P
(client, because it only occurs when the client has crashed.) 108 169.67 T
0.69 (In the second case, the server must add a client to the list the \336rst time it issues a request that) 118.8 144.67 P
0.54 (would change the distributed cache or \336le system state. The server only needs to add a client the) 108 131.67 P
-0.1 (\336rst time it contacts the server with such a request, because subsequent contacts will \336nd the client) 108 118.67 P
0.27 (on the list. The \336rst request from a client that changes this state is likely to be an open request, or) 108 105.67 P
1.17 (perhaps a delete or create. In practice, though, it is acceptable to add the client the \336rst time it) 108 92.67 P
FMENDPAGE
%%EndPage: "58" 70
%%Page: "59" 70
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(59) 282 55 T
1 11 Q
0.66 (sends any RPC request to the server) 72 712.67 P
0.66 (. This is because a client that contacts the server for the \336rst) 233.4 712.67 P
(time with any RPC is likely to follow that with a request that af) 72 699.67 T
(fects the distributed state.) 350.43 699.67 T
0.98 (In this case, unfortunately) 82.8 674.67 P
0.98 (, the extra disk I/O will impact the client, by slowing down its \336rst) 199.15 674.67 P
-0.12 (RPC to the server) 72 661.67 P
-0.12 (. This \336rst RPC suf) 148.86 661.67 P
-0.12 (fers the extra latency of a disk I/O, which makes it an order of) 232.75 661.67 P
-0.21 (magnitude longer than it would otherwise be \050tens of milliseconds, depending on the type of server) 72 648.67 P
0.62 (disk\051. The server must complete the I/O before it responds to the RPC to ensure that it knows to) 72 635.67 P
-0.16 (recover with the client in the event that it crashes right after responding. This is important, because) 72 622.67 P
0.29 (the client\325) 72 609.67 P
0.29 (s \336rst RPC may cause a state change. If the server does not contact the client for recov-) 115.92 609.67 P
-0.06 (ery) 72 596.67 P
-0.06 (, it will not recover the new state. If this I/O overhead on the client is a problem for some appli-) 85.32 596.67 P
1.48 (cation, it should be possible to pre-contact the server) 72 583.67 P
1.48 (, so that the client will already be on the) 314.96 583.67 P
(server) 72 570.67 T
(\325) 99.25 570.67 T
(s list before the application runs.) 102.3 570.67 T
-0.06 (Luckily) 82.8 545.67 P
-0.06 (, these list updates are infrequent, because the list of active clients on the server does not) 116.26 545.67 P
0.08 (change often. For instance, during May 1992, there were on average 10.7 client reboots per day in) 72 532.67 P
-0.14 (the production Sprite setup. This would cause only 10.7 additions and 10.7 deletions per day to the) 72 519.67 P
0.78 (client list. The standard deviation of this measurement is 8.2, with a maximum of 35 reboots on) 72 506.67 P
0.12 (one day and a minimum of zero reboots on two other days. The number of client reboots is higher) 72 493.67 P
-0.16 (in Sprite than in a non-research system, because I and several other users perform experiments that) 72 480.67 P
2 (often require testing, debugging, and rebooting kernels many times a day) 72 467.67 P
2 (. John Hartman, for) 412.27 467.67 P
(example, often reboots the same machine 15 times in one day) 72 454.67 T
(.) 341.93 454.67 T
0 12 Q
(4.1.2. Maintaining and Recovering Fr) 72 423 T
(om the Client List) 264.01 423 T
1 11 Q
0.33 (The second design issue in server) 82.8 397.67 P
0.33 (-driven recovery is how to maintain and recover from the cli-) 231.6 397.67 P
0.87 (ent list; in particular) 72 384.67 P
0.87 (, we must decide what part of the system should handle disk I/O to the list.) 162.96 384.67 P
0.04 (One possibility is that the \336le server) 72 371.67 P
0.04 (\325) 231.33 371.67 P
0.04 (s kernel could issue the disk writes to update the list and read) 234.39 371.67 P
0.51 (the list for recovery from it. Since the \336le server kernel keeps track of the list of active clients in) 72 358.67 P
0.31 (memory) 72 345.67 P
0.31 (, this sounds reasonable. However) 107.9 345.67 P
0.31 (, it is simpler in Sprite to issue disk I/O from user level) 258.84 345.67 P
1 (than from within the kernel, and it is easier to debug a user) 72 332.67 P
1 (-level process than kernel code. For) 342.19 332.67 P
-0.15 (these reasons I chose to use user) 72 319.67 P
-0.15 (-level processes on the server to maintain and recover from the list) 213.05 319.67 P
(on disk.) 72 306.67 T
0.85 (In my design, a user) 82.8 281.67 P
0.85 (-level daemon process issues updates to the list during normal execution.) 174.78 281.67 P
0.44 (Figure 4-1 shows the arrangement of the server kernel and user) 72 268.67 P
0.44 (-level daemon process. Whenever) 353.81 268.67 P
0.66 (the server receives an RPC from a client that is not in its main-memory client list, it updates the) 72 255.67 P
-0.24 (main memory list and informs the user) 72 242.67 P
-0.24 (-level daemon of the new client. The kernel RPC server pro-) 240.63 242.67 P
0.77 (cess that handles this RPC then sleeps until receiving a response from the daemon. The daemon) 72 229.67 P
0.54 (writes the change to disk and responds to the kernel. The RPC server process then wakes up and) 72 216.67 P
(responds to the client.) 72 203.67 T
0.19 (Although managing the client at user) 82.8 178.67 P
0.19 (-level is easier to debug, it does not reduce the importance) 246.15 178.67 P
0.44 (of correctness. Just like the kernel, the user) 72 165.67 P
0.44 (-level daemon process is a point of failure. If the dae-) 264.35 165.67 P
0.13 (mon process dies or hangs, the server is unable to maintain its client list on disk. My current solu-) 72 152.67 P
1.59 (tion to this problem is to start a software timer in the \336le server kernel every time the kernel) 72 139.67 P
0.13 (attempts to communicate with the user) 72 126.67 P
0.13 (-level daemon. If the server kernel does not hear back from) 242.42 126.67 P
0.58 (the daemon before the timer goes of) 72 113.67 P
0.58 (f, the kernel assumes the process has encountered some fail-) 233.94 113.67 P
0.34 (ure. The kernel then panics and reboots. The timer must be long enough that small glitches in the) 72 100.67 P
FMENDPAGE
%%EndPage: "59" 71
%%Page: "60" 71
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(60) 318 55 T
1 11 Q
0.05 (daemon process\325) 108 307.69 P
0.05 (s performance do not cause the kernel to panic unnecessarily) 181.58 307.69 P
0.05 (. A value of \336ve sec-) 448.24 307.69 P
(onds for the timer has worked well. So far) 108 294.69 T
(, daemon failures have not been a problem.) 292.77 294.69 T
0.04 (Another user) 118.8 269.69 P
0.04 (-level process is responsible for reading the client list during crash recovery) 175.67 269.69 P
0.04 (. When) 508.23 269.69 P
0.24 (the server reboots, it starts up a user) 108 256.69 P
0.24 (-level recovery process. The recovery process reads the client) 267.5 256.69 P
1.11 (list from disk and informs the server kernel of the list of clients to contact. The server initiates) 108 243.69 P
0.38 (recovery with the clients and updates its main-memory list of active clients in the normal fashion) 108 230.69 P
1.24 (as these clients respond to the server) 108 217.69 P
1.24 (. If any client has crashed while the server was down, the) 275.3 217.69 P
0.16 (recovery RPC to the client will time-out using the normal crash detection mechanism, and the cli-) 108 204.69 P
-0.05 (ent will be removed from the client list on disk by the user) 108 191.69 P
-0.05 (-level daemon. T) 364.07 191.69 P
-0.05 (o initiate recovery with) 437.94 191.69 P
-0.12 (a client, the server sends a) 108 178.69 P
2 F
-0.12 (start r) 225.38 178.69 P
-0.12 (ecovery) 252.02 178.69 P
1 F
-0.12 ( RPC to the client. The client then executes the same code) 286.18 178.69 P
0.69 (to recover its state as it would have for client-driven recovery) 108 165.69 P
0.69 (. As described in chapter 3, clients) 384.52 165.69 P
0.76 (end their recovery sessions by sending an) 108 152.69 P
2 F
0.76 (end r) 298.57 152.69 P
0.76 (ecovery) 321.81 152.69 P
1 F
0.76 ( RPC to the server) 355.96 152.69 P
0.76 (. Figure 4-2 shows the) 438.98 152.69 P
(communication between the recovery process and the kernel during crash recovery) 108 139.69 T
(.) 471.56 139.69 T
0.08 (After the kernel receives the client list from the recovery process, it decides what to do with the) 118.8 114.69 P
0.39 (list. The kernel can choose the number of clients to recover with at once and it can choose which) 108 101.69 P
0.59 (clients to recover with \336rst. This gives the \336le server an opportunity to manage its recovery load) 108 88.69 P
(Figure 4-1. User) 200.99 443.69 T
(-level daemon updates active client list.) 273.08 443.69 T
1 10 Q
1.34 (This \336gure shows how the \336le server maintains its active client list. Everything in the) 144 421.36 P
1.1 (illustration is running on the \336le server) 144 410.36 P
1.1 (. Whenever the server) 305.52 410.36 P
1.1 (\325) 396.89 410.36 P
1.1 (s kernel receives an RPC) 399.67 410.36 P
0.71 (from a client that is not already on the active client list, it updates the list in memory to) 144 399.36 P
-0.11 (include that client and informs the user) 144 388.36 P
-0.11 (-level daemon of the client\325) 299.17 388.36 P
-0.11 (s host number) 408.66 388.36 P
-0.11 (. The dae-) 463.98 388.36 P
0.55 (mon updates the list on disk and responds to the kernel indicating the update completed.) 144 377.36 P
108 345.02 540 363.02 C
108 345.02 540 363.02 R
7 X
0 K
V
108 354.02 540 354.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(Only then does the server) 144 366.36 T
(\325) 246.51 366.36 T
(s kernel respond to the client.) 249.29 366.36 T
108 469.02 540 720 C
108 469.02 540 709 C
7 X
0 K
90 450 40.5 9 158.2 487.51 G
0.5 H
0 Z
0 X
90 450 40.5 9 158.2 487.51 A
7 X
90 450 40.5 9 158.2 496.51 G
0 X
90 450 40.5 9 158.2 496.51 A
7 X
90 450 40.5 9 158.2 505.51 G
0 X
90 450 40.5 9 158.2 505.51 A
294.7 537.51 447.7 632.51 18 RR
N
117.7 559.51 198.7 631.51 R
N
1 12 Q
(kernel) 351.7 611.51 T
(daemon) 135.7 598.11 T
398.21 637.28 387.68 631.52 393.55 641.98 395.88 639.63 4 Y
V
459.7 703.51 395.9 639.63 2 L
2 Z
N
210.24 619.21 198.7 622.51 210.24 625.82 210.24 622.51 4 Y
V
295 622.51 210.24 622.51 2 L
N
7 X
90 450 40.5 9 158.2 514.51 G
0 Z
0 X
90 450 40.5 9 158.2 514.51 A
(disk) 147.01 511.6 T
157.01 535.05 153.7 523.51 150.39 535.05 153.7 535.05 4 Y
V
153.7 559.51 153.7 535.05 2 L
7 X
V
2 Z
0 X
N
283.46 598.82 295 595.51 283.46 592.21 283.46 595.51 4 Y
V
198.7 595.51 283.46 595.51 2 L
7 X
V
0 X
N
457.36 672.41 467.69 678.51 462.17 667.86 459.76 670.13 4 Y
V
424 632.51 459.77 670.13 2 L
7 X
V
0 X
N
(1\051 1st RPC arrives) 351.7 691.11 T
(from new client) 351.7 679.11 T
(3\051 kernel sends client host number) 205.7 642.33 T
(4\051 daemon updates client list) 159.79 533.33 T
(5\051 daemon) 207.7 574.11 T
(responds to kernel) 201.7 562.11 T
(6\051 kernel responds) 447.7 643.11 T
(to client) 448.7 629.11 T
(2\051 kernel checks for client) 303 591 T
(host in main-memory list,) 306 578 T
(if not there, it updates the) 306 565 T
(list) 307 551 T
(to daemon) 205.7 630.33 T
108 469.02 540 720 C
108 469.02 540 709 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "60" 72
%%Page: "61" 72
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(61) 282 55 T
1 11 Q
0.42 (and control congestion. W) 72 341.66 P
0.42 (ith the current size of the Sprite system \05020 clients\051, negative acknowl-) 188.77 341.66 P
-0.16 (edgments have worked well enough for congestion control that we have not had to limit the degree) 72 328.66 P
(of concurrency during server) 72 315.66 T
(-driven recovery) 198.99 315.66 T
(.) 271.18 315.66 T
-0.26 (T) 82.8 290.66 P
-0.26 (o communicate with each other) 88.74 290.66 P
-0.26 (, the \336le server kernel and user) 225.19 290.66 P
-0.26 (-level processes use a device-like) 358.59 290.66 P
0.56 (interface. The daemon receives client list updates by reading from the \322device,\323 while the kernel) 72 277.66 P
-0.25 (writes these updates to the \322device.\323 The daemon informs the kernel when it has safely \336nished the) 72 264.66 P
0.69 (\336le I/O by issuing an I/O control to the device. During recovery) 72 251.66 P
0.69 (, the recovery process writes the) 358.99 251.66 P
(list of active clients to the device, and the kernel reads the list from it.) 72 238.66 T
0 12 Q
(4.1.3. List Format and Atomic Update) 72 206.99 T
1 11 Q
0.18 (The major concern in the design of the client list is to prevent its loss or corruption in the event) 82.8 181.66 P
0.17 (of a failure. T) 72 168.66 P
0.17 (o accomplish this, I use two techniques: a simple list format that helps to detect cor-) 132.16 168.66 P
(ruption, and an atomic list update that uses two copies.) 72 155.66 T
-0.18 (Figure 4-3 is a diagram of the list format. The \336le header contains a) 82.8 130.66 P
2 F
-0.18 (magic number) 380.18 130.66 P
1 F
-0.18 (, a timestamp,) 442.72 130.66 P
0.87 (and the number of active clients. The magic number is an integer agreed upon by the user) 72 117.66 P
0.87 (-level) 478.98 117.66 P
-0.12 (daemon and recovery process that is unlikely to be present accidentally at the given of) 72 104.66 P
-0.12 (fset in a ran-) 449.13 104.66 P
-0.09 (dom \336le. Thus, it must be an integer other than 0, -1, an ASCII character) 72 91.66 P
-0.09 (, or an even word address.) 389.44 91.66 P
(Figure 4-2. The kernel uses the active client list for recovery) 154.11 466.66 T
(.) 419.14 466.66 T
1 10 Q
-0.04 (This \336gure shows how recovery from the client list works. Everything in the illustration is) 108 444.33 P
0.01 (running on the \336le server) 108 433.33 P
0.01 (. As part of rebooting, the server starts up the user) 207.99 433.33 P
0.01 (-level recovery) 407.77 433.33 P
0.15 (process. The process reads the list of active clients from disk and sends the list to the ker-) 108 422.33 P
0.03 (nel. The \336le server kernel then sends a message to each active client requesting it to begin) 108 411.33 P
72 378.99 504 396.99 C
72 378.99 504 396.99 R
7 X
0 K
V
72 387.99 504 387.99 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(its recovery activities with the server) 108 400.33 T
(.) 254.84 400.33 T
72 491.99 504 720 C
72 491.99 504 709 C
256.2 589.51 409.2 652.51 18 RR
0.5 H
0 Z
0 X
0 K
N
85.2 581.51 166.2 653.51 R
N
1 12 Q
(kernel) 319.2 617.51 T
(recovery) 103.2 620.11 T
(disk) 112.2 537.33 T
244.66 628.82 256.2 625.51 244.66 622.2 244.66 625.51 4 Y
V
166.2 625.51 244.66 625.51 2 L
2 Z
N
432.98 690.08 443.51 695.85 437.64 685.38 435.31 687.73 4 Y
V
398.53 650.84 435.33 687.73 2 L
N
(2\051 recovery process writes list) 173.26 663.33 T
(1\051 recovery process retrieves client list) 127.28 555.33 T
7 X
90 450 40.5 9 125.7 509.51 G
0 Z
0 X
90 450 40.5 9 125.7 509.51 A
7 X
90 450 40.5 9 125.7 518.51 G
0 X
90 450 40.5 9 125.7 518.51 A
7 X
90 450 40.5 9 125.7 527.51 G
0 X
90 450 40.5 9 125.7 527.51 A
7 X
90 450 40.5 9 125.7 536.51 G
0 X
90 450 40.5 9 125.7 536.51 A
(disk) 113.2 532.33 T
117.89 568.98 121.2 580.51 124.5 568.98 121.2 568.98 4 Y
V
121.2 544.51 121.2 568.98 2 L
7 X
V
2 Z
0 X
N
(to server) 173.26 651.33 T
417.37 696.04 425.52 704.84 423.28 693.06 420.33 694.55 4 Y
V
398.53 650.84 420.33 694.55 2 L
7 X
V
0 X
N
395.22 693.31 398.53 704.84 401.84 693.31 398.53 693.31 4 Y
V
398.53 650.84 398.53 693.31 2 L
7 X
V
0 X
N
440.73 675.6 452.52 677.85 443.71 669.7 442.22 672.65 4 Y
V
398.53 650.84 442.23 672.65 2 L
7 X
V
0 X
N
(3\051 kernel sends) 418.2 643.51 T
2 F
(start-r) 418.2 631.51 T
(ecovery) 448.41 631.51 T
1 F
(requests to) 418.2 619.51 T
(active clients) 418.2 607.51 T
(process) 105 602 T
72 491.99 504 720 C
72 491.99 504 709 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "61" 73
%%Page: "62" 73
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(62) 318 55 T
1 11 Q
-0.22 (If the magic number is not present, then either the \336le is corrupted or it is not really a client list \336le.) 108 712.67 P
0.85 (A checksum would provide better corruption detection, but the magic number is simple and has) 108 699.67 P
1.1 (worked well in practice. The timestamp is used for atomic \336le update, as described below) 108 686.67 P
1.1 (. The) 516.32 686.67 P
0.63 (number of active clients makes reading the \336le easier and also helps detect corruption. If the \336le) 108 673.67 P
-0.11 (does not contain the indicated number of clients, then something is wrong. Following the header is) 108 660.67 P
1.79 (a list of tuples. Each tuple contains the host number of the active client and an indication of) 108 647.67 P
0.5 (whether the host is also a server) 108 634.67 P
0.5 (. As described previously) 250.74 634.67 P
0.5 (, this allows the failed server to recover) 363.2 634.67 P
0.05 (\336rst with other servers, but I currently do not make use of this possibility and have no good mech-) 108 621.67 P
(anism for automatically determining when a client is also a server) 108 608.67 T
(.) 396.65 608.67 T
-0.13 (T) 118.8 172.66 P
-0.13 (o prevent corruption or loss of the client list due to a server crash, the daemon performs atomic) 124.74 172.66 P
0 (updates to the list by using two copies. T) 108 159.66 P
0 (o update the list, the daemon overwrites the older copy of) 287.01 159.66 P
-0.04 (the list with the latest update. If the server crashes part way through this update, the newer copy of) 108 146.66 P
0.21 (the list is still available. The only information lost will be the latest update. This is not a problem,) 108 133.66 P
0.71 (because the latest update is not valid if the server crashes before the daemon acknowledges suc-) 108 120.66 P
(cessfully writing the new list.) 108 107.66 T
(Figure 4-3. Client list format.) 259.3 288.66 T
1 10 Q
0.95 (This \336gure is a diagram of the format of the active client list \336le. The \336le starts with a) 144 266.33 P
-0.09 (header containing a magic number) 144 255.33 P
-0.09 (, a time stamp, and the number of active clients listed in) 281.48 255.33 P
-0.1 (the \336le. The client list follows, in the form of a list of tuples. Each tuple contains the client) 144 244.33 P
108 211.99 540 229.99 C
108 211.99 540 229.99 R
7 X
0 K
V
108 220.99 540 220.99 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(host number and an indication of whether the client is a server) 144 233.33 T
(.) 392.43 233.33 T
108 313.99 540 587 C
108 313.99 540 576 C
256 323 398 568 R
7 X
0 K
V
1 H
0 Z
0 X
N
1 12 Q
(magic number) 275 550 T
(time stamp) 275 529 T
(number of active clients) 277 505 T
(client host number) 275 478 T
(server?) 275 460 T
257.14 494 397.14 494 2 L
7 X
V
3 H
2 Z
0 X
N
256 540 398 540 2 L
7 X
V
0.5 H
0 X
N
257 519 398 519 2 L
7 X
V
0 X
N
256 473 398 473 2 L
7 X
V
0 X
N
256 432 398 432 2 L
7 X
V
1 H
0 X
N
257.14 371 397 371 2 L
7 X
V
2 H
0 X
N
(client host number) 275 440 T
(header) 183 531 T
(tuple list) 174 408 T
257 412 397.86 412 2 L
7 X
V
0 X
N
(server?) 275 420 T
256 345 398 345 2 L
7 X
V
1 H
0 X
N
(client host number) 275 355 T
(server?) 274 331 T
256.43 454 398 454 2 L
7 X
V
2 H
0 X
N
235 523.5 235 506.83 2 L
0.5 H
N
180 270 9 8.34 244 506.83 A
0 90 9 8.33 226 524.28 A
235 542.49 235 559.16 2 L
N
90 180 9 8.33 244 559.16 A
270 360 9 8.33 226 541.72 A
235 391.07 235 349.86 2 L
N
180 270 9 19.69 244 349.85 A
0 90 9 19.69 226 391.07 A
235 430.6 235 471.81 2 L
N
90 180 9 19.69 244 471.81 A
270 360 9 19.69 226 430.6 A
0 18 Q
(. . .) 0 -270 294.58 379 TF
108 313.99 540 587 C
108 313.99 540 576 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "62" 74
%%Page: "63" 74
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(63) 282 55 T
1 11 Q
-0.12 (During recovery) 82.8 712.67 P
-0.12 (, the \336le header is used to select the correct \336le and to check that the \336le is com-) 154.27 712.67 P
-0.02 (plete. Before an update, the daemon clears a \336eld in the header) 72 699.67 P
-0.02 (. After a successful update, the dae-) 347.3 699.67 P
0.25 (mon writes the date of the operation to the cleared \336eld. Each of these \336le modi\336cations is forced) 72 686.67 P
2.19 (synchronously to disk using the UNIX) 72 673.67 P
2 F
2.19 (fsync) 257.23 673.67 P
1 F
2.19 ( system call. For recovery) 279.81 673.67 P
2.19 (, the recovery process) 401.65 673.67 P
0.81 (chooses the latest successfully updated copy of the list. The recovery process knows if the most) 72 660.67 P
1.15 (recent copy of the list was successfully updated by examining its header) 72 647.67 P
1.15 (. The recovery process) 401.09 647.67 P
1.11 (checks the \336eld in the header to make sure it is no longer cleared and that it contains the most) 72 634.67 P
(recent date. This means the \336le was correctly and completely updated.) 72 621.67 T
0 14 Q
(4.2. Pr) 72 588.67 T
(oblems with Server) 111 588.67 T
(-Driven Recovery) 225.51 588.67 T
1 11 Q
0.66 (While server) 82.8 562.67 P
0.66 (-driven recovery has many advantages compared to client-driven recovery) 139.67 562.67 P
0.66 (, it also) 470.64 562.67 P
-0.11 (has several problems: it requires more special-purpose code; it is vulnerable to slow clients; it may) 72 549.67 P
0.66 (recover with more clients than necessary; it requires complicated synchronization and locking in) 72 536.67 P
0.3 (the kernel; and, depending on the desired level of robustness, a backup recovery mechanism such) 72 523.67 P
(as client-driven recovery may be desirable. This section explains these problems.) 72 510.67 T
0 12 Q
(4.2.1. Special-Purpose Recovery Code) 72 479 T
1 11 Q
0.76 (I have tried to minimize changes to Sprite for server) 82.8 453.67 P
0.76 (-driven recovery) 318.6 453.67 P
0.76 (, but there were still four) 391.56 453.67 P
0.26 (areas where I had to add new code: I implemented the user) 72 440.67 P
0.26 (-level daemon and recovery processes,) 333.04 440.67 P
1.07 (added the \322device\323 interface, changed the recovery system, and added a new RPC request. The) 72 427.67 P
-0.05 (user) 72 414.67 P
-0.05 (-level processes are not much of a problem, simply because they are at user level. Maintaining) 90.08 414.67 P
-0.01 (and reading the client list at user level is much simpler than doing this in the kernel. However) 72 401.67 P
-0.01 (, this) 482.65 401.67 P
1.47 (arrangement requires an interface for the user) 72 388.67 P
1.47 (-level processes to communicate with the kernel,) 280.7 388.67 P
0.13 (implemented in this case as a special device. Adding a device to Sprite is not hard, but this device) 72 375.67 P
0.72 (adds about 750 new lines of C code to Sprite. \050Over a quarter of the lines are comments.\051 I also) 72 362.67 P
0.49 (changed the recovery module to tell the device about clients to add to or to remove from the list,) 72 349.67 P
1.07 (and also to provide synchronization described below) 72 336.67 P
1.07 (. T) 308.99 336.67 P
1.07 (o the RPC system I added the new) 321.49 336.67 P
2 F
1.07 (start) 483.85 336.67 P
(r) 72 323.67 T
(ecovery) 75.87 323.67 T
1 F
( RPC that the server uses to notify clients that they should initiate recovery) 110.02 323.67 T
(.) 438.57 323.67 T
0 12 Q
(4.2.2. The Slow-Client Pr) 72 292 T
(oblem) 200.38 292 T
1 11 Q
0.45 (Although the server has some control over server) 82.8 266.67 P
0.45 (-driven recovery) 302.02 266.67 P
0.45 (, it is still dependent upon its) 374.66 266.67 P
0.07 (clients for fast recovery) 72 253.67 P
0.07 (. The server can only recover as fast as its slowest client. A client can hold) 175.53 253.67 P
-0.21 (up recovery for the whole system if it is slow sending its state or issuing an) 72 240.67 P
2 F
-0.21 ( end r) 399.36 240.67 P
-0.21 (ecovery) 424.17 240.67 P
1 F
-0.21 ( RPC. The) 458.33 240.67 P
0.15 (solution to this problem is to use a dif) 72 227.67 P
0.15 (ferent recovery scheme that avoids communication with cli-) 239.03 227.67 P
-0.16 (ents during recovery) 72 214.67 P
-0.16 (, such as the transparent recovery approach described in the following chapter) 161.28 214.67 P
-0.16 (.) 501.25 214.67 P
-0.04 (The client may be slow simply because it is running a lot of jobs, or it could have some bug that) 82.8 189.67 P
0.93 (causes it to hang temporarily) 72 176.67 P
0.93 (. For example, while taking measurements for this chapter) 201.93 176.67 P
0.93 (, I found) 464.61 176.67 P
-0.24 (that SP) 72 163.67 P
-0.24 (ARCstations periodically took several hundred milliseconds too long to respond to the serv-) 102.2 163.67 P
0.11 (er) 72 150.67 P
0.11 (\325) 80.94 150.67 P
0.11 (s recovery requests. They were especially likely to do so after being rebooted. Eventually I dis-) 84 150.67 P
-0.17 (covered the source of the problem: clients print two short messages to their consoles, one when the) 72 137.67 P
1.75 (server contacts them for recovery and another when they \336nish recovering. DECstations print) 72 124.67 P
0.34 (quickly to their consoles, but SP) 72 111.67 P
0.34 (ARCstations do not, and they leave interrupts of) 214.9 111.67 P
0.34 (f during the con-) 429.45 111.67 P
0.66 (sole print operation. If a client is running an X server with a default window setup, system mes-) 72 98.67 P
FMENDPAGE
%%EndPage: "63" 75
%%Page: "64" 75
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(64) 318 55 T
1 11 Q
0.66 (sages are redirected to a window rather than the console device. Printing to the window is much) 108 712.67 P
(faster) 108 699.67 T
(. After rebooting a client, though, I often for) 131.8 699.67 T
(got to restart its X server) 325.96 699.67 T
(.) 434.28 699.67 T
0 12 Q
(4.2.3. The T) 108 668 T
(oo-Many-Clients Pr) 167.87 668 T
(oblem) 269.25 668 T
1 11 Q
0.24 (Another problem with server) 118.8 642.67 P
0.24 (-driven recovery is that it may recover with more clients than nec-) 246.55 642.67 P
-0.09 (essary) 108 629.67 P
-0.09 (. Once the server adds a client to the client list, it will not remove the client unless it crashes.) 134.74 629.67 P
1.25 (However) 108 616.67 P
1.25 (, a perfectly healthy client may cease to have any interest in the server if it no longer) 147.82 616.67 P
0.8 (needs any of the server) 108 603.67 P
0.8 (\325) 212.88 603.67 P
0.8 (s \336les or other objects. This is unlikely to occur in an environment with) 215.93 603.67 P
(one central server) 108 590.67 T
(, but in a system with several servers it can happen easily) 185.65 590.67 T
(.) 436.36 590.67 T
0.68 (This problem has two ef) 118.8 565.67 P
0.68 (fects. First, the server will waste time sending) 228.11 565.67 P
2 F
0.68 (start r) 437.97 565.67 P
0.68 (ecovery) 465.41 565.67 P
1 F
0.68 (RPCs to) 502.99 565.67 P
-0.09 (clients with no state to recover) 108 552.67 P
-0.09 (. A worse possibility) 241.53 552.67 P
-0.09 (, though, is that the server may wait a long time) 331.51 552.67 P
0.18 (for these clients to recover) 108 539.67 P
0.18 (. The clients will respond to the) 224.66 539.67 P
2 F
0.18 (start r) 367.52 539.67 P
0.18 (ecovery) 394.47 539.67 P
1 F
0.18 (RPC, and the server will) 431.55 539.67 P
0.33 (mark them as recovering. But if the client actually has no state to recover) 108 526.67 P
0.33 (, it may not execute any) 433.4 526.67 P
(recovery code and may not send the server an) 108 513.67 T
2 F
(end r) 311.49 513.67 T
(ecovery) 333.97 513.67 T
1 F
( RPC.) 368.12 513.67 T
0.04 (There are at least two solutions to this problem. The \336rst is that a client can respond to the serv-) 118.8 488.67 P
-0.21 (er) 108 475.67 P
-0.21 (\325) 116.94 475.67 P
-0.21 (s) 120 475.67 P
2 F
-0.21 (start r) 126.81 475.67 P
-0.21 (ecovery) 153.35 475.67 P
1 F
-0.21 ( RPC by indicating whether or not it has state to recover) 187.51 475.67 P
-0.21 (. If it does not, the server) 431.43 475.67 P
-0.01 (will remove it from the client list and will not wait for it to recover) 108 462.67 P
-0.01 (. In this solution, the server still) 400.87 462.67 P
-0.21 (sends an extra) 108 449.67 P
2 F
-0.21 (start r) 172.35 449.67 P
-0.21 (ecovery) 198.9 449.67 P
1 F
-0.21 ( RPC to the client after its \336rst failure, but it will not do so after subse-) 233.05 449.67 P
0.08 (quent failures. This is the solution I have used in Sprite. A second solution is for a client to unreg-) 108 436.67 P
-0.26 (ister its interest in a server when it no longer has state associated with that server) 108 423.67 P
-0.26 (. The server would) 458.39 423.67 P
0.42 (then remove the client from its list. The advantage of this solution is that the server will not send) 108 410.67 P
1.45 (any unnecessary) 108 397.67 P
2 F
1.45 (start r) 185.94 397.67 P
1.45 (ecovery) 214.15 397.67 P
1 F
1.45 ( RPCs, as long as the clients can be trusted to unregister them-) 248.31 397.67 P
0.05 (selves. The disadvantage is that a client may register and unregister itself frequently if it only uses) 108 384.67 P
-0.06 (a few of the server) 108 371.67 P
-0.06 (\325) 189.9 371.67 P
-0.06 (s \336les. Sprite clients do not currently have the ability to unregister their interest) 192.96 371.67 P
(in a server) 108 358.67 T
(.) 153.15 358.67 T
0 12 Q
(4.2.4. Synchr) 108 327 T
(onization and Locking) 174.42 327 T
1 11 Q
0.01 (Synchronization problems occur for a combination of reasons: the server must block a subset of) 118.8 301.67 P
1.2 (RPC requests from the clients until all clients have recovered, and the list of active clients can) 108 288.67 P
0.58 (change during recovery itself. These problems are all solvable, but \336nding the solutions required) 108 275.67 P
(some experimentation, and the solutions may not be easily generalizable to other systems.) 108 262.67 T
0.54 (One reason for tricky synchronization on the server is that it must refuse certain kinds of RPC) 118.8 237.67 P
0.6 (requests during recovery) 108 224.67 P
0.6 (, but not others. T) 217.1 224.67 P
0.6 (o prevent cache consistency violations the server must) 296.87 224.67 P
0.19 (block new open requests and other requests that can alter the distributed cache state or \336le system) 108 211.67 P
0.25 (structure. However) 108 198.67 P
0.25 (, it must not block client reopen requests or requests from clients to write back) 192.01 198.67 P
-0 (their dirty cache pages, because these requests are part of the clients\325 recovery activities. Blocking) 108 185.67 P
2.18 (these RPCs will hang the system. Unfortunately) 108 172.67 P
2.18 (, discovering which RPCs to block seems to) 331.25 172.67 P
0.99 (require some trial and error) 108 159.67 P
0.99 (. When there was any question, I erred on the conservative side and) 231.56 159.67 P
0.23 (chose to block the RPC request. T) 108 146.67 P
0.23 (able 4-1 and T) 258.44 146.67 P
0.23 (able 4-2 list the blocked and unblocked RPCs for) 322.12 146.67 P
(Sprite.) 108 133.67 T
1.25 (There is an alternative to blocking various RPC requests to prevent cache consistency viola-) 118.8 108.67 P
0.93 (tions. Spritely NFS \050described in chapter 2\051 instead uses an extra phase of RPCs that the server) 108 95.67 P
FMENDPAGE
%%EndPage: "64" 76
%%Page: "65" 76
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(65) 282 55 T
1 11 Q
0.91 (sends to clients to indicate that recovery is over) 72 151.67 P
0.91 (. In Spritely NFS, clients know that they cannot) 287.38 151.67 P
-0.08 (send certain RPC requests to the server until after recovery) 72 138.67 P
-0.08 (. When all clients have \336nished sending) 329.62 138.67 P
0.69 (their reopen requests to the server) 72 125.67 P
0.69 (, the server sends out a special) 223.61 125.67 P
2 F
0.69 (endr) 364.54 125.67 P
0.69 (ecov) 384.27 125.67 P
1 F
0.69 ( RPC to each client to) 404.4 125.67 P
0.67 (tell it that recovery is done. Once the client receives this RPC, it knows it can start sending new) 72 112.67 P
0.89 (requests to the server) 72 99.67 P
0.89 (. The advantage of this technique is that the server does not need to worry) 167.13 99.67 P
1.21 (about blocking RPCs. The disadvantages are that the clients must be trusted not to issue RPCs) 72 86.67 P
72 81 504 720 C
72.5 159 503.5 720 C
74 167 502 716 R
7 X
0 K
V
1 11 Q
0 X
(T) 215.91 245.67 T
(able 4-1. List of blocked RPCs.) 221.86 245.67 T
1 10 Q
0.05 (This table lists RPCs that are blocked for all clients during recovery) 110 221.33 P
0.05 (. Most of these RPCs) 381.12 221.33 P
-0.07 (change the distributed cache state or other \336le system state and could cause cache consis-) 110 210.33 P
1.38 (tency violations or other inconsistencies during recovery) 110 199.33 P
1.38 (. For more information about) 344.16 199.33 P
74 167 502 185 C
74 167 502 185 R
7 X
0 K
V
74 176 506 176 2 L
V
0.5 H
2 Z
0 X
N
72.5 159 503.5 720 C
1 10 Q
0 X
0 K
(these RPCs, please see [W) 110 188.33 T
(elch86] and [W) 215.52 188.33 T
(elch90]) 276.88 188.33 T
(RPC) 141.43 676.33 T
(Purpose) 317.17 676.33 T
(open) 109.61 658.33 T
(Open a \336le or other object.) 200.14 658.33 T
(read) 109.61 640.33 T
(Read from a \336le or other object.) 200.14 640.33 T
(write) 109.61 622.33 T
(W) 200.14 622.33 T
(rite to a \336le or other object.) 209.18 622.33 T
(close) 109.61 604.33 T
(Close a \336le or other object.) 200.14 604.33 T
(unlink) 109.61 586.33 T
(Unlink a \336le or other object.) 200.14 586.33 T
(rename) 109.61 568.33 T
(Rename a \336le or other object.) 200.14 568.33 T
(mkdir) 109.61 550.33 T
(Create a directory) 200.14 550.33 T
(.) 271.09 550.33 T
(rmdir) 109.61 532.33 T
(Remove a directory) 200.14 532.33 T
(.) 278.32 532.33 T
(mkdev) 109.61 514.33 T
(Create a device.) 200.14 514.33 T
(link) 109.61 496.33 T
(Create a link to a \336le or other object.) 200.14 496.33 T
(sym_link) 109.61 478.33 T
(Create a symbolic link to a \336le or other object.) 200.14 478.33 T
(set_attr) 109.61 460.33 T
(Set various attributes of a \336le or other object.) 200.14 460.33 T
(set_attr_path) 109.61 442.33 T
(Given a pathname, set the attributes of that \336le or other object.) 200.14 442.33 T
(set_io_attr) 109.61 424.33 T
(Set the attributes of a \336le or other object cached on the I/O server) 200.14 424.33 T
(.) 460.78 424.33 T
(dev_open) 109.61 406.33 T
(Open a connection to the I/O server for a device.) 200.14 406.33 T
(io_control) 109.61 388.33 T
(Perform an I/O control.) 200.14 388.33 T
(migrate) 109.61 370.33 T
(Start migration of an I/O handle.) 200.14 370.33 T
(release) 109.61 352.33 T
(Release a stream reference during migration.) 200.14 352.33 T
(mig_command) 109.61 334.33 T
(T) 200.14 334.33 T
(ransfer information about a process being migrated.) 205.9 334.33 T
(remote_call) 109.61 316.33 T
(Perform a system call on a migrated process.) 200.14 316.33 T
(remote_wait) 109.61 298.33 T
(W) 200.14 298.33 T
(ait on a migrated process.) 208.78 298.33 T
(fs_release) 109.61 280.33 T
(Release a stream reference during process migration.) 200.14 280.33 T
105.61 686 105.61 274 2 L
V
2 H
0 Z
N
196.14 688 196.14 272 2 L
V
N
470.4 686 470.4 274 2 L
V
N
104.61 687 471.4 687 2 L
V
N
106.61 670.25 469.4 670.25 2 L
V
0.5 H
N
106.61 667.75 469.4 667.75 2 L
V
N
104.61 651 471.4 651 2 L
V
N
104.61 633 471.4 633 2 L
V
N
104.61 615 471.4 615 2 L
V
N
104.61 597 471.4 597 2 L
V
N
104.61 579 471.4 579 2 L
V
N
104.61 561 471.4 561 2 L
V
N
104.61 543 471.4 543 2 L
V
N
104.61 525 471.4 525 2 L
V
N
104.61 507 471.4 507 2 L
V
N
104.61 489 471.4 489 2 L
V
N
104.61 471 471.4 471 2 L
V
N
104.61 453 471.4 453 2 L
V
N
104.61 435 471.4 435 2 L
V
N
104.61 417 471.4 417 2 L
V
N
104.61 399 471.4 399 2 L
V
N
104.61 381 471.4 381 2 L
V
N
104.61 363 471.4 363 2 L
V
N
104.61 345 471.4 345 2 L
V
N
104.61 327 471.4 327 2 L
V
N
104.61 309 471.4 309 2 L
V
N
104.61 291 471.4 291 2 L
V
N
104.61 273 471.4 273 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "65" 77
%%Page: "66" 77
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(66) 318 55 T
1 11 Q
0.36 (such as new open requests until after the server has said it is okay) 108 245.67 P
0.36 (, and that recovery takes longer) 400.3 245.67 P
0.54 (because of the extra phase of RPCs sent by the server) 108 232.67 P
0.54 (. The designers of Spritely NFS were more) 347.68 232.67 P
(concerned with simplicity) 108 219.67 T
(, though, than with recovery speed.) 221.41 219.67 T
1.12 (In Sprite, synchronization is further complicated by the fact that clients can crash or become) 118.8 194.67 P
1.67 (newly available during the recovery period. The server must update its client list accordingly) 108 181.67 P
1.67 (.) 537.25 181.67 P
0.16 (Thus, the server may both read and write the client list during recovery) 108 168.67 P
0.16 (. In my initial implementa-) 421.28 168.67 P
-0.07 (tion, client list updates and recovery from the list were both handled by one user) 108 155.67 P
-0.07 (-level process, but) 459.89 155.67 P
0.34 (this allowed deadlock to occur) 108 142.67 P
0.34 (. The recovery activities from user) 243 142.67 P
0.34 (-level would hang waiting to get) 395.8 142.67 P
0.38 (exclusive access to the device module, while the device module would hang waiting for the user) 108 129.67 P
0.38 (-) 536.34 129.67 P
0.83 (level process to acknowledge writing a new client to the list. This caused deadlock, because the) 108 116.67 P
0.4 (user) 108 103.67 P
0.4 (-level process could not write the new client to the list while hung. The solution to this prob-) 126.08 103.67 P
(lem was to separate the user) 108 90.67 T
(-level daemon and recovery processes.) 231.34 90.67 T
108 81 540 720 C
108 253 540 720 C
107 260 540 716 R
7 X
0 K
V
1 10 Q
0 X
(RPC) 176.05 676.33 T
(Purpose) 353.9 676.33 T
(echo) 143 658.33 T
(An empty RPC that just requests a response.) 236 658.33 T
(send) 143 640.33 T
(Used to time RPCs with dif) 236 640.33 T
(ferent amounts of data.) 346.05 640.33 T
(get_time) 143 622.33 T
(Get the time of day) 236 622.33 T
(.) 312.52 622.33 T
(pre\336x) 143 604.33 T
(Look up a pre\336x for a pathname.) 236 604.33 T
(get_attr) 143 586.33 T
(Get the attributes for a \336le or other object.) 236 586.33 T
(get_attr_path) 143 568.33 T
(Given a pathname, get the attributes of that \336le or other object.) 236 568.33 T
(get_io_attr) 143 550.33 T
(Get the attributes of a \336le or other object cached on the I/O server) 236 550.33 T
(.) 498.3 550.33 T
(select) 143 532.33 T
(Perform the select system call for a \336le or other object.) 236 532.33 T
(remote_call) 143 514.33 T
(Perform a system call for a migrated process.) 236 514.33 T
(consist) 143 496.33 T
(Cache consistency operation sent by server to client.) 236 496.33 T
(consist_reply) 143 478.33 T
(Response to consistency call, sent by client back to the server) 236 478.33 T
(.) 481.67 478.33 T
(remote_wakeup) 143 460.33 T
(Notify a remote process of some event.) 236 460.33 T
(reopen) 143 442.33 T
(Reopen a \336le or other object.) 236 442.33 T
(domain_info) 143 424.33 T
(Return information about a \336le system domain.) 236 424.33 T
(end_recovery) 143 406.33 T
(Sent by client to server to indicate end of client\325) 236 406.33 T
(s recovery) 427.82 406.33 T
(.) 468.51 406.33 T
(get_pcb) 143 388.33 T
(Retrieve a process control block from another host.) 236 388.33 T
(bulk_reopen) 143 370.33 T
(Reopen many objects at once. \050A batched reopen request.\051) 236 370.33 T
(server_reopen) 143 352.33 T
-0.09 (Sent by server to clients to tell them to start server) 236 352.33 P
-0.09 (-driven recovery) 435.91 352.33 P
-0.09 (.) 501.5 352.33 P
1 11 Q
(T) 244.7 327.67 T
(able 4-2. List of Unblocked RPCs.) 250.64 327.67 T
1 10 Q
0.2 (This table lists RPCs that are not blocked for clients during recovery) 143 303.33 P
0.2 (. Most of these RPCs) 418.52 303.33 P
2.43 (are needed as part of recovery) 143 292.33 P
2.43 (. For more information about these RPCs, please see) 274.67 292.33 P
108 260 540 278 C
107 260 540 278 R
7 X
0 K
V
107 269 539 269 2 L
V
0.5 H
2 Z
0 X
N
108 253 540 720 C
1 10 Q
0 X
0 K
([W) 143 281.33 T
(elch86] and [W) 154.96 281.33 T
(elch90]) 216.33 281.33 T
139 686 139 346 2 L
V
2 H
0 Z
N
232 688 232 344 2 L
V
N
508 686 508 346 2 L
V
N
138 687 509 687 2 L
V
N
140 670.25 507 670.25 2 L
V
0.5 H
N
140 667.75 507 667.75 2 L
V
N
138 651 509 651 2 L
V
N
138 633 509 633 2 L
V
N
138 615 509 615 2 L
V
N
138 597 509 597 2 L
V
N
138 579 509 579 2 L
V
N
138 561 509 561 2 L
V
N
138 543 509 543 2 L
V
N
138 525 509 525 2 L
V
N
138 507 509 507 2 L
V
N
138 489 509 489 2 L
V
N
138 471 509 471 2 L
V
N
138 453 509 453 2 L
V
N
138 435 509 435 2 L
V
N
138 417 509 417 2 L
V
N
138 399 509 399 2 L
V
N
138 381 509 381 2 L
V
N
138 363 509 363 2 L
V
N
138 345 509 345 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "66" 78
%%Page: "67" 78
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(67) 282 55 T
1 11 Q
1.21 (This combination of restrictions and complications means that there are many types of locks) 82.8 712.67 P
0.19 (held simultaneously during recovery and care is required to avoid deadlock. There is an exclusive) 72 699.67 P
0.81 (access lock \050monitor lock\051 around some of the device code to protect the device data structures.) 72 686.67 P
0.42 (This lock can be held as a result of an open or close device call by either user) 72 673.67 P
0.42 (-level process, or it) 418.52 673.67 P
0.16 (can be held by the recovery module as it adds and deletes clients from the client list. There is also) 72 660.67 P
0.44 (a monitor lock in the recovery module to protect updates to the recovery status information. This) 72 647.67 P
0.15 (lock can be held as a result of calls from the RPC system or calls from the device module to mark) 72 634.67 P
0.98 (when hosts begin recovery or when the recovery module should block various RPCs. There are) 72 621.67 P
-0.06 (also \337ags that must be set and unset in the per) 72 608.67 P
-0.06 (-client recovery status information, so that the server) 272.55 608.67 P
-0.18 (can block some RPCs for recovering clients and all RPCs for other clients. Calls from the recovery) 72 595.67 P
0.67 (module into the device module will acquire both the recovery and device module monitor locks.) 72 582.67 P
0.67 (T) 72 569.67 P
0.67 (o avoid deadlock, it is necessary to restrict calls in the other direction \050from the device module) 77.94 569.67 P
1.64 (into the recovery module\051 to locations in the code where the device module does not need to) 72 556.67 P
(acquire its own monitor lock.) 72 543.67 T
0 12 Q
(4.2.5. Robustness V) 72 512 T
(ersus Simplicity) 170.51 512 T
1 11 Q
0.19 (A \336nal potential disadvantage of server) 82.8 486.67 P
0.19 (-driven recovery is that it does not necessarily eliminate) 256.54 486.67 P
0.53 (the need for client-driven recovery) 72 473.67 P
0.53 (. Whether or not a system should have both forms of recovery) 225.96 473.67 P
-0.13 (available involves a trade-of) 72 460.67 P
-0.13 (f between simplicity and extra robustness in the face of a network par-) 196.19 460.67 P
(tition or a lost client list \336le.) 72 447.67 T
0.44 (Both network partitions and losing the client list will cause server) 82.8 422.67 P
0.44 (-driven recovery to fail. Net-) 375.64 422.67 P
0.34 (work partitions are rare in our environment \050a local-area ethernet\051, but they are still possible. In a) 72 409.67 P
0.42 (network partition, the server may believe a client has died because it cannot reach the client. The) 72 396.67 P
0.06 (server will clean up the state for that client and remove it from the active client list. When the net-) 72 383.67 P
0.59 (work partition ends, the server will fail to recover with the client, because the client is no longer) 72 370.67 P
-0.16 (listed. It is also conceivable after a failure that both copies of the client list \336le have disappeared or) 72 357.67 P
0.58 (become corrupted. Server) 72 344.67 P
0.58 (-driven recovery will fail in this case, because it does not have a list of) 186.13 344.67 P
(clients to contact for recovery) 72 331.67 T
(.) 202.47 331.67 T
0.46 (There are two choices for addressing these problems. The \336rst solution is that we could reboot) 82.8 306.67 P
0.62 (the af) 72 293.67 P
0.62 (fected clients. In the case of network partition, we would reboot the clients that were sepa-) 97.13 293.67 P
0.05 (rated from the server) 72 280.67 P
0.05 (. In the case of a lost client list, we would restart the whole system by reboot-) 163.36 280.67 P
-0.06 (ing all the clients. Although this would disrupt many users, the need to do this should be very rare,) 72 267.67 P
(and it is a very simple solution.) 72 254.67 T
0.22 (The second solution is to retain the ability to perform client-driven recovery) 82.8 229.67 P
0.22 (. One of the advan-) 418.61 229.67 P
-0.19 (tages of client-driven recovery is that it depends only on the clients to drive recovery) 72 216.67 P
-0.19 (, so it will still) 441.55 216.67 P
-0.15 (work in these situations. Retaining both types of recovery adds complexity to the system, but since) 72 203.67 P
0.79 (all of the client-driven recovery code is used by the server) 72 190.67 P
0.79 (-driven code, the added complexity is) 334.7 190.67 P
-0.1 (limited. There are two extra requirements to maintain both types of recovery) 72 177.67 P
-0.1 (. The \336rst is a \337ag in a) 406.43 177.67 P
0.12 (\336eld of the server) 72 164.67 P
0.12 (\325) 149.97 164.67 P
0.12 (s RPC headers that states it is using server) 153.02 164.67 P
0.12 (-driven recovery) 339.34 164.67 P
0.12 (. The second is some) 411.65 164.67 P
1.62 (extra client-side synchronization, so that clients know to wait for some period of time for the) 72 151.67 P
1.26 (server to contact them. The extra synchronization is required to prevent clients from triggering) 72 138.67 P
(their own client-driven recovery with a server that is performing server) 72 125.67 T
(-driven recovery) 384.2 125.67 T
(.) 456.39 125.67 T
FMENDPAGE
%%EndPage: "67" 79
%%Page: "68" 79
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(68) 318 55 T
0 14 Q
(4.3. Results and Measur) 108 710.67 T
(ements) 251.17 710.67 T
1 11 Q
1.41 (The two main advantages for server) 118.8 684.67 P
1.41 (-driven recovery are that it eliminates cache consistency) 283.34 684.67 P
0.32 (violations during and after recovery) 108 671.67 P
0.32 (, and that it is faster than client-driven recovery) 265.99 671.67 P
0.32 (. The previous) 476.2 671.67 P
0.8 (chapter described the cache consistency issues; this section contains recovery performance mea-) 108 658.67 P
1.24 (surements. Besides the basic timings of server) 108 645.67 P
1.24 (-driven recovery) 318.14 645.67 P
1.24 (, this section includes timings of) 391.58 645.67 P
-0.12 (server) 108 632.67 P
-0.12 (-driven recovery with varying numbers of clients, measurements of resource utilization, tim-) 134.62 632.67 P
0.2 (ings of recovery with and without optimizations to the recovery protocol, and timings with dif) 108 619.67 P
0.2 (fer-) 524.15 619.67 P
(ent amounts of \336le sharing between clients.) 108 606.67 T
2.21 (Server) 118.8 581.67 P
2.21 (-driven recovery is faster than client-driven recovery) 147.26 581.67 P
2.21 (, because the server can initiate) 391.66 581.67 P
0.56 (recovery with clients without waiting for them to detect that it has rebooted. Otherwise the work) 108 568.67 P
0.97 (done by the clients and the server is much the same for the two recovery techniques. Using the) 108 555.67 P
0.88 (same testbed and basic state setup used in the previous chapter \050described in T) 108 542.67 P
0.88 (able 3-5\051, server) 463.12 542.67 P
0.88 (-) 536.34 542.67 P
0.12 (driven recovery takes 1.98 seconds on average, rather than 21. This test was run \336ve times, with a) 108 529.67 P
0.56 (standard deviation of 1.7%. I call this the basic server) 108 516.67 P
0.56 (-driven measurement, because it is directly) 348.65 516.67 P
0.3 (comparable to the basic client-driven measurement and to the transparent recovery measurements) 108 503.67 P
(in the next chapter) 108 490.67 T
(.) 188.86 490.67 T
-0.23 (There are two distinct phases for server) 118.8 465.67 P
-0.23 (-driven recovery: handling the client list \336le and recover-) 290.46 465.67 P
0.45 (ing with the clients. The time for the \336rst phase includes the cost of starting up the recovery pro-) 108 452.67 P
0.64 (cess, executing the) 108 439.67 P
2 F
0.64 (stat) 195.37 439.67 P
1 F
0.64 ( system call for two client list \336les, reading their \336le descriptors, opening) 211.24 439.67 P
0.57 (the two \336les, reading their headers to determine which to use, reading the contents of the chosen) 108 426.67 P
0.04 (\336le to make sure it includes the correct number of clients, opening the kernel\325) 108 413.67 P
0.04 (s \322device,\323 and writ-) 448.98 413.67 P
-0 (ing the client list to the to the device. This phase takes 280 milliseconds. During the second phase,) 108 400.67 P
(the kernel recovers its distributed state from the clients. This phase takes about 1.70 seconds.) 108 387.67 T
-0.25 (For the remaining measurements in this chapter) 118.8 362.67 P
-0.25 (, I separate the \336rst phase from the state recovery) 326.21 362.67 P
0.45 (phase. There are two reasons for doing so. First, the time to handle the client list \336le is relatively) 108 349.67 P
0.22 (static. It does not vary much with the number of clients \050unless the number is so huge that the \336le) 108 336.67 P
0.52 (becomes very lar) 108 323.67 P
0.52 (ge and takes longer to read\051, and it does not vary at all with the amount of state) 183.89 323.67 P
0.96 (recovered. Second, separating the state recovery phase makes it easier to compare the results in) 108 310.67 P
0.93 (this chapter with those of other chapters, since the other recovery techniques do not include the) 108 297.67 P
(\336rst phase.) 108 284.67 T
-0.24 (Figure 4-4 below shows server) 118.8 259.67 P
-0.24 (-driven recovery timings for dif) 253.1 259.67 P
-0.24 (ferent numbers of clients. The \336g-) 391.08 259.67 P
0.48 (ure presents the times for the state recovery phase and does not include the time for handling the) 108 246.67 P
1.19 (client list \336le. This data is useful for determining how server) 108 233.67 P
1.19 (-driven recovery should scale to a) 385.47 233.67 P
0.68 (lar) 108 220.67 P
0.68 (ger system than my testbed setup. The results scale linearly with respect to the number of cli-) 119.39 220.67 P
0.33 (ents, at least for the number available in this test. The slope of the curve in Figure 4-4 shows that) 108 207.67 P
-0.02 (the extra cost per client is 0.131 seconds. Thus, for a server with 40 clients and an average amount) 108 194.67 P
0.43 (of recovery state per client, the state recovery phase for server) 108 181.67 P
0.43 (-driven recovery should take about) 385.12 181.67 P
(5.6 seconds.) 108 168.67 T
-0.26 (Note, though, that this result does not necessarily mean that an individual client takes an average) 118.8 143.67 P
0.35 (of 0.131 seconds to recover) 108 130.67 P
0.35 (. Clients can take much longer to recover) 229.93 130.67 P
0.35 (, but their recovery activities) 412.58 130.67 P
0.18 (overlap. For instance, the server can process state from one client while another client unpacks its) 108 117.67 P
-0.01 (reopen results. W) 108 104.67 P
-0.01 (ith a single client, no such overlap is possible, and Figure 4-4 shows that a single) 184.72 104.67 P
(client takes about 550 to 600 milliseconds for state recovery) 108 91.67 T
(.) 371.84 91.67 T
FMENDPAGE
%%EndPage: "68" 80
%%Page: "69" 80
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(69) 282 55 T
1 11 Q
1.67 (The limiting performance factor for server) 82.8 218.64 P
1.67 (-driven recovery in Sprite is disk I/O. Figure 4-5) 277.34 218.64 P
-0.26 (shows disk utilization during state recovery for dif) 72 205.64 P
-0.26 (ferent numbers of clients. For one or two clients,) 291.85 205.64 P
2.56 (there is only limited concurrency between the disk and CPU. But as the number of clients) 72 192.64 P
0.2 (increases, the disk rapidly becomes the limiting factor) 72 179.64 P
0.2 (. W) 310.19 179.64 P
0.2 (ith four or more clients, the disk is 75 to) 325.81 179.64 P
1.12 (80% utilized. The disk is actually even more highly utilized during the I/O handle part of state) 72 166.64 P
0.93 (recovery) 72 153.64 P
0.93 (, because it is not used at all for stream handle recovery) 109.72 153.64 P
0.93 (. The last clients to recover are) 363.28 153.64 P
0.91 (unable to overlap the CPU processing for stream handle recovery with other clients\325 I/O handle) 72 140.64 P
(recovery) 72 127.64 T
(.) 109.72 127.64 T
-0.26 (The source of disk activity on the server is reading \336le descriptors. As described in section 3.1.4,) 82.8 102.64 P
0.43 (a Sprite server requires \336le descriptors for the \336le I/O handles it reopens. The clients do not send) 72 89.64 P
(Figure 4-4. Server) 152.03 398.64 T
(-driven state recovery by number of clients.) 232.06 398.64 T
1 10 Q
0.14 (This graph gives timings for the state recovery phase of server) 108 376.31 P
0.14 (-driven recovery versus the) 358.5 376.31 P
0.41 (number of clients in the testbed setup. The X axis gives the number of clients in the tim-) 108 365.31 P
0.67 (ings, and the Y axis gives the number of seconds required for state recovery) 108 354.31 P
0.67 (. \050This does) 419.74 354.31 P
0.12 (not include the time to handle the client list \336le.\051 There are \336ve to six data points for each) 108 343.31 P
-0.16 (number of clients, but some of the points lie on top of each other so they are not separately) 108 332.31 P
0.25 (visible. The dotted line gives the apparent slope of the measurements, using least-squares) 108 321.31 P
-0.04 (linear regression. The slope of the line is 0.131 seconds per client. The per) 108 310.31 P
-0.04 (-client setup for) 404.8 310.31 P
0.67 (this data is shown in T) 108 299.31 P
0.67 (able 3-5, with one modi\336cation: to make the setup more realistic,) 200.89 299.31 P
0.96 (for timings of one to nine clients, only one client repeatedly truncated and wrote a \336le.) 108 288.31 P
72 255.98 504 273.98 C
72 255.98 504 273.98 R
7 X
0 K
V
72 264.98 504 264.98 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(When ten clients were available, two clients participated in this activity) 108 277.31 T
(.) 392.98 277.31 T
72 423.98 504 720 C
72 423.98 504 709 C
0 0 0 539 449 403 282 87 424 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/serverVary.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 449
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 7360 3 just-string
200 /Times-Roman choose-font
() 7106 6608 2 just-string
() 7106 6316 2 just-string
() 7106 6024 2 just-string
() 7106 5732 2 just-string
() 7106 5440 2 just-string
() 7106 5148 2 just-string
() 7106 4856 2 just-string
() 7106 4564 2 just-string
() 7106 4272 2 just-string
() 7106 3980 2 just-string
() 7106 3688 2 just-string
() 7106 3396 2 just-string
() 7106 3104 2 just-string
() 7106 2812 2 just-string
() 7106 2520 2 just-string
() 7106 2228 2 just-string
() 7106 1936 2 just-string
() 7106 1644 2 just-string
() 7106 1352 2 just-string
() 7106 1060 2 just-string
() 7106 768 2 just-string
14 setlinewidth
[] 0 setdash
(Seconds) 560 6800 2 just-string
(Number of clients) 7106 380 1 just-string
(0.00) 860 663 5 just-string
(0.20) 860 1292 5 just-string
(0.40) 860 1922 5 just-string
(0.60) 860 2551 5 just-string
(0.80) 860 3180 5 just-string
(1.00) 860 3810 5 just-string
(1.20) 860 4439 5 just-string
(1.40) 860 5068 5 just-string
(1.60) 860 5698 5 just-string
(1.80) 860 6327 5 just-string
(    0) 1226 90 7 just-string
(    2) 2329 90 7 just-string
(    4) 3432 90 7 just-string
(    6) 4534 90 7 just-string
(    8) 5637 90 7 just-string
(   10) 6740 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  950 663 moveto
  1225 663 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1292 moveto
  1225 1292 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1922 moveto
  1225 1922 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2551 moveto
  1225 2551 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3180 moveto
  1225 3180 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3810 moveto
  1225 3810 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4439 moveto
  1225 4439 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5068 moveto
  1225 5068 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5698 moveto
  1225 5698 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 6327 moveto
  1225 6327 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1226 663 moveto
  1226 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  2329 663 moveto
  2329 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  3432 663 moveto
  3432 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4534 663 moveto
  4534 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  5637 663 moveto
  5637 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6740 663 moveto
  6740 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1225 6327 moveto
  1225 663 lineto
  6740 663 lineto
  6740 6327 lineto
  1225 6327 lineto
stroke
1777 2236 24 mark0
1777 2236 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  1777 2236 moveto
  1777 2236 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 2236 24 mark0
1777 2236 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  1777 2236 moveto
  1777 2236 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 2362 24 mark0
1777 2362 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1777 2362 moveto
  1777 2362 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 2236 24 mark0
1777 2236 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  1777 2236 moveto
  1777 2236 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 2425 24 mark0
1777 2425 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  1777 2425 moveto
  1777 2425 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 6201 24 mark0
6740 6201 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6740 6201 moveto
  6740 6201 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 6012 24 mark0
6740 6012 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6740 6012 moveto
  6740 6012 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5886 24 mark0
6740 5886 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6740 5886 moveto
  6740 5886 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5949 24 mark0
6740 5949 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6740 5949 moveto
  6740 5949 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5949 24 mark0
6740 5949 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6740 5949 moveto
  6740 5949 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2677 24 mark0
2329 2677 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2329 2677 moveto
  2329 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2677 24 mark0
2329 2677 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2329 2677 moveto
  2329 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2677 24 mark0
2329 2677 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2329 2677 moveto
  2329 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2992 24 mark0
2329 2992 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  2329 2992 moveto
  2329 2992 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2677 24 mark0
2329 2677 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  2329 2677 moveto
  2329 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 2740 24 mark0
2880 2740 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  2880 2740 moveto
  2880 2740 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3117 24 mark0
2880 3117 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  2880 3117 moveto
  2880 3117 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3306 24 mark0
2880 3306 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2880 3306 moveto
  2880 3306 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3054 24 mark0
2880 3054 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2880 3054 moveto
  2880 3054 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3180 24 mark0
2880 3180 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2880 3180 moveto
  2880 3180 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3369 24 mark0
3432 3369 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3432 3369 moveto
  3432 3369 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3684 24 mark0
3432 3684 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3432 3684 moveto
  3432 3684 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3432 24 mark0
3432 3432 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3432 3432 moveto
  3432 3432 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3495 24 mark0
3432 3495 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3432 3495 moveto
  3432 3495 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3432 24 mark0
3432 3432 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  3432 3432 moveto
  3432 3432 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3495 24 mark0
3432 3495 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  3432 3495 moveto
  3432 3495 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3621 24 mark0
3983 3621 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  3983 3621 moveto
  3983 3621 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3684 24 mark0
3983 3684 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3983 3684 moveto
  3983 3684 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3998 24 mark0
3983 3998 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3983 3998 moveto
  3983 3998 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3684 24 mark0
3983 3684 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3983 3684 moveto
  3983 3684 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3810 24 mark0
3983 3810 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3983 3810 moveto
  3983 3810 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3747 24 mark0
3983 3747 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3983 3747 moveto
  3983 3747 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4124 24 mark0
4534 4124 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  4534 4124 moveto
  4534 4124 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4124 24 mark0
4534 4124 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  4534 4124 moveto
  4534 4124 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4313 24 mark0
4534 4313 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  4534 4313 moveto
  4534 4313 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4250 24 mark0
4534 4250 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  4534 4250 moveto
  4534 4250 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4187 24 mark0
4534 4187 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  4534 4187 moveto
  4534 4187 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4691 24 mark0
5086 4691 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5086 4691 moveto
  5086 4691 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4879 24 mark0
5086 4879 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5086 4879 moveto
  5086 4879 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4754 24 mark0
5086 4754 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5086 4754 moveto
  5086 4754 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4691 24 mark0
5086 4691 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  5086 4691 moveto
  5086 4691 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4565 24 mark0
5086 4565 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  5086 4565 moveto
  5086 4565 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4879 24 mark0
5637 4879 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  5637 4879 moveto
  5637 4879 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5131 24 mark0
5637 5131 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5637 5131 moveto
  5637 5131 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5068 24 mark0
5637 5068 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5637 5068 moveto
  5637 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5509 24 mark0
5637 5509 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5637 5509 moveto
  5637 5509 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5005 24 mark0
5637 5005 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5637 5005 moveto
  5637 5005 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5068 24 mark0
5637 5068 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5637 5068 moveto
  5637 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5509 24 mark0
6189 5509 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6189 5509 moveto
  6189 5509 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5698 24 mark0
6189 5698 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6189 5698 moveto
  6189 5698 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5886 24 mark0
6189 5886 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  6189 5886 moveto
  6189 5886 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5383 24 mark0
6189 5383 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  6189 5383 moveto
  6189 5383 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5572 24 mark0
6189 5572 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6189 5572 moveto
  6189 5572 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5823 24 mark0
6189 5823 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6189 5823 moveto
  6189 5823 lineto
stroke
[] 0 setdash 8 setlinewidth 1226 1833 24 mark0
6740 5958 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  1226 1833 moveto
  6740 5958 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
72 423.98 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "69" 81
%%Page: "70" 81
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(70) 318 55 T
1 11 Q
1.2 (the server this information, because they do not necessarily have the most recent copy) 108 275.67 P
1.2 (. For the) 500.67 275.67 P
0.3 (basic state setup used in these measurements, each client causes four to \336ve disk reads. The aver-) 108 262.67 P
-0.09 (age access delay on the WREN IV disk is 29.5 milliseconds, so disk I/O entirely explains the extra) 108 249.67 P
(130 milliseconds required per client for state recovery) 108 236.67 T
(.) 344.96 236.67 T
-0.21 (Only four or \336ve reads are necessary per client, because the server does not need to read the disk) 118.8 211.67 P
-0.25 (for each descriptor referenced. LFS writes blocks of descriptors to disk, so for each read, the server) 108 198.67 P
0.04 (reads a whole block of descriptors from disk and caches them. Thus, many descriptor reads do not) 108 185.67 P
(cause I/O because the server \336nds the descriptors in its cache.) 108 172.67 T
1.32 (There are two implications for this I/O bottleneck. The \336rst is that the only way to improve) 118.8 147.67 P
-0.01 (server) 108 134.67 P
-0.01 (-driven recovery time signi\336cantly is to reduce the amount of necessary disk I/O. This could) 134.62 134.67 P
0.81 (be done by allowing clients to cache \336le descriptors and send them to the server as part of state) 108 121.67 P
0.2 (recovery) 108 108.67 P
0.2 (. Another possibility is that the server could delay reading some of the descriptors until it) 145.72 108.67 P
-0.24 (needs to use them. However) 108 95.67 P
-0.24 (, this second technique would not save as much I/O; the \336les recovered) 230.77 95.67 P
(Figure 4-5. Disk utilization during server) 184.88 400.67 T
(-driven state recovery) 365.3 400.67 T
(.) 460.38 400.67 T
1 10 Q
0.43 (This graph gives the percent of disk utilization during the state recovery phase of server) 144 378.33 P
0.43 (-) 500.67 378.33 P
1.02 (driven recovery versus the number of clients in the testbed setup. The X axis gives the) 144 367.33 P
-0.23 (number of clients in the timings, and the Y axis gives the percent utilization. There are \336ve) 144 356.33 P
-0.22 (to six data points for each number of clients, but some of the points lie on top of each other) 144 345.33 P
108 313 540 331 C
108 313 540 331 R
7 X
0 K
V
108 322 540 322 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(so they are not separately visible.) 144 334.33 T
108 426 540 720 C
108 426 540 709 C
0 0 0 539 449 399 278 123.67 429 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/serverUtilDisk.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 449
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 7360 3 just-string
200 /Times-Roman choose-font
() 7106 6608 2 just-string
() 7106 6316 2 just-string
() 7106 6024 2 just-string
() 7106 5732 2 just-string
() 7106 5440 2 just-string
() 7106 5148 2 just-string
() 7106 4856 2 just-string
() 7106 4564 2 just-string
() 7106 4272 2 just-string
() 7106 3980 2 just-string
() 7106 3688 2 just-string
() 7106 3396 2 just-string
() 7106 3104 2 just-string
() 7106 2812 2 just-string
() 7106 2520 2 just-string
() 7106 2228 2 just-string
() 7106 1936 2 just-string
() 7106 1644 2 just-string
() 7106 1352 2 just-string
() 7106 1060 2 just-string
() 7106 768 2 just-string
14 setlinewidth
[] 0 setdash
(Percent utilized) 560 6800 2 just-string
(Number of clients) 7106 380 1 just-string
(    0) 860 663 5 just-string
(   10) 860 1230 5 just-string
(   20) 860 1796 5 just-string
(   30) 860 2362 5 just-string
(   40) 860 2929 5 just-string
(   50) 860 3495 5 just-string
(   60) 860 4061 5 just-string
(   70) 860 4628 5 just-string
(   80) 860 5194 5 just-string
(   90) 860 5760 5 just-string
(  100) 860 6327 5 just-string
(    0) 1226 90 7 just-string
(    2) 2329 90 7 just-string
(    4) 3432 90 7 just-string
(    6) 4534 90 7 just-string
(    8) 5637 90 7 just-string
(   10) 6740 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  950 663 moveto
  1225 663 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1230 moveto
  1225 1230 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1796 moveto
  1225 1796 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2362 moveto
  1225 2362 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2929 moveto
  1225 2929 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3495 moveto
  1225 3495 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4061 moveto
  1225 4061 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4628 moveto
  1225 4628 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5194 moveto
  1225 5194 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5760 moveto
  1225 5760 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 6327 moveto
  1225 6327 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1226 663 moveto
  1226 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  2329 663 moveto
  2329 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  3432 663 moveto
  3432 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4534 663 moveto
  4534 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  5637 663 moveto
  5637 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6740 663 moveto
  6740 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1225 6327 moveto
  1225 663 lineto
  6740 663 lineto
  6740 6327 lineto
  1225 6327 lineto
stroke
8 setlinewidth 1777 4061 24 mark0
1777 4061 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  1777 4061 moveto
  1777 4061 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4288 24 mark0
1777 4288 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  1777 4288 moveto
  1777 4288 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4019 24 mark0
1777 4019 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  1777 4019 moveto
  1777 4019 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4288 24 mark0
1777 4288 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1777 4288 moveto
  1777 4288 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4102 24 mark0
1777 4102 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  1777 4102 moveto
  1777 4102 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5040 24 mark0
6740 5040 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6740 5040 moveto
  6740 5040 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5061 24 mark0
6740 5061 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6740 5061 moveto
  6740 5061 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 4962 24 mark0
6740 4962 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6740 4962 moveto
  6740 4962 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5181 24 mark0
6740 5181 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6740 5181 moveto
  6740 5181 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5113 24 mark0
6740 5113 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6740 5113 moveto
  6740 5113 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4557 24 mark0
2329 4557 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2329 4557 moveto
  2329 4557 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4380 24 mark0
2329 4380 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2329 4380 moveto
  2329 4380 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4557 24 mark0
2329 4557 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2329 4557 moveto
  2329 4557 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4949 24 mark0
2329 4949 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2329 4949 moveto
  2329 4949 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4734 24 mark0
2329 4734 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  2329 4734 moveto
  2329 4734 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 4611 24 mark0
2880 4611 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  2880 4611 moveto
  2880 4611 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 4584 24 mark0
2880 4584 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  2880 4584 moveto
  2880 4584 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 4709 24 mark0
2880 4709 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  2880 4709 moveto
  2880 4709 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 4687 24 mark0
2880 4687 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2880 4687 moveto
  2880 4687 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 4911 24 mark0
2880 4911 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2880 4911 moveto
  2880 4911 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5141 24 mark0
3432 5141 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3432 5141 moveto
  3432 5141 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5147 24 mark0
3432 5147 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3432 5147 moveto
  3432 5147 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5168 24 mark0
3432 5168 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3432 5168 moveto
  3432 5168 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 4817 24 mark0
3432 4817 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3432 4817 moveto
  3432 4817 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5040 24 mark0
3432 5040 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3432 5040 moveto
  3432 5040 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 4942 24 mark0
3432 4942 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  3432 4942 moveto
  3432 4942 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4881 24 mark0
3983 4881 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  3983 4881 moveto
  3983 4881 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 5029 24 mark0
3983 5029 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  3983 5029 moveto
  3983 5029 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4831 24 mark0
3983 4831 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3983 4831 moveto
  3983 4831 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4911 24 mark0
3983 4911 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3983 4911 moveto
  3983 4911 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4968 24 mark0
3983 4968 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3983 4968 moveto
  3983 4968 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4709 24 mark0
3983 4709 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3983 4709 moveto
  3983 4709 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4988 24 mark0
4534 4988 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  4534 4988 moveto
  4534 4988 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 5091 24 mark0
4534 5091 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  4534 5091 moveto
  4534 5091 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4764 24 mark0
4534 4764 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  4534 4764 moveto
  4534 4764 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4936 24 mark0
4534 4936 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  4534 4936 moveto
  4534 4936 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4709 24 mark0
4534 4709 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  4534 4709 moveto
  4534 4709 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4822 24 mark0
5086 4822 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5086 4822 moveto
  5086 4822 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4721 24 mark0
5086 4721 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5086 4721 moveto
  5086 4721 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4933 24 mark0
5086 4933 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5086 4933 moveto
  5086 4933 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4734 24 mark0
5086 4734 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5086 4734 moveto
  5086 4734 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4774 24 mark0
5086 4774 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  5086 4774 moveto
  5086 4774 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4890 24 mark0
5637 4890 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  5637 4890 moveto
  5637 4890 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4811 24 mark0
5637 4811 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  5637 4811 moveto
  5637 4811 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4951 24 mark0
5637 4951 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5637 4951 moveto
  5637 4951 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5076 24 mark0
5637 5076 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5637 5076 moveto
  5637 5076 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5014 24 mark0
5637 5014 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5637 5014 moveto
  5637 5014 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5032 24 mark0
5637 5032 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5637 5032 moveto
  5637 5032 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4929 24 mark0
6189 4929 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6189 4929 moveto
  6189 4929 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5053 24 mark0
6189 5053 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6189 5053 moveto
  6189 5053 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4689 24 mark0
6189 4689 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6189 4689 moveto
  6189 4689 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4968 24 mark0
6189 4968 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  6189 4968 moveto
  6189 4968 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5092 24 mark0
6189 5092 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  6189 5092 moveto
  6189 5092 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5015 24 mark0
6189 5015 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6189 5015 moveto
  6189 5015 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
108 426 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "70" 82
%%Page: "71" 82
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(71) 282 55 T
1 11 Q
0.58 (are either open or dirty on the clients, and in either case the server will soon need to examine an) 72 712.67 P
(access or modi\336cation date for the \336le.) 72 699.67 T
0.04 (The second implication for this I/O bottle neck is that server) 82.8 674.67 P
0.04 (-driven recovery time is very sensi-) 347.87 674.67 P
0.17 (tive to the cost of the descriptor I/O. In the course of my experiments, I found a ten percent varia-) 72 661.67 P
0.21 (tion in server) 72 648.67 P
0.21 (-driven recovery times depending upon the placement of the descriptors on disk. For) 130.17 648.67 P
0.32 (more accurate comparisons, I have made sure that the disk placement of the \336le descriptors is the) 72 635.67 P
(same throughout all the measurements in this thesis.) 72 622.67 T
1.57 (In contrast to disk I/O, the CPU is not a limiting performance factor for server) 82.8 597.67 P
1.57 (-driven state) 447.82 597.67 P
0.13 (recovery) 72 584.67 P
0.13 (. Figure 4-6 shows the percent utilization of the CPU for recovery with dif) 109.72 584.67 P
0.13 (ferent numbers) 437.67 584.67 P
(of clients. W) 72 571.67 T
(ith \336ve or more clients, the CPU remains only 55% utilized.) 128.01 571.67 T
0.22 (T) 82.8 104.67 P
0.22 (able 4-3 shows the results of several other tests. The \336rst few tests measure two optimizations) 88.74 104.67 P
0.2 (already described in the chapter on client-driven recovery: batching reopen requests and eliminat-) 72 91.67 P
(Figure 4-6. CPU utilization during server) 148.57 231.67 T
(-driven state recovery) 329.61 231.67 T
(.) 424.69 231.67 T
1 10 Q
0.23 (This graph gives the percent of CPU utilization during the state recovery phase of server) 108 209.33 P
0.23 (-) 464.67 209.33 P
1.02 (driven recovery versus the number of clients in the testbed setup. The X axis gives the) 108 198.33 P
-0.23 (number of clients in the timings, and the Y axis gives the percent utilization. There are \336ve) 108 187.33 P
-0.22 (to six data points for each number of clients, but some of the points lie on top of each other) 108 176.33 P
72 144 504 162 C
72 144 504 162 R
7 X
0 K
V
72 153 504 153 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(so they are not separately visible.) 108 165.33 T
72 257 504 550 C
72 257 504 539 C
0 0 0 539 449 397 282 87.66 257 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/serverUtilCpu.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 449
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 7360 3 just-string
200 /Times-Roman choose-font
() 7106 6608 2 just-string
() 7106 6316 2 just-string
() 7106 6024 2 just-string
() 7106 5732 2 just-string
() 7106 5440 2 just-string
() 7106 5148 2 just-string
() 7106 4856 2 just-string
() 7106 4564 2 just-string
() 7106 4272 2 just-string
() 7106 3980 2 just-string
() 7106 3688 2 just-string
() 7106 3396 2 just-string
() 7106 3104 2 just-string
() 7106 2812 2 just-string
() 7106 2520 2 just-string
() 7106 2228 2 just-string
() 7106 1936 2 just-string
() 7106 1644 2 just-string
() 7106 1352 2 just-string
() 7106 1060 2 just-string
() 7106 768 2 just-string
14 setlinewidth
[] 0 setdash
(Percent utilized) 560 6800 2 just-string
(Number of clients) 7106 380 1 just-string
(    0) 860 663 5 just-string
(   10) 860 1230 5 just-string
(   20) 860 1796 5 just-string
(   30) 860 2362 5 just-string
(   40) 860 2929 5 just-string
(   50) 860 3495 5 just-string
(   60) 860 4061 5 just-string
(   70) 860 4628 5 just-string
(   80) 860 5194 5 just-string
(   90) 860 5760 5 just-string
(  100) 860 6327 5 just-string
(    0) 1226 90 7 just-string
(    2) 2329 90 7 just-string
(    4) 3432 90 7 just-string
(    6) 4534 90 7 just-string
(    8) 5637 90 7 just-string
(   10) 6740 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  950 663 moveto
  1225 663 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1230 moveto
  1225 1230 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1796 moveto
  1225 1796 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2362 moveto
  1225 2362 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2929 moveto
  1225 2929 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3495 moveto
  1225 3495 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4061 moveto
  1225 4061 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4628 moveto
  1225 4628 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5194 moveto
  1225 5194 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5760 moveto
  1225 5760 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 6327 moveto
  1225 6327 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1226 663 moveto
  1226 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  2329 663 moveto
  2329 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  3432 663 moveto
  3432 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4534 663 moveto
  4534 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  5637 663 moveto
  5637 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6740 663 moveto
  6740 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1225 6327 moveto
  1225 663 lineto
  6740 663 lineto
  6740 6327 lineto
  1225 6327 lineto
stroke
8 setlinewidth 1777 3259 24 mark0
1777 3259 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  1777 3259 moveto
  1777 3259 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3090 24 mark0
1777 3090 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  1777 3090 moveto
  1777 3090 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3020 24 mark0
1777 3020 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  1777 3020 moveto
  1777 3020 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3285 24 mark0
1777 3285 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1777 3285 moveto
  1777 3285 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3127 24 mark0
1777 3127 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  1777 3127 moveto
  1777 3127 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3717 24 mark0
6740 3717 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6740 3717 moveto
  6740 3717 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3797 24 mark0
6740 3797 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6740 3797 moveto
  6740 3797 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3924 24 mark0
6740 3924 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6740 3924 moveto
  6740 3924 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3803 24 mark0
6740 3803 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6740 3803 moveto
  6740 3803 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3789 24 mark0
6740 3789 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6740 3789 moveto
  6740 3789 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3384 24 mark0
2329 3384 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2329 3384 moveto
  2329 3384 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3365 24 mark0
2329 3365 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2329 3365 moveto
  2329 3365 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3290 24 mark0
2329 3290 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2329 3290 moveto
  2329 3290 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2965 24 mark0
2329 2965 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2329 2965 moveto
  2329 2965 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3194 24 mark0
2329 3194 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  2329 3194 moveto
  2329 3194 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3430 24 mark0
2880 3430 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  2880 3430 moveto
  2880 3430 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3586 24 mark0
2880 3586 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  2880 3586 moveto
  2880 3586 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3263 24 mark0
2880 3263 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  2880 3263 moveto
  2880 3263 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3552 24 mark0
2880 3552 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2880 3552 moveto
  2880 3552 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3399 24 mark0
2880 3399 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2880 3399 moveto
  2880 3399 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3651 24 mark0
3432 3651 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3432 3651 moveto
  3432 3651 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3367 24 mark0
3432 3367 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3432 3367 moveto
  3432 3367 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3608 24 mark0
3432 3608 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3432 3608 moveto
  3432 3608 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3519 24 mark0
3432 3519 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3432 3519 moveto
  3432 3519 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3648 24 mark0
3432 3648 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3432 3648 moveto
  3432 3648 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3535 24 mark0
3432 3535 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  3432 3535 moveto
  3432 3535 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3880 24 mark0
3983 3880 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  3983 3880 moveto
  3983 3880 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3875 24 mark0
3983 3875 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  3983 3875 moveto
  3983 3875 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3600 24 mark0
3983 3600 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3983 3600 moveto
  3983 3600 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3844 24 mark0
3983 3844 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3983 3844 moveto
  3983 3844 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3699 24 mark0
3983 3699 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3983 3699 moveto
  3983 3699 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3858 24 mark0
3983 3858 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3983 3858 moveto
  3983 3858 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3871 24 mark0
4534 3871 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  4534 3871 moveto
  4534 3871 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3886 24 mark0
4534 3886 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  4534 3886 moveto
  4534 3886 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3714 24 mark0
4534 3714 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  4534 3714 moveto
  4534 3714 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3782 24 mark0
4534 3782 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  4534 3782 moveto
  4534 3782 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3776 24 mark0
4534 3776 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  4534 3776 moveto
  4534 3776 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3774 24 mark0
5086 3774 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5086 3774 moveto
  5086 3774 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3729 24 mark0
5086 3729 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5086 3729 moveto
  5086 3729 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3767 24 mark0
5086 3767 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5086 3767 moveto
  5086 3767 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3864 24 mark0
5086 3864 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5086 3864 moveto
  5086 3864 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3803 24 mark0
5086 3803 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  5086 3803 moveto
  5086 3803 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3919 24 mark0
5637 3919 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  5637 3919 moveto
  5637 3919 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3820 24 mark0
5637 3820 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  5637 3820 moveto
  5637 3820 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3867 24 mark0
5637 3867 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5637 3867 moveto
  5637 3867 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3549 24 mark0
5637 3549 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5637 3549 moveto
  5637 3549 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3871 24 mark0
5637 3871 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5637 3871 moveto
  5637 3871 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3854 24 mark0
5637 3854 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5637 3854 moveto
  5637 3854 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3850 24 mark0
6189 3850 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6189 3850 moveto
  6189 3850 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3684 24 mark0
6189 3684 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6189 3684 moveto
  6189 3684 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3647 24 mark0
6189 3647 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6189 3647 moveto
  6189 3647 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3899 24 mark0
6189 3899 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  6189 3899 moveto
  6189 3899 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3790 24 mark0
6189 3790 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  6189 3790 moveto
  6189 3790 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3635 24 mark0
6189 3635 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6189 3635 moveto
  6189 3635 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
72 257 504 550 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "71" 83
%%Page: "72" 83
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(72) 318 55 T
1 11 Q
0.28 (ing unnecessary state. The last two tests show the overhead for reopening \336les that are not shared) 108 712.67 P
(between clients.) 108 699.67 T
1.14 ( A comparison of the \336rst two measurements,) 118.8 674.67 P
2 F
1.14 ( Unoptimized) 326.97 674.67 P
1 F
1.14 ( and) 387.01 674.67 P
2 F
1.14 (Batching r) 410.65 674.67 P
1.14 (eopens) 458.08 674.67 P
1 F
1.14 (, shows the) 488.58 674.67 P
0.35 (bene\336ts of reducing client/server communication. The two tests are the same, except that) 108 297.67 P
2 F
0.35 (Unopti-) 505.82 297.67 P
-0.15 (mized) 108 284.67 P
1 F
-0.15 ( requires 790 RPCs per client for \336le I/O handles and 90 for streams, while) 133.63 284.67 P
2 F
-0.15 ( Batching r) 460.76 284.67 P
-0.15 (eopens) 509.49 284.67 P
1 F
1.36 (packs all its \336le I/O handle reopens into three RPCs per client with a fourth RPC for streams.) 108 271.67 P
0.95 (These two tests thus transfer the same amount of data and reopen the same number of \336les and) 108 258.67 P
-0.26 (streams on the server) 108 245.67 P
-0.26 (, but) 199.84 245.67 P
2 F
-0.26 (Batching r) 221.6 245.67 P
-0.26 (eopens) 267.62 245.67 P
1 F
-0.26 ( does so with about 786 fewer RPCs per client. The dif-) 298.13 245.67 P
0.4 (ference in timings between these tests shows us part of the cost on the server to process the extra) 108 232.67 P
1.31 (RPCs. \050It does not show us the entire cost, because the) 108 219.67 P
2 F
1.31 (Unoptimized) 364.99 219.67 P
1 F
1.31 ( test is CPU bound, while) 421.14 219.67 P
2 F
0.22 (Batching r) 108 206.67 P
0.22 (eopens) 154.51 206.67 P
1 F
0.22 ( is I/O bound.\051 The cost includes the time for the client to issue the RPC, for the) 185.01 206.67 P
-0.03 (server to receive it, and for the server to process it to the point of allocating an RPC server process) 108 193.67 P
0.65 (for the request. The cost does not include data transfer time, collecting the recovery state for the) 108 180.67 P
1.56 (request on the client, or processing the actual reopen on the server) 108 167.67 P
1.56 (. This is because both tests) 415.02 167.67 P
0.77 (reopen the same number of things. The savings from this optimization is 5.77 seconds, which is) 108 154.67 P
-0 (0.58 seconds per client, or about 0.66 milliseconds per RPC. The actual cost of a round-trip empty) 108 141.67 P
-0.04 (RPC between a DECstation 5000 client and a SP) 108 128.67 P
-0.04 (ARCstation-2 server) 321.54 128.67 P
-0.04 (, veri\336ed through direct mea-) 411.69 128.67 P
(surement, is 0.83 milliseconds.) 108 115.67 T
108 81 540 720 C
110.02 312 537.98 671 C
108.02 320 542.02 667 R
7 X
0 K
V
1 11 Q
0 X
(T) 213.85 466.67 T
(able 4-3. Other server) 219.79 466.67 T
(-driven state recovery tests.) 315.36 466.67 T
1 10 Q
0.22 (This table gives the times for dif) 144.02 442.33 P
0.22 (ferent measurements of server) 275.09 442.33 P
0.22 (-driven state recovery from) 396.28 442.33 P
1.19 (the testbed setup, excluding the time to handle the client list \336le.) 144.02 431.33 P
2 F
1.19 (Unoptimized) 418.13 431.33 P
1 F
1.19 ( uses the) 469.22 431.33 P
0.83 (same experimental setup as the basic server) 144.02 420.33 P
0.83 (-driven timing, but includes neither recovery) 323.1 420.33 P
0.37 (protocol optimization \050batching reopen requests or reopening only necessary cache state\051.) 144.02 409.33 P
2 F
2.34 (Batching r) 144.02 398.33 P
2.34 (eopens) 188.47 398.33 P
1 F
2.34 ( adds the optimization of batching reopen requests.) 216.22 398.33 P
2 F
2.34 ( Necessary state) 436.37 398.33 P
1 F
1.64 (recovers only necessary cache state, but does not batch reopen requests.) 144.02 387.33 P
2 F
1.64 (Basic server) 451.56 387.33 P
1.64 (-) 502.69 387.33 P
0.37 (driven) 144.02 376.33 P
1 F
0.37 ( uses both optimizations and is included again here for comparison) 169.55 376.33 P
2 F
0.37 (. No \336les shar) 440.31 376.33 P
0.37 (ed) 496.58 376.33 P
1 F
0.83 (uses all optimizations, and the per) 144.02 365.33 P
0.83 (-client state setup is the same except that no reopened) 283.99 365.33 P
0.79 (\336les are shared.) 144.02 354.33 P
2 F
0.79 (All \336les shar) 211.33 354.33 P
0.79 (ed) 263.07 354.33 P
1 F
0.79 ( is the same except that all reopened \336les are shared. All) 272.51 354.33 P
110.02 322 537.98 340 C
108.02 322 542.02 340 R
7 X
0 K
V
108.02 331 540.02 331 2 L
V
0.5 H
2 Z
0 X
N
110.02 312 537.98 671 C
1 10 Q
0 X
0 K
(tests were run \336ve times.) 144.02 343.33 T
(T) 170 627.33 T
(est) 175.4 627.33 T
(A) 235.39 627.33 T
(verage time) 241.87 627.33 T
(\050seconds\051) 242.93 615.33 T
(Standard devi-) 305.05 627.33 T
(ation) 324.33 615.33 T
(CPU utilization) 374.56 627.33 T
(\050%\051) 398.3 615.33 T
-0.46 (Disk utilization) 449.35 627.33 P
(\050%\051) 472.82 615.33 T
(Unoptimized) 137.18 597.33 T
1 11 Q
(16.62) 238.12 596.67 T
(0.21) 315.63 596.67 T
(85) 382.62 596.67 T
(55) 458.56 596.67 T
1 10 Q
(Batching reopens) 137.18 578.33 T
1 11 Q
(10.85) 238.12 577.67 T
(0.20) 315.63 577.67 T
(45) 382.62 577.67 T
(80) 458.56 577.67 T
1 10 Q
(Necessary state) 137.18 559.33 T
1 11 Q
(2.53) 238.12 558.67 T
(0.06) 315.63 558.67 T
(78) 382.62 558.67 T
(50) 458.56 558.67 T
1 10 Q
(Basic server) 137.18 540.33 T
(-driven) 186.1 540.33 T
1 11 Q
(1.70) 238.12 539.67 T
(0.03) 315.63 539.67 T
(55) 382.62 539.67 T
(78) 458.56 539.67 T
1 10 Q
(No \336les shared) 137.18 521.33 T
1 11 Q
(1.90) 238.12 520.67 T
(0.05) 315.63 520.67 T
(55) 382.62 520.67 T
(82) 458.56 520.67 T
1 10 Q
(All \336les shared) 137.18 502.33 T
1 11 Q
(0.70) 238.12 501.67 T
(0.02) 315.63 501.67 T
(85) 382.62 501.67 T
(30) 458.56 501.67 T
133.18 637 133.18 495 2 L
V
2 H
0 Z
N
223.32 639 223.32 493 2 L
V
N
300.83 639 300.83 493 2 L
V
0.5 H
N
367.82 639 367.82 493 2 L
V
N
443.76 639 443.76 493 2 L
V
N
516.85 637 516.85 495 2 L
V
2 H
N
132.18 638 517.85 638 2 L
V
N
134.18 609.25 515.85 609.25 2 L
V
0.5 H
N
134.18 606.75 515.85 606.75 2 L
V
N
132.18 589 517.85 589 2 L
V
N
132.18 570 517.85 570 2 L
V
N
132.18 551 517.85 551 2 L
V
N
132.18 532 517.85 532 2 L
V
N
132.18 513 517.85 513 2 L
V
N
132.18 494 517.85 494 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "72" 84
%%Page: "73" 84
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(73) 282 55 T
1 11 Q
-0.22 (A comparison of the \336rst and third tests,) 82.8 712.67 P
2 F
-0.22 ( Unoptimized) 258.26 712.67 P
1 F
-0.22 ( and) 316.94 712.67 P
2 F
-0.22 (Necessary state) 337.87 712.67 P
1 F
-0.22 (, shows us the bene\336ts) 406.3 712.67 P
0.62 (of reducing the amount of state recovered. As described in the previous chapter) 72 699.67 P
0.62 (, clients keep \336le) 427.69 699.67 P
-0.27 (handles for \336les that are neither open nor dirty) 72 686.67 P
-0.27 (, but for which they may have clean cached data. It is) 272.95 686.67 P
-0.07 (not necessary to reopen these \336les during recovery) 72 673.67 P
-0.07 (. In the average case, this cuts the recovery state) 293.21 673.67 P
0.4 (to about one-\336fth what an unoptimized client would recover) 72 660.67 P
0.4 (, eliminating 700 reopen requests per) 339.04 660.67 P
0.49 (client. As seen in T) 72 647.67 P
0.49 (able 4-3, this state reduction makes a signi\336cant dif) 158.32 647.67 P
0.49 (ference in recovery times:) 388.13 647.67 P
(14.09 seconds, or 1.4 seconds per client.) 72 634.67 T
0.27 (A comparison of the tests) 82.8 609.67 P
2 F
0.27 (No \336les shar) 199.17 609.67 P
0.27 (ed) 254.84 609.67 P
1 F
0.27 ( and) 265.21 609.67 P
2 F
0.27 (All \336les shar) 287.1 609.67 P
0.27 (ed) 342.77 609.67 P
1 F
0.27 ( gives us the dif) 353.14 609.67 P
0.27 (ference in cost for) 423.58 609.67 P
0.93 (reopening shared and unshared \336les. Although \336le sharing may increase costs in normal system) 72 596.67 P
0.68 (operation \050due to cache consistency overhead\051, it reduces recovery time. As explained in section) 72 583.67 P
0.17 (3.2, the server performs less work to reopen a \336le already reopened \050shared\051 by another client.) 72 570.67 P
2 F
0.17 (No) 491.18 570.67 P
0.38 (\336les shar) 72 557.67 P
0.38 (ed) 111.96 557.67 P
1 F
0.38 ( uses the same per) 122.33 557.67 P
0.38 (-client setup as the basic server) 203.59 557.67 P
0.38 (-driven measurement, except that no) 342.28 557.67 P
0.3 (client reopens any shared \336les. Each client still reopens 90 \336les and 90 streams apiece. But of the) 72 544.67 P
0.22 (90 \336les, none is shared with another client. Even the \336les repeatedly truncated and written by two) 72 531.67 P
0.14 (clients are unshared. In contrast,) 72 518.67 P
2 F
0.14 (All \336les shar) 217.61 518.67 P
0.14 (ed) 273.02 518.67 P
1 F
0.14 ( reopens the same number of \336les and streams per) 283.39 518.67 P
-0.09 (client, but the set of \336les is the same across all the clients, so the server performs no extra work for) 72 505.67 P
0.46 (nine out of the ten clients. This dif) 72 492.67 P
0.46 (ference for nine out of ten clients gives a cost of 190 millisec-) 226.36 492.67 P
0.03 (onds per client with distinct \336les, and 57 milliseconds per client with shared \336les. Given that there) 72 479.67 P
0.34 (are 90 \336le I/O handles per client, this represents an extra cost of about 1.5 milliseconds to reopen) 72 466.67 P
0.73 (an individual unshared \336le versus a shared \336le. However) 72 453.67 P
0.73 (, this calculation does not scale linearly) 326.64 453.67 P
0.48 (with the amount of \336le sharing; as the test moves from sharing no \336les to sharing all \336les, it also) 72 440.67 P
(moves from being I/O bound to being CPU bound.) 72 427.67 T
0 14 Q
(4.4. Summary) 72 394.67 T
1 11 Q
1.09 (Server) 82.8 368.67 P
1.09 (-driven recovery is a modi\336cation of client-driven recovery with several advantages. It) 111.25 368.67 P
0.3 (eliminates cache consistency violations; it is faster; and it allows the server more control over the) 72 355.67 P
1.17 (recovery process. For these reasons, server) 72 342.67 P
1.17 (-driven recovery is likely to be the distributed cache) 265.84 342.67 P
(state recovery technique of choice for many \336le systems.) 72 329.67 T
1.6 (Server) 82.8 304.67 P
1.6 (-driven recovery also has several problems. It requires more special-purpose recovery) 111.25 304.67 P
0.93 (code and more synchronization and locking in the kernel. Despite the server) 72 291.67 P
0.93 (\325) 417.02 291.67 P
0.93 (s control, recovery) 420.08 291.67 P
1.38 (speed is still vulnerable to client misbehavior) 72 278.67 P
1.38 (. The server depends upon clients to send it their) 278.62 278.67 P
1 (state, so it can only recover as quickly as the slowest client. Server) 72 265.67 P
1 (-driven recovery in Sprite is) 376.72 265.67 P
1.03 (disk I/O bound, so it can only be improved by reducing necessary I/O during recovery) 72 252.67 P
1.03 (. Finally) 464.31 252.67 P
1.03 (,) 501.25 252.67 P
0.3 (server) 72 239.67 P
0.3 (-driven recovery requires extra disk I/Os and processing to handle the client list \336le, so it is) 98.62 239.67 P
(not as fast as transparent recovery) 72 226.67 T
(, the subject of the next chapter) 220.47 226.67 T
(.) 357.47 226.67 T
FMENDPAGE
%%EndPage: "73" 85
%%Page: "74" 85
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(74) 318 55 T
108 666 540 720 C
108 666 540 720 R
7 X
0 K
V
108 693 540 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
108 594 540 648 C
108 594 540 648 R
7 X
0 K
V
108 603 540 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(5) 144 638 T
0 18 Q
(T) 180 654 T
(ranspar) 190.67 654 T
(ent Recovery) 251.31 654 T
1 11 Q
0.41 (This chapter describes transparent recovery) 118.8 519.67 P
0.41 (, in which the server recovers without communicat-) 310.71 519.67 P
0.23 (ing with its clients. I call it transparent, because the clients do not participate in recovery) 108 506.67 P
0.23 (. Instead,) 499.8 506.67 P
-0.01 (client RPCs to the \336le server simply hang until the server \336nishes recovery and re-enables its RPC) 108 493.67 P
-0.05 (service. At this point it services the RPCs, and the clients continue processing. This recovery tech-) 108 480.67 P
0.74 (nique avoids client/server communication during recovery by keeping the distributed \336le system) 108 467.67 P
0.22 (state in stable storage on the \336le server) 108 454.67 P
0.22 (. The \336le server can then regenerate the state after a failure) 279.5 454.67 P
0.78 (without contacting its client workstations for information. By eliminating communication, trans-) 108 441.67 P
0.06 (parent recovery also eliminates the server) 108 428.67 P
0.06 (\325) 291.43 428.67 P
0.06 (s dependency upon its clients for recovery speed and its) 294.49 428.67 P
0.11 (need for a client list \336le. W) 108 415.67 P
0.11 (ith no client list \336le, transparent recovery executes fewer disk I/Os and) 228.15 415.67 P
0.34 (is thus the fastest form of distributed state recovery) 108 402.67 P
0.34 (. For ten clients in the testbed setup, this tech-) 335.21 402.67 P
1.36 (nique takes only 1.5 seconds compared to 2.0 for server) 108 389.67 P
1.36 (-driven recovery) 364.99 389.67 P
1.36 (. T) 438.53 389.67 P
1.36 (ransparent recovery) 451.71 389.67 P
1.64 (scales linearly with the number of clients. Like server) 108 376.67 P
1.64 (-driven recovery it is disk I/O bound in) 356.74 376.67 P
0.32 (Sprite and requires an extra 130 milliseconds per client, all of which is spent reading \336le descrip-) 108 363.67 P
-0.18 (tors from disk. However) 108 350.67 P
-0.18 (, transparent recovery presents more opportunities to reduce the amount of) 214.42 350.67 P
(necessary disk I/O.) 108 337.67 T
1.34 (The key element of transparent recovery is the) 118.8 312.67 P
2 F
1.34 (r) 336.37 312.67 P
1.34 (ecovery box) 340.24 312.67 P
1 F
1.34 (, which is the stable storage the) 394.35 312.67 P
0.57 (server uses to hold its distributed state. What is most interesting about the recovery box is that it) 108 299.67 P
0.65 (turns main memory into a form of stable storage; the recovery box is just an area of the server) 108 286.67 P
0.65 (\325) 532.67 286.67 P
0.65 (s) 535.73 286.67 P
1.13 (main memory that is preserved across failures. During normal execution, the server) 108 273.67 P
1.13 (\325) 487.3 273.67 P
1.13 (s operating) 490.35 273.67 P
0.16 (system inserts backup copies of \336le system and cache state information in the recovery box. After) 108 260.67 P
0.05 (a failure, the system retrieves these items from the box and uses them to regenerate the distributed) 108 247.67 P
(state information. The recovery box enables these activities to proceed at main-memory speeds.) 108 234.67 T
0.25 (The recovery box interface is designed to avoid memory corruption, since this would render its) 118.8 209.67 P
-0.04 (contents useless. When the system inserts an item into the recovery box, it also inserts a checksum) 108 196.67 P
0.75 (for the item. After a failure, the system examines the checksums for the items it retrieves. If the) 108 183.67 P
0.51 (software checksum detects corruption, the system clears the recovery box memory and reverts to) 108 170.67 P
1.34 (some more traditional form of recovery or a complete system reboot, as described later in this) 108 157.67 P
0 (chapter) 108 144.67 P
0 (. Fortunately) 139.73 144.67 P
0 (, error statistics presented in this chapter show that failures are unlikely to cor-) 195.17 144.67 P
(rupt the recovery box. Also, the recovery box memory can be write-protected in hardware.) 108 131.67 T
-0.06 (Besides its performance bene\336ts, an advantage of the recovery box is that it can be used for safe) 118.8 106.67 P
1.08 (storage by other parts of the operating system and by user) 108 93.67 P
1.08 (-level applications such as databases.) 372.44 93.67 P
FMENDPAGE
%%EndPage: "74" 86
%%Page: "75" 86
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(75) 282 55 T
1 11 Q
0.43 (Later in this chapter I describe how a distributed version of the POSTGRES database [Stoneb86]) 72 712.67 P
0.14 (uses the recovery box for fast crash recovery) 72 699.67 P
0.14 (. The recovery box is generally useful for any system) 269.03 699.67 P
-0.16 (that wishes to preserve state information across failures, if it is possible to isolate the state updates,) 72 686.67 P
0.57 (and if the state items have the following properties. The items to store should be 1\051 expensive to) 72 673.67 P
1.04 (regenerate from scratch, 2\051 small, 3\051 updated too frequently to store on disk, and 4\051 unlikely to) 72 660.67 P
(propagate the error that caused the system crash.) 72 647.67 T
-0.12 (Despite these advantages, there are at least four problems with transparent recovery) 82.8 622.67 P
-0.12 (. First, trans-) 448.09 622.67 P
0.51 (parent recovery requires more special-purpose code than the other recovery techniques; the addi-) 72 609.67 P
-0.22 (tional code is needed to implement the recovery box, maintain its contents, and rebuild the server) 72 596.67 P
-0.22 (\325) 496.67 596.67 P
-0.22 (s) 499.73 596.67 P
-0.1 (\336le system state from its contents after a failure. Second, transparent recovery is prone to inconsis-) 72 583.67 P
0.91 (tencies between the clients and the server; while avoiding recovery communication between the) 72 570.67 P
0.65 (server and clients reduces recovery time, it also removes an opportunity for server and clients to) 72 557.67 P
-0.16 (re-synchronize their state information. Third, the recovery box is dif) 72 544.67 P
-0.16 (\336cult to incorporate into a sys-) 370.25 544.67 P
-0.1 (tem in which operations that change the \336le system state, such as opens and closes, are hard to iso-) 72 531.67 P
-0.27 (late or handle atomically) 72 518.67 P
-0.27 (. It is often hard to isolate these operations in Sprite, and this is likely to be) 179.4 518.67 P
-0.12 (true in many other distributed \336le systems. Finally) 72 505.67 P
-0.12 (, transparent recovery does not necessarily elim-) 292.04 505.67 P
1.42 (inate the need for a communication-based form of recovery) 72 492.67 P
1.42 (, depending on the desired level of) 343.82 492.67 P
-0.26 (robustness. Recovery box corruption is unlikely) 72 479.67 P
-0.26 (, but if it occurs we may wish to recover the system) 280.51 479.67 P
(with client-driven or server) 72 466.67 T
(-driven recovery) 191.68 466.67 T
(, rather than reboot all the clients.) 263.88 466.67 T
0.23 (This chapter \336rst motivates the use of the recovery box for storing distributed state information) 82.8 441.67 P
0.89 (locally on the \336le server) 72 428.67 P
0.89 (. As part of this \336rst section I list other possible storage techniques and) 181.15 428.67 P
-0.02 (explain why they are less satisfactory) 72 415.67 P
-0.02 (. I then list the failure statistics that indicate the recovery box) 235.66 415.67 P
0.74 (memory should be free from corruption after most failures. Section 5.2 describes the design and) 72 402.67 P
0.93 (implementation of the recovery box. This includes a description of the interface to the recovery) 72 389.67 P
1.09 (box functions, a description of the internal recovery box structure, and a list of implementation) 72 376.67 P
0.66 (shortcomings. Section 5.3 explains how Sprite incorporates the recovery box for transparent dis-) 72 363.67 P
1.02 (tributed state recovery) 72 350.67 P
1.02 (. Section 5.4 gives measurements of transparent crash recovery times and) 171.57 350.67 P
0.1 (measurements of \336le system performance degradation due to maintaining the recovery box during) 72 337.67 P
-0.16 (normal execution. Section 5.5 explains some overall disadvantages of transparent recovery and the) 72 324.67 P
0.03 (recovery box. Section 5.6 lists two trends in \336le system design and their implications for using the) 72 311.67 P
0.1 (recovery box: asynchronous operations and stateful \336le servers. Section 5.7 explains how applica-) 72 298.67 P
0.47 (ble the recovery box is to other systems. The \336nal section describes recovery box use for distrib-) 72 285.67 P
4.7 (uted crash recovery in a user) 72 272.67 P
4.7 (-level application, the POSTGRES database, and includes) 221.29 272.67 P
(application-level performance measurements.) 72 259.67 T
0 14 Q
(5.1. Motivation for the Recovery Box) 72 226.67 T
1 11 Q
0.18 (T) 82.8 200.67 P
0.18 (o avoid communication with clients for distributed state recovery) 88.74 200.67 P
0.18 (, the \336le server must store its) 376.29 200.67 P
0.66 (distributed state locally) 72 187.67 P
0.66 (. There are two requirements for this local storage: high performance and) 175.15 187.67 P
-0 (persistence across most failures. This section motivates why I\325ve chosen main-memory storage, in) 72 174.67 P
(the form of the recovery box, as most likely to meet these requirements.) 72 161.67 T
0.77 (Keeping a persistent copy of the distributed state in the server) 82.8 136.67 P
0.77 (\325) 362.51 136.67 P
0.77 (s main memory means that the) 365.56 136.67 P
0.5 (\336le server can update this stored cache state information at main memory speeds, avoiding much) 72 123.67 P
0.02 (performance degradation during normal operation. The recovery box is just an area of memory set) 72 110.67 P
1.3 (aside for access only by the recovery box code. T) 72 97.67 P
1.3 (o insert an item of state information into the) 300.14 97.67 P
0.98 (recovery box, the \336le server kernel simply calls the recovery box procedure) 72 84.67 P
2 F
0.98 (InsertItem) 418.44 84.67 P
1 F
0.98 ( with the) 463.59 84.67 P
FMENDPAGE
%%EndPage: "75" 87
%%Page: "76" 87
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(76) 318 55 T
1 11 Q
0.24 (item as a parameter) 108 712.67 P
0.24 (. The recovery box code copies the item into its area of memory) 193.85 712.67 P
0.24 (. After a crash) 477.05 712.67 P
0.58 (the kernel recovers the state information quickly from its own memory by calling) 108 699.67 P
2 F
0.58 (ReturnItemAr-) 475.93 699.67 P
0.83 (ray) 108 686.67 P
1 F
0.83 (. The recovery box code copies the array of preserved items from its memory back out to its) 121.93 686.67 P
(caller) 108 673.67 T
(. This interface is described in more detail in section 5.2.1.) 131.8 673.67 T
-0.24 (This technique contrasts with more traditional ones that store the distributed state on the server) 118.8 648.67 P
-0.24 (\325) 532.67 648.67 P
-0.24 (s) 535.73 648.67 P
-0.22 (disk or in the memory of a backup machine. Section 5.1.1 lists some of these more traditional tech-) 108 635.67 P
(niques and explains why they are slower or more complex.) 108 622.67 T
0.15 (The second requirement for the recovery box is to preserve the distributed state across the most) 118.8 597.67 P
0.04 (common types of failures. The recovery box memory can be implemented with non-volatile RAM) 108 584.67 P
0.14 (for persistence across power failures, but further ef) 108 571.67 P
0.14 (forts are required to ensure that its contents are) 332.67 571.67 P
-0.14 (not corrupted by errors in the kernel code or by hardware glitches. The recovery box is designed to) 108 558.67 P
1.28 (detect memory corruption so that the system does not try to recover incorrect distributed state.) 108 545.67 P
-0.21 (Whenever an item is inserted in the recovery box, the recovery box code also calculates and inserts) 108 532.67 P
-0.22 (a checksum for the item. When the items are retrieved, the recovery box examines their checksums) 108 519.67 P
(and reports a failure if they are not correct.) 108 506.67 T
1.37 (While this technique detects the existence of memory corruption, the question remains as to) 118.8 481.67 P
0.71 (how often such corruption is likely to occur) 108 468.67 P
0.71 (. If it occurs often, then the recovery box will fail to) 304.29 468.67 P
0.8 (provide fast recovery after most failures. Storing the cache state information in main memory is) 108 455.67 P
0.2 (only reasonable if we can protect and preserve that area of memory across failures. Sections 5.1.2) 108 442.67 P
0.73 (and 5.1.3 give two reasons why we can preserve the recovery box memory across most failures.) 108 429.67 P
-0.25 (First, statistics about the types and distribution of system failures show that the recovery box mem-) 108 416.67 P
0.63 (ory is unlikely to be corrupted by failures. Second, we can also use hardware write-protection to) 108 403.67 P
(prevent recovery box corruption.) 108 390.67 T
0 12 Q
(5.1.1. Storing Distributed State) 108 359 T
1 11 Q
0.18 (This section describes two alternate ways to store the distributed state information: on the serv-) 118.8 333.67 P
0.9 (er) 108 320.67 P
0.9 (\325) 116.94 320.67 P
0.9 (s disk, or in the main memory of another machine. I have not implemented these techniques,) 120 320.67 P
(because they have disadvantages that led me to believe that the recovery box is preferable.) 108 307.67 T
0 12 Q
(5.1.1.1. Disk Storage) 108 276 T
1 11 Q
-0.23 (The simplest way to maintain the distributed state information is to keep a copy of it on the serv-) 118.8 250.67 P
0.6 (er) 108 237.67 P
0.6 (\325) 116.94 237.67 P
0.6 (s disk, as is done with the client list for server) 120 237.67 P
0.6 (-driven recovery) 326.9 237.67 P
0.6 (. Whenever a client requests an) 399.7 237.67 P
-0.21 (operation that changes the distributed state information, the server can record the change in its disk) 108 224.67 P
0.68 (copy before responding to the client. Recording the change synchronously \050before responding to) 108 211.67 P
0.3 (the client\051 ensures that the state remains consistent between the server and client in the event of a) 108 198.67 P
(server crash.) 108 185.67 T
0.44 (Unfortunately) 118.8 160.67 P
0.44 (, the state needed for \336le cache consistency changes too frequently to be updated) 179.72 160.67 P
1.48 (synchronously on disk without performance penalty) 108 147.67 P
1.48 (. As explained in chapter 2, the distributed) 343.22 147.67 P
1.14 (state information changes on the server whenever a client workstation opens or closes a \336le. A) 108 134.67 P
0.61 (synchronous disk write for each change adds too much latency to \336le open and close operations.) 108 121.67 P
0.14 (The combination of a remote open and close operation on a Sprite client takes only about 3.5 mil-) 108 108.67 P
0.64 (liseconds, while a disk write takes 15 to 30 milliseconds, depending on the disk. In addition, the) 108 95.67 P
FMENDPAGE
%%EndPage: "76" 88
%%Page: "77" 88
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(77) 282 55 T
1 11 Q
0.52 (cache state information is sometimes updated with a frequency that would require too many disk) 72 712.67 P
0.24 (accesses. On average, the server sees two to four pairs of \336le open/close operations every second,) 72 699.67 P
0.14 (which would require six to eight extra disk accesses. During periods of bursty \336le system activity) 72 686.67 P
0.14 (,) 501.25 686.67 P
0.11 (the server sees as many as 50 pairs of open/close operations in a second, which would require one) 72 673.67 P
-0.15 (hundred disk accesses in a second. This is unreasonable for the average server with only \336ve or six) 72 660.67 P
(disks, even if the updates are divided evenly among the disks and handled in parallel.) 72 647.67 T
0.87 (Storing the server) 82.8 622.67 P
0.87 (\325) 163.05 622.67 P
0.87 (s state information on disk thus requires some more complicated approach,) 166.1 622.67 P
0.02 (such as batching together state changes resulting from many client requests into fewer disk writes.) 72 609.67 P
-0.22 (This amortizes the cost of the disk I/O on the \336le server) 72 596.67 P
-0.22 (. But the performance overhead seen by cli-) 313.36 596.67 P
-0.07 (ents depends upon whether these batched updates are done synchronously or asynchronously) 72 583.67 P
-0.07 (, with) 479.05 583.67 P
(respect to the clients\325 RPC requests.) 72 570.67 T
-0.21 (If the server performs the I/O synchronously) 82.8 545.67 P
-0.21 (, before responding to the client RPC request, it will) 276.71 545.67 P
1.19 (not lose recent state updates if it crashes. However) 72 532.67 P
1.19 (, this delays response to all the RPCs in the) 303.48 532.67 P
-0.19 (batch by at least the length of a disk write, increasing the overhead of all client open requests by an) 72 519.67 P
(order of magnitude.) 72 506.67 T
1.99 (Performing the batched updates asynchronously with respect to the client RPCs allows the) 82.8 481.67 P
0.76 (server to respond to the client RPCs immediately) 72 468.67 P
0.76 (, but it is more complicated. It is more compli-) 292.37 468.67 P
0.53 (cated because the server and clients must do extra work to ensure that state information does not) 72 455.67 P
0.5 (become inconsistent. The state can become inconsistent if the server crashes after replying to the) 72 442.67 P
0.21 (client RPCs but before it writes the updates to disk. T) 72 429.67 P
0.21 (o combat this problem, we can use a combi-) 308.59 429.67 P
-0.16 (nation of server) 72 416.67 P
-0.16 (-driven and transparent recovery) 140.42 416.67 P
-0.16 (. Clients must save enough information about their) 282.32 416.67 P
2.48 (requests to resend the necessary information to the server if it crashes before recording the) 72 403.67 P
0.55 (updates. If the server forces all updates to disk every 30 seconds, clients can discard information) 72 390.67 P
0.31 (about requests older than 30 seconds. During recovery) 72 377.67 P
0.31 (, the clients resend the state updates for the) 312.66 377.67 P
-0.21 (last 30 seconds to the server) 72 364.67 P
-0.21 (. The server then updates its distributed state information before allow-) 193.93 364.67 P
-0.04 (ing the clients to continue normal operation. The disadvantage of this scheme is that it is not much) 72 351.67 P
0.59 (better than server) 72 338.67 P
0.59 (-driven recovery) 149.22 338.67 P
0.59 (, and it isn\325) 222 338.67 P
0.59 (t transparent recovery) 273 338.67 P
0.59 (, because it still requires com-) 369.25 338.67 P
1.49 (munication during recovery) 72 325.67 P
1.49 (. All it does is reduce the amount of state sent to the server) 196.31 325.67 P
1.49 (. Since) 472.61 325.67 P
0.26 (server) 72 312.67 P
0.26 (-driven recovery is simpler and almost as fast, we might as well skip storing the state infor-) 98.62 312.67 P
(mation on the server) 72 299.67 T
(\325) 162.42 299.67 T
(s disk altogether) 165.47 299.67 T
(.) 236.88 299.67 T
0 12 Q
(5.1.1.2. Backup Machine Storage) 72 268 T
1 11 Q
0.16 (Another alternative to the recovery box is to keep a complete backup copy in the main memory) 82.8 242.67 P
-0.16 (of a machine other than the server) 72 229.67 P
-0.16 (. After a crash, the \336le server retrieves the state information from) 219.91 229.67 P
-0.21 (this backup machine. This technique requires only a few RPCs, and only with the backup machine.) 72 216.67 P
1.04 (This is dif) 72 203.67 P
1.04 (ferent from client-driven and server) 118.45 203.67 P
1.04 (-driven recovery) 279.22 203.67 P
1.04 (, because those techniques spread) 352.46 203.67 P
(dif) 72 190.67 T
(ferent parts of the state information across many machines.) 84.01 190.67 T
-0.14 (If we store the backup state information on another machine, we must be able to update it when-) 82.8 165.67 P
0.25 (ever the server) 72 152.67 P
0.25 (\325) 137.58 152.67 P
0.25 (s state changes. The choices for accomplishing this are similar to those for storing) 140.63 152.67 P
0.47 (the state on disk, but the performance costs are dif) 72 139.67 P
0.47 (ferent. One way to do this is to require the \336le) 296.96 139.67 P
1.4 (server to update the backup\325) 72 126.67 P
1.4 (s state information every time a client makes an RPC request that) 201.47 126.67 P
-0.16 (changes the distributed state. The server issues an RPC to the backup and waits to receive its reply) 72 113.67 P
-0.16 (,) 501.25 113.67 P
1.46 (before responding to the client. This technique is similar to that used by HARP [Liskov91] to) 72 100.67 P
(make its \336le system updates on backup servers.) 72 87.67 T
FMENDPAGE
%%EndPage: "77" 89
%%Page: "78" 89
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(78) 318 55 T
1 11 Q
0.34 (There are several advantages of this technique. Updating the information across the network to) 118.8 712.67 P
0.08 (the backup machine\325) 108 699.67 P
0.08 (s main memory is faster than updating it to the server) 199.09 699.67 P
0.08 (\325) 434.67 699.67 P
0.08 (s disk but still provides) 437.73 699.67 P
0.65 (the same permanence in the case of a server failure. Each client request that causes an update of) 108 686.67 P
0.26 (the cache state information suf) 108 673.67 P
0.26 (fers less than a millisecond\325) 243.7 673.67 P
0.26 (s extra latency) 366.81 673.67 P
0.26 (, compared to the tens of) 430.07 673.67 P
0.13 (milliseconds required by a disk write. Also, accessing the saved state information for crash recov-) 108 660.67 P
0.07 (ery requires the server to communicate with only one machine, rather than with a whole set of cli-) 108 647.67 P
0.34 (ents as during client-driven or server) 108 634.67 P
0.34 (-driven recovery) 270.86 634.67 P
0.34 (. Additionally) 343.39 634.67 P
0.34 (, storing the information in the) 404.05 634.67 P
0.34 (memory of a machine other than the server avoids the complexity of the checksums or write-pro-) 108 621.67 P
(tection used by the recovery box.) 108 608.67 T
-0.09 ( The disadvantage of this technique is that it still incurs a substantial performance overhead dur-) 118.8 583.67 P
-0.14 (ing normal operation of the system. Except for storing the state on disk, it is slower than the recov-) 108 570.67 P
1.17 (ery techniques previously described. This is because the updates to the backup machine\325) 108 557.67 P
1.17 (s main) 509.84 557.67 P
0.6 (memory require an extra round-trip RPC for each relevant client RPC. Using DECstation 5000\325) 108 544.67 P
0.6 (s) 535.73 544.67 P
0.83 (or SP) 108 531.67 P
0.83 (ARCstation-2\325) 131.93 531.67 P
0.83 (s in Sprite, this round-trip RPC adds about a millisecond of latency to every) 196.02 531.67 P
-0.06 (\336le open or close. This is 25% of the cost of a remote \336le open and close combined. A system run-) 108 518.67 P
0.79 (ning client-driven or server) 108 505.67 P
0.79 (-driven recovery does not suf) 230.04 505.67 P
0.79 (fer this performance degradation during) 361.73 505.67 P
0.85 (normal operation, and a server running transparent recovery only needs to update its own main-) 108 492.67 P
(memory) 108 479.67 T
(.) 143.9 479.67 T
0.2 (A second way to maintain the backup machine\325) 118.8 454.67 P
0.2 (s state information is for the backup to listen on) 328.58 454.67 P
-0.22 (the network for client RPC requests of the \336le server) 108 441.67 P
-0.22 (. Whenever a client makes a request that could) 337.02 441.67 P
0.16 (change the cache state information on the server) 108 428.67 P
0.16 (, the backup machine updates its copy of the state) 320.71 428.67 P
0.82 (information to re\337ect that change. The advantage of this technique is that the \336le server and the) 108 415.67 P
1.31 (backup machine need not communicate during normal operation, so RPCs from clients are not) 108 402.67 P
1.41 (delayed. The big disadvantage is that the backup machine\325) 108 389.67 P
1.41 (s copy of the state information may) 375.9 389.67 P
0.19 (become inconsistent with the server) 108 376.67 P
0.19 (\325) 266.61 376.67 P
0.19 (s. The server has no way to know if the backup has noted the) 269.66 376.67 P
-0 (RPC request and successfully applied the state change before the server responds to the client. For) 108 363.67 P
1.15 (example, the backup machine could fail to notice an RPC if its network interface is congested.) 108 350.67 P
-0.04 (Since the backup machine is not the primary destination of the RPC, the client will know only that) 108 337.67 P
-0.16 (the primary server successfully received the request, and it will not resend the message. If the RPC) 108 324.67 P
(contains a \336le open request, the backup will fail to record that the client is caching the \336le.) 108 311.67 T
1.94 (Another disadvantage with both these techniques for storing state information on a backup) 118.8 286.67 P
1.69 (machine is the extra complexity for handling backup machine crashes. If the backup machine) 108 273.67 P
0.63 (crashes, the server must send its state to another backup. If the server itself crashes before it \336n-) 108 260.67 P
0.08 (ishes sending this information to the new backup, the system cannot recover without using server) 108 247.67 P
0.08 (-) 536.34 247.67 P
-0.07 (driven or client-driven recovery) 108 234.67 P
-0.07 (. Storing the state information on multiple backup machines would) 247.1 234.67 P
(reduce this vulnerability) 108 221.67 T
(, but would also further degrade overall performance.) 214.08 221.67 T
0 12 Q
(5.1.2. Err) 108 190 T
(or Statistics) 156.42 190 T
1 11 Q
-0.19 (The most important issue for storing the recovery box in main memory is whether it will survive) 118.8 164.67 P
0.51 (most server crashes intact. Statistics on the frequencies of dif) 108 151.67 P
0.51 (ferent types of system outages indi-) 380.91 151.67 P
-0.21 (cate that this should be true for three reasons. These statistics were collected by Jim Gray [Gray90]) 108 138.67 P
0.27 (and Mark Sullivan [Sulli93a] in T) 108 125.67 P
0.27 (andem, MVS, and UNIX systems. First, the majority of failures) 257.79 125.67 P
-0.03 (are due to software failures rather than permanent hardware problems that require long downtimes) 108 112.67 P
0.61 (to \336x. Second, the majority of software errors do not corrupt memory) 108 99.67 P
0.61 (. Third, of those errors that) 418.85 99.67 P
0.6 (corrupt memory) 108 86.67 P
0.6 (, most do not af) 178.97 86.67 P
0.6 (fect random memory locations. Rather) 249.82 86.67 P
0.6 (, the error corrupts an area) 421.11 86.67 P
FMENDPAGE
%%EndPage: "78" 90
%%Page: "79" 90
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(79) 282 55 T
1 11 Q
0.1 (local to the data structure it intended to modify) 72 712.67 P
0.1 (. This means that careful address and size checking) 278.35 712.67 P
0.95 (for updates to items in the recovery box will catch most of the corruption errors before they do) 72 699.67 P
2.08 (damage. T) 72 686.67 P
2.08 (ogether) 119.69 686.67 P
2.08 (, these statistics suggest that most failures will leave the recovery box data) 152.2 686.67 P
(undamaged, as detailed below) 72 673.67 T
(.) 203.7 673.67 T
-0.25 (Published data about the frequency of dif) 82.8 648.67 P
-0.25 (ferent kinds of outages is scarce, but a study of T) 262.31 648.67 P
-0.25 (andem) 474.71 648.67 P
0.05 (systems shows that faulty software is now responsible for most failures [Gray90]. Over time, T) 72 635.67 P
0.05 (an-) 489.97 635.67 P
0.99 (dem systems have experienced fewer outages caused by hardware failures. The number of soft-) 72 622.67 P
0.46 (ware failures, on the other hand, has remained constant. T) 72 609.67 P
0.46 (able 5-1 shows the percentages of each) 329.8 609.67 P
0.99 (source of outage. In 1989, software errors accounted for 62% of T) 72 596.67 P
0.99 (andem system failures, while) 372.87 596.67 P
0.39 (only 7% were caused by hardware. In other environments as well, software errors and other tran-) 72 583.67 P
(sient errors account for the majority of failures [Lin90].) 72 570.67 T
0.5 (The direction of change in these failure statistics is part of the motivation for the fast recovery) 82.8 225.65 P
0.75 (approach. W) 72 212.65 P
0.75 (ithout redundant hardware, the recovery box and other fast recovery approaches are) 128.44 212.65 P
-0.2 (not able to recover from hardware failures, but hardware is becoming more reliable and software is) 72 199.65 P
0.29 (now the greatest source of unreliability) 72 186.65 P
0.29 (. This means that we should be able to handle the majority) 244.51 186.65 P
1.09 (of failures by concentrating on software failures and other failures that do not cause permanent) 72 173.65 P
(hardware damage.) 72 160.65 T
0.82 (Even if most system outages are due to software rather than permanent hardware failures, the) 82.8 135.65 P
-0 (question remains as to whether the software failures will damage the contents of the recovery box.) 72 122.65 P
0.57 (T) 72 109.65 P
0.57 (wo studies that categorize the types of operating system software errors indicate that most soft-) 77.94 109.65 P
72 81 504 720 C
72 246.98 504 567 C
70.99 254 503.99 562 R
7 X
0 K
V
1 11 Q
0 X
(T) 201.06 379.67 T
(able 5-1. Distribution of outage types.) 207.01 379.67 T
1 10 Q
0.93 (This table shows the distribution of types of outages by fatal fault occurring in T) 106.99 355.33 P
0.93 (andem) 441.35 355.33 P
0.55 (systems between 1985-1990 [Gray90]. Software failures are caused by errors in the soft-) 106.99 344.33 P
2.34 (ware. Operator errors are mistakes made by humans responsible for maintaining the) 106.99 333.33 P
-0.11 (machines. Hardware failures are caused by problems with the hardware. Environment fail-) 106.99 322.33 P
0.59 (ures are caused by \337oods, \336res, and long power outages. The table also includes outages) 106.99 311.33 P
0.09 (due to scheduled maintenance and unknown causes. The overall failure rate has decreased) 106.99 300.33 P
0.69 (since 1985 but has held steady since about 1987. The total percentages do not all add to) 106.99 289.33 P
72 257 503.99 275 C
70.99 257 503.99 275 R
7 X
0 K
V
70.99 266 502.99 266 2 L
V
0.5 H
2 Z
0 X
N
72 246.98 504 567 C
1 10 Q
0 X
0 K
(100, due to rounding.) 106.99 278.33 T
(Outage sources) 136.82 522.33 T
(Percent in 1985) 256.12 522.33 T
(Percent in 1989) 376.12 522.33 T
(Software failures) 111.49 504.33 T
(34) 333.5 504.33 T
(62) 453.5 504.33 T
(Operator errors) 111.49 486.33 T
(9) 338.49 486.33 T
(15) 453.5 486.33 T
(Hardware failures) 111.49 468.33 T
(29) 333.5 468.33 T
(7) 458.49 468.33 T
(Environment failures) 111.49 450.33 T
(6) 338.49 450.33 T
(6) 458.49 450.33 T
(Scheduled maintenance) 111.49 432.33 T
(19) 333.5 432.33 T
(5) 458.49 432.33 T
(Unknown) 111.49 414.33 T
(4) 338.49 414.33 T
(5) 458.49 414.33 T
107.49 532 107.49 408 2 L
V
2 H
0 Z
N
227.49 534 227.49 406 2 L
V
N
347.49 534 347.49 406 2 L
V
0.5 H
N
467.49 532 467.49 408 2 L
V
2 H
N
106.49 533 468.49 533 2 L
V
N
108.49 516.25 466.49 516.25 2 L
V
0.5 H
N
108.49 513.75 466.49 513.75 2 L
V
N
106.49 497 468.49 497 2 L
V
N
106.49 479 468.49 479 2 L
V
N
106.49 461 468.49 461 2 L
V
N
106.49 443 468.49 443 2 L
V
N
106.49 425 468.49 425 2 L
V
N
106.49 407 468.49 407 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "79" 91
%%Page: "80" 91
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(80) 318 55 T
1 11 Q
0.22 (ware errors will not corrupt the recovery box. These two studies are summarized in T) 108 712.67 P
0.22 (able 5-2 and) 485.26 712.67 P
(are described below) 108 699.67 T
(.) 195.14 699.67 T
0.02 (The BSD UNIX study [Sulliv90] divides errors into) 118.8 674.67 P
2 F
0.02 (synchr) 349.66 674.67 P
0.02 (onization) 378.54 674.67 P
1 F
0.02 ( \05047%\051,) 419.44 674.67 P
2 F
0.02 (exception-handling) 455.17 674.67 P
1 F
0.86 (\05012%\051,) 108 661.67 P
2 F
0.86 (addr) 141.81 661.67 P
0.86 (essing) 162.16 661.67 P
1 F
0.86 ( \05012%\051, and) 189.62 661.67 P
2 F
0.86 (miscellaneous) 246.51 661.67 P
1 F
0.86 ( \05029%\051 errors. Synchronization errors include prob-) 308.76 661.67 P
1.68 (lems such as deadlock or waiting endlessly for a signal from some event. Exception-handling) 108 648.67 P
0.74 (errors are those that occur in code for handling other errors, including transient hardware errors.) 108 635.67 P
-0.16 (Addressing errors are those for which the software uses an incorrect memory address. They are the) 108 622.67 P
0.31 (errors most likely to corrupt memory) 108 609.67 P
0.31 (, since the software may modify bytes at the wrong location.) 271.46 609.67 P
(For UNIX, addressing errors account for only 12% of errors.) 108 596.67 T
0.24 (The MVS study [Sulliv91] classi\336es errors in terms of low-level programming errors, of which) 118.8 571.67 P
-0.02 (41% were) 108 558.67 P
2 F
-0.02 (contr) 154.94 558.67 P
-0.02 (ol) 177.73 558.67 P
1 F
-0.02 ( problems, 30% were addressing errors, 8% were) 186.27 558.67 P
2 F
-0.02 (data miscalculations) 404.56 558.67 P
1 F
-0.02 (, and 21%) 495.8 558.67 P
1.01 (were miscellaneous errors. Control errors include such problems as deadlock, in which the pro-) 108 545.67 P
0.48 (gram stops without corrupting anything but transient state. Data miscalculations include errors in) 108 532.67 P
0.36 (which the wrong variable is used or a function returns the wrong value. Most of the errors classi-) 108 519.67 P
0.12 (\336ed as miscellaneous are related to performance or denial of service. In MVS as well as in UNIX,) 108 506.67 P
(addressing problems are not responsible for the majority of failures.) 108 493.67 T
-0.16 (In addition, the MVS study shows that most memory corruption due to addressing errors is local) 118.8 150.67 P
0.43 (to the data structure being manipulated. As shown in T) 108 137.67 P
0.43 (able 5-3, at least 57% of addressing errors) 352.13 137.67 P
0.91 (either corrupt the data structure the operating system intends to modify or the memory immedi-) 108 124.67 P
0.81 (ately following the data structure. Only 19% of the MVS addressing errors covered in the study) 108 111.67 P
0.61 (damaged parts of the system unrelated to the one where the error occurred. For example, a com-) 108 98.67 P
0.77 (mon type of addressing error in MVS is) 108 85.67 P
2 F
0.77 (copy overrun) 291.74 85.67 P
1 F
0.77 ( in which a copy transfers too many bytes) 350.78 85.67 P
108 81 540 720 C
108 172 540 490 C
110 180 539 485 R
7 X
0 K
V
1 11 Q
0 X
(T) 228 284.67 T
(able 5-2. Software error type distributions.) 233.95 284.67 T
1 10 Q
0.15 (This table shows the distribution of software errors analyzed by Mark Sullivan in studies) 146 260.33 P
0.06 (of error reports from the IBM MVS and 4.1/4.2 BSD UNIX operating systems [Sulli93a]) 146 249.33 P
-0.09 ([Baker92a]. The results columns give the percentage of errors that fall into each category) 146 238.33 P
-0.09 (.) 500.5 238.33 P
-0.11 (The two studies used dif) 146 227.33 P
-0.11 (ferent classi\336cation schemes, but both list addressing errors) 243.1 227.33 P
3 F
-0.11 (-) 482.9 227.33 P
1 F
-0.11 ( the) 488.39 227.33 P
0.27 (errors most likely to corrupt recovery box memory) 146 216.33 P
0.27 (. The other error classes are described) 350.14 216.33 P
110 184 539 202 C
110 184 539 202 R
7 X
0 K
V
110 193 542 193 2 L
V
0.5 H
2 Z
0 X
N
108 172 540 490 C
1 10 Q
0 X
0 K
(in the text.) 146 205.33 T
2 F
(NA) 190.97 205.33 T
1 F
( means not applicable due to dif) 203.74 205.33 T
(ferences in the classi\336cation schemes.) 331.25 205.33 T
(Error classes) 178.82 445.33 T
(BSD UNIX) 307.04 445.33 T
(MVS) 439.67 445.33 T
(Addressing-related errors) 142.5 427.33 T
(12) 376.5 427.33 T
(30) 496.5 427.33 T
(Control-related errors) 142.5 409.33 T
(NA) 372.06 409.33 T
(41) 496.5 409.33 T
(Data miscalculation errors) 142.5 391.33 T
(NA) 372.06 391.33 T
(8) 501.5 391.33 T
(Synchronization-related errors) 142.5 373.33 T
(47) 376.5 373.33 T
(NA) 492.06 373.33 T
(Exception-related errors) 142.5 355.33 T
(12) 376.5 355.33 T
(NA) 492.06 355.33 T
(Miscellaneous errors) 142.5 337.33 T
(29) 376.5 337.33 T
(21) 496.5 337.33 T
(T) 142.5 319.33 T
(otal) 147.9 319.33 T
(100) 371.5 319.33 T
(100) 491.5 319.33 T
138.5 455 138.5 313 2 L
V
2 H
0 Z
N
270.49 457 270.49 311 2 L
V
N
390.5 457 390.5 311 2 L
V
0.5 H
N
510.5 455 510.5 313 2 L
V
2 H
N
137.5 456 511.5 456 2 L
V
N
139.5 439.25 509.5 439.25 2 L
V
0.5 H
N
139.5 436.75 509.5 436.75 2 L
V
N
137.5 420 511.5 420 2 L
V
N
137.5 402 511.5 402 2 L
V
N
137.5 384 511.5 384 2 L
V
N
137.5 366 511.5 366 2 L
V
N
137.5 348 511.5 348 2 L
V
N
139.5 331.25 509.5 331.25 2 L
V
N
139.5 328.75 509.5 328.75 2 L
V
N
137.5 312 511.5 312 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "80" 92
%%Page: "81" 92
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(81) 282 55 T
1 11 Q
-0.26 (from one buf) 72 712.67 P
-0.26 (fer into another) 128.63 712.67 P
-0.26 (, overwriting the data structure that follows the intended destination. A) 195.4 712.67 P
0 (second common addressing error) 72 699.67 P
0 (, called an) 217.1 699.67 P
2 F
0 (allocation management err) 264.7 699.67 P
0 (or) 383.92 699.67 P
1 F
0 (, occurs when the operat-) 393.25 699.67 P
0.12 (ing system continues to use a structure after deallocating it. Careful size and bounds checking and) 72 686.67 P
-0 (careful memory allocation will reduce the likelihood of corruption from these local address errors.) 72 426.67 P
-0.25 (These statistics indicate that random addressing errors are rare, which is fortunate, since they are) 82.8 401.67 P
-0 (the type of addressing error most likely to corrupt the recovery box. Random addressing errors are) 72 388.67 P
-0.19 (the most dangerous, because they are the hardest to guard against. Any errant code in the operating) 72 375.67 P
0.03 (system kernel could mistakenly write to the recovery box area of memory) 72 362.67 P
0.03 (. Because these statistics) 395.9 362.67 P
0.41 (were gathered across dif) 72 349.67 P
0.41 (ferent systems, we cannot combine them with accuracy) 180.09 349.67 P
0.41 (, but we can get a) 425.09 349.67 P
1.47 (rough idea of the likely distribution of errors. If about two thirds of errors are software errors) 72 336.67 P
-0.16 (\050T) 72 323.67 P
-0.16 (able 5-1\051, and about 12 to 30% of these are addressing errors \050T) 81.6 323.67 P
-0.16 (able 5-2\051, and 19 to 43% of these) 359.28 323.67 P
-0.16 (are random addressing errors \050T) 72 310.67 P
-0.16 (able 5-3\051, then only one to seven percent of overall failures are due) 211.53 310.67 P
-0.17 (to an addressing error that corrupts random memory) 72 297.67 P
-0.17 (. Figure 5-1 is a pie chart showing this calcula-) 299.25 297.67 P
0.58 (tion of random addressing errors. Using measurements from Internet sites [Long91] that indicate) 72 284.67 P
0.22 (that UNIX machines fail on average once every two weeks, we can expect one to two failures per) 72 271.67 P
0.06 (year due to random addressing errors. Even then, the error does not necessarily mean the recovery) 72 258.67 P
(box will be damaged.) 72 245.67 T
0.21 (W) 82.8 220.67 P
0.21 (ith these statistics in mind, I designed an interface to the recovery box that reduces the possi-) 92.73 220.67 P
1.36 (bility of corruption from software failures. For example, corruption is less likely if we use the) 72 207.67 P
0.36 (recovery box to store backup copies of critical data structures, rather than the primary copies that) 72 194.67 P
1.42 (callers access directly) 72 181.67 P
1.42 (. The recovery box interface does not allow callers to access its memory) 169.92 181.67 P
0.41 (directly) 72 168.67 P
0.41 (. The interface does strict length checking when items are copied into the recovery box to) 104.85 168.67 P
0.71 (prevent copy overruns. The recovery box must also do very simple memory allocation and must) 72 155.67 P
(not allow the software calling it to allocate or free recovery box space directly) 72 142.67 T
(.) 414.52 142.67 T
1 (Unfortunately) 82.8 117.67 P
1 (, the failure statistics do not give us enough information to protect the recovery) 143.72 117.67 P
-0.17 (box against complex faults involving) 72 104.67 P
2 F
-0.17 (err) 236.88 104.67 P
-0.17 (or pr) 249.9 104.67 P
-0.17 (opagation) 271.61 104.67 P
1 F
-0.17 (. If the system fails due to a logical error in) 316.17 104.67 P
0.25 (one of its data structures, and if this data is stored in the recovery box, then the system will suf) 72 91.67 P
0.25 (fer) 491.8 91.67 P
72 81 504 720 C
72 443.03 504 683 C
73 450 504 678 R
7 X
0 K
V
1 11 Q
0 X
(T) 184.85 531.67 T
(able 5-3. Data corrupted by addressing errors.) 190.79 531.67 T
1 10 Q
0.14 (This table shows the relationship between the location of data corrupted by an addressing) 109 507.33 P
2 (error in MVS and the location of the intended modi\336cation. Usually data corruption) 109 496.33 P
0.23 (occurs near the data owned by the faulty code. In 24% of MVS error reports studied, this) 109 485.33 P
73 453 504 471 C
73 453 504 471 R
7 X
0 K
V
73 462 505 462 2 L
V
0.5 H
2 Z
0 X
N
72 443.03 504 683 C
1 10 Q
0 X
0 K
(location information was not evident.) 109 474.33 T
(Location of damaged area) 176.46 638.33 T
(Percent of MVS errors) 303.12 638.33 T
(Near intended area) 172.5 620.33 T
(57) 394.51 620.33 T
(Anywhere in storage) 172.5 602.33 T
(19) 394.51 602.33 T
(Not evident from report) 172.5 584.33 T
(24) 394.51 584.33 T
(T) 172.5 566.33 T
(otal) 177.91 566.33 T
(100) 389.51 566.33 T
168.5 648 168.5 560 2 L
V
2 H
0 Z
N
288.5 650 288.5 558 2 L
V
N
408.5 648 408.5 560 2 L
V
N
167.5 649 409.5 649 2 L
V
N
169.5 632.25 407.5 632.25 2 L
V
0.5 H
N
169.5 629.75 407.5 629.75 2 L
V
N
167.5 613 409.5 613 2 L
V
N
167.5 595 409.5 595 2 L
V
N
169.5 578.25 407.5 578.25 2 L
V
N
169.5 575.75 407.5 575.75 2 L
V
N
167.5 559 409.5 559 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "81" 93
%%Page: "82" 93
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(82) 318 55 T
1 11 Q
0.76 (the same failure after recovery) 108 348.69 P
0.76 (. The only way we can protect the system from this problem is to) 244.54 348.69 P
0.47 (choose data structures for insertion in the recovery box that have proven themselves over time to) 108 335.69 P
1.45 (be relatively error) 108 322.69 P
1.45 (-free. In commercial systems using a recovery box, data gathered from error) 189.38 322.69 P
(reports would help indicate which data structures are likely to propagate errors.) 108 309.69 T
0 12 Q
(5.1.3. W) 108 278.03 T
(rite Pr) 149.76 278.03 T
(otection) 183.18 278.03 T
1 11 Q
0.27 (Another way to protect the recovery box from memory corruption is to write-protect its area of) 118.8 252.69 P
-0.11 (memory) 108 239.69 P
-0.11 (. W) 143.9 239.69 P
-0.11 (e can set the protection bits in the hardware pages containing the recovery box to disal-) 158.78 239.69 P
1.81 (low any writes to those pages. Only the recovery box code, in one place, should execute the) 108 226.69 P
1.83 (instructions necessary to make the pages writable, make the update, and re-protect the pages.) 108 213.69 P
-0.06 (There is no guarantee that the recovery box code itself, between making the pages writable and re-) 108 200.69 P
0.04 (protecting them again, will not suf) 108 187.69 P
0.04 (fer an addressing error and corrupt the memory) 259.34 187.69 P
0.04 (. But the amount) 466.64 187.69 P
0.1 (of code executed between making the pages writable and re-protecting them is very small and can) 108 174.69 P
0.64 (be checked with high con\336dence. W) 108 161.69 P
0.64 (rite protection means that other parts of the kernel code will) 270.62 161.69 P
(not be able to write to the recovery box accidentally without suf) 108 148.69 T
(fering a write-protection fault.) 388.82 148.69 T
1 (W) 118.8 123.69 P
1 (rite-protecting the recovery box adds some performance overhead to recovery box updates,) 128.73 123.69 P
-0.03 (because changing the hardware page protection on some architectures requires \337ushing translation) 108 110.69 P
0.9 (look-aside buf) 108 97.69 P
0.9 (fers or virtually addressed caches. However) 171.86 97.69 P
0.9 (, the overhead seen on the SP) 368.1 97.69 P
0.9 (ARCsta-) 501.55 97.69 P
(tion-2 is low and is described in this chapter in section 5.4.2 on \336le system overhead.) 108 84.69 T
(Figure 5-1. Percentage of random addressing errors.) 209.59 473.69 T
1 10 Q
-0.1 (This pie chart gives a very rough estimate of the percentage of errors that are likely to cor-) 144 451.36 P
0.46 (rupt random memory) 144 440.36 P
0.46 (. About two-thirds of errors are software errors, about 12 to 30% of) 229.22 440.36 P
0.77 (these are addressing errors, and about 19 to 43% of these are random addressing errors.) 144 429.36 P
0.04 (Random addressing errors are the ones likely to corrupt the recovery box. This estimate is) 144 418.36 P
108 386.02 540 404.02 C
108 386.02 540 404.02 R
7 X
0 K
V
108 395.02 540 395.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(very rough, because it combines data from several dif) 144 407.36 T
(ferent studies of system failures.) 358.37 407.36 T
108 499.02 540 720 C
108 499.02 540 708 C
7 X
0 K
90 450 83.5 83 370.5 595 G
2 H
0 Z
0 X
90 450 83.5 83 370.5 595 A
370 676 370 596 2 L
7 X
V
3 H
2 Z
0 X
N
370 596 443 554 2 L
7 X
V
0 X
N
370 596 405 670 2 L
7 X
V
0 X
N
371 597 287 597 2 L
7 X
V
1 H
10 X
N
371 597 292 622 2 L
7 X
V
10 X
N
273 596 194 621 2 L
7 X
V
0 X
N
272 596 188 596 2 L
7 X
V
0 X
N
90 180 8 24.67 195 596 A
189 610 271 596 2 L
N
1 12 Q
(software 62%) 313 565 T
(other 30%) 387 599 T
(hardware 8%) 293 690 T
(random addressing errors 3%) 133 643 T
(local addressing errors 4%) 128 563 T
383.02 670.93 387.99 660 377.99 666.64 380.51 668.78 4 Y
V
360 693 380.52 668.78 2 L
N
178.92 626.51 189 620 177 620.18 177.96 623.35 4 Y
V
136 636 177.96 623.35 2 L
N
174.33 601.18 186 604 177.6 595.43 175.97 598.31 4 Y
V
138 577 175.97 598.3 2 L
N
108 499.02 540 720 C
108 499.02 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "82" 94
%%Page: "83" 94
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(83) 282 55 T
0 14 Q
(5.2. Design and Implementation) 72 710.67 T
1 11 Q
0.26 (The goal of the recovery box is to provide fast insert, delete and retrieval operations while pro-) 82.8 684.67 P
1.85 (tecting the stored data against common addressing and memory management errors. Both the) 72 671.67 P
0.08 (operating system kernel and user) 72 658.67 P
0.08 (-level applications can use the recovery box, but user) 216.72 658.67 P
0.08 (-level appli-) 450.53 658.67 P
0.7 (cations must execute their operations through a system call interface. This section \336rst describes) 72 645.67 P
(the interface to the recovery box and then its internal structure.) 72 632.67 T
0 12 Q
(5.2.1. Interface) 72 601 T
1 11 Q
-0.01 (The recovery box interface should help Sprite and its application programs manage backup data) 82.8 575.67 P
0.29 (without exposure to some of the common software errors that corrupt main memory) 72 562.67 P
0.29 (. For this rea-) 443.94 562.67 P
-0.06 (son I chose a structured and relatively in\337exible interface, rather than a more \337exible one in which) 72 549.67 P
-0.19 (clients directly allocate and manage data structures in the reserved area of memory) 72 536.67 P
-0.19 (. This structured) 432.67 536.67 P
(interface provides more opportunity to avoid and detect recovery box corruption.) 72 523.67 T
0.24 (In this interface, each item belongs to a type, and users of the recovery box must pre-de\336ne the) 82.8 498.67 P
0.47 (types of items they use. When a new type is de\336ned, the recovery box assigns it a unique) 72 485.67 P
2 F
0.47 (typeID) 474.11 485.67 P
1 F
-0.04 (and returns this ID to the caller so that the caller can refer to the type in the future. All items of the) 72 472.67 P
0.1 (same type have common characteristics, such as size and checksum calculation routine. Maintain-) 72 459.67 P
-0.17 (ing item size in the recovery box makes it easy for the interface to detect common errors that cause) 72 446.67 P
(memory corruption, such as writing past the end of a data structure.) 72 433.67 T
0.41 ( Callers of the recovery box must explicitly insert, delete, and update recovery box items. This) 82.8 408.67 P
0.22 (makes it easy for the recovery box to detect memory management errors. For example, the recov-) 72 395.67 P
1.54 (ery box does not need any sort of complex garbage collection, because callers must explicitly) 72 382.67 P
0.69 (delete items when done with them. When a client creates a new item, the recovery box manager) 72 369.67 P
-0.09 (generates a unique) 72 356.67 P
2 F
-0.09 (itemID) 156.23 356.67 P
1 F
-0.09 ( and returns this to the caller so that the caller can refer to the item in the) 186.74 356.67 P
(future. An itemID consists of the item\325) 72 343.67 T
(s typeID and an) 241.97 343.67 T
2 F
(itemNumber) 313.97 343.67 T
1 F
(.) 367.69 343.67 T
1.49 (The Sprite kernel and its user) 82.8 318.67 P
1.49 (-level applications use the same interface to the recovery box,) 219.08 318.67 P
0.38 (except that applications call the recovery box routines via a system call. The major dif) 72 305.67 P
0.38 (ference for) 455.74 305.67 P
-0.09 (user) 72 292.67 P
-0.09 (-level applications calling recovery box functions is that they have no control over the order in) 90.08 292.67 P
0.05 (which other types and items are inserted in the recovery box. For this reason, they have no control) 72 279.67 P
0.65 (over the typeIDs and itemNumbers assigned to their items. When an application program begins) 72 266.67 P
0.27 (fast recovery) 72 253.67 P
0.27 (, it must be able to \336nd its recovery box items to regenerate its state from them. This) 128.6 253.67 P
1.09 (means the application must be able to remember) 72 240.67 P
1.09 (, across reboots, the typeIDs and itemNumbers) 291.83 240.67 P
0.33 (assigned to its items by the recovery box. T) 72 227.67 P
0.33 (o solve this problem without requiring the application) 265.19 227.67 P
0.09 (to store a list of these IDs on disk, the recovery box allows the application to choose its own well-) 72 214.67 P
0.1 (known typeIDs and itemNumbers and to map from them to the system-assigned IDs. The applica-) 72 201.67 P
1.89 (tion can specify its) 72 188.67 P
2 F
1.89 (applicationT) 165.01 188.67 P
1.89 (ypeID) 220.35 188.67 P
1 F
1.89 ( or) 247.19 188.67 P
2 F
1.89 (applicationItemNumber) 265.62 188.67 P
1 F
1.89 ( when it initializes a type or) 370.6 188.67 P
0.61 (inserts a new item. On recovery) 72 175.67 P
0.61 (, the application maps from its application IDs to the system IDs) 214.08 175.67 P
0.15 (once, at initialization, and not every time it accesses recovery box items. Allowing applications to) 72 162.67 P
1.01 (specify their own IDs also facilitates sharing of recovery box items between cooperating UNIX) 72 149.67 P
0.73 (processes. The recovery box functions return an error to the application if it chooses an applica-) 72 136.67 P
(tionT) 72 123.67 T
(ypeID or applicationItemNumber already chosen by another caller) 95.04 123.67 T
(.) 386.41 123.67 T
-0.2 ( T) 82.8 98.67 P
-0.2 (able 5-4 lists the available recovery box functions. The \336rst two functions operate on types. T) 91.29 98.67 P
-0.2 (o) 498.51 98.67 P
0.85 (initialize a new type of item, the system or application must call) 72 85.67 P
2 F
0.85 (InitT) 366.25 85.67 P
0.85 (ype) 386.81 85.67 P
1 F
0.85 (. As parameters to this) 402.06 85.67 P
FMENDPAGE
%%EndPage: "83" 95
%%Page: "84" 95
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(84) 318 55 T
1 11 Q
0.57 (function, the caller speci\336es the maximum number of items that can be valid simultaneously) 108 187.66 P
0.57 (, the) 520.51 187.66 P
-0.08 (item size, an optional applicationT) 108 174.66 P
-0.08 (ypeID, and a \337ag that signals whether checksums should be cal-) 259.18 174.66 P
1.45 (culated and stored for items of this type. When called by kernel code, the checksum \337ag may) 108 161.66 P
0.98 (instead be a pointer to a specialized checksum routine for the type. Otherwise the recovery box) 108 148.66 P
0.05 (uses a generic checksum. Stating the maximum number of items ahead of time is a potential prob-) 108 135.66 P
-0.02 (lem for applications that do not know how many items they will need. However) 108 122.66 P
-0.02 (, it makes memory) 458.27 122.66 P
0.06 (management much easier) 108 109.66 P
0.06 (.) 219.19 109.66 P
2 F
0.06 (DeleteT) 224.74 109.66 P
0.06 (ype) 258.71 109.66 P
1 F
0.06 ( frees up an item type, but I do not expect this function to be) 273.96 109.66 P
(called often, except perhaps when a new application is being tested.) 108 96.66 T
108 81 540 720 C
109.48 194.99 538.52 720 C
107.98 204 537.98 716 R
7 X
0 K
V
1 11 Q
0 X
(T) 243.12 305.67 T
(able 5-4. Recovery box operations.) 249.07 305.67 T
1 10 Q
-0.1 (This table lists the operations available through the recovery box interface. The \336rst set of) 143.98 281.33 P
0.03 (functions applies to item types; the second set applies to individual items, and the third to) 143.98 270.33 P
0.05 (multiple items. The last set of functions map from an application\325) 143.98 259.33 P
0.05 (s chosen typeID or item) 406.29 259.33 P
0.21 (numbers to those used by the recovery box. Results in italics are actually parameters that) 143.98 248.33 P
0.59 (the caller supplies to the function into which the recovery box copies the results. In this) 143.98 237.33 P
109.48 205 537.98 223 C
107.98 205 537.98 223 R
7 X
0 K
V
107.98 214 539.98 214 2 L
V
0.5 H
2 Z
0 X
N
109.48 194.99 538.52 720 C
1 10 Q
0 X
0 K
(way) 143.98 226.33 T
(, the recovery box avoids returning any internally-used addresses to its caller) 159.99 226.33 T
(.) 466.43 226.33 T
(Category) 139.16 676.33 T
(Name) 224.55 676.33 T
(Parameters) 332.78 676.33 T
(Results) 460.27 676.33 T
(Operations on) 127.98 658.33 T
(types) 127.98 646.33 T
(InitT) 194.98 658.33 T
(ype) 214.27 658.33 T
(itemSize, maxNumber) 285.98 658.33 T
(, applica-) 375.52 658.33 T
-0.19 (tionT) 285.98 646.33 P
-0.19 (ypeID \050optional\051, Checksum-) 306.94 646.33 P
(FunctionOrFlag) 285.98 634.33 T
(typeID) 431.98 658.33 T
(DeleteT) 194.98 616.33 T
(ype) 226.48 616.33 T
(typeID) 285.98 616.33 T
(none) 431.98 616.33 T
(Operations on) 127.98 598.33 T
(single items) 127.98 586.33 T
(InsertItem) 194.98 598.33 T
(typeID, itemPtr) 285.98 598.33 T
(, applicationItem-) 347.77 598.33 T
(Number \050optional\051) 285.98 586.33 T
(itemID) 431.98 598.33 T
(DeleteItem) 194.98 568.33 T
(itemID) 285.98 568.33 T
(none) 431.98 568.33 T
(UpdateItem) 194.98 550.33 T
(itemPtr) 285.98 550.33 T
(, itemID) 315.02 550.33 T
(none) 431.98 550.33 T
(ReturnItem) 194.98 532.33 T
-0.03 (itemID, itemBuf) 285.98 532.33 P
-0.03 (ferSize, doCheck-) 351.85 532.33 P
(sum) 285.98 520.33 T
2 F
(itemPtr) 431.98 532.33 T
1 F
(Operations on) 127.98 502.33 T
(multiple items) 127.98 490.33 T
(InsertItemArray) 194.98 502.33 T
(typeID, numberOfItems, item-) 285.98 502.33 T
(Buf) 285.98 490.33 T
(fer) 300.8 490.33 T
(, applicationItemtNumber-) 311.49 490.33 T
(Buf) 285.98 478.33 T
(fer) 300.8 478.33 T
2 F
(itemIDBuffer) 431.98 502.33 T
1 F
(DeleteItemArray) 194.98 460.33 T
(numberOfItems, itemIDBuf) 285.98 460.33 T
(fer) 397.39 460.33 T
(none) 431.98 460.33 T
(UpdateItemArray) 194.98 442.33 T
(numberOfItems, itemBuf) 285.98 442.33 T
(fer) 386.85 442.33 T
(,) 397.54 442.33 T
(itemIDBuf) 285.98 430.33 T
(fer) 329.11 430.33 T
(none) 431.98 442.33 T
(ReturnItemArray) 194.98 412.33 T
(typeID, itemBuf) 285.98 412.33 T
(ferSize,) 351.32 412.33 T
(itemIDBuf) 285.98 400.33 T
(ferSize,applicationItem) 329.11 400.33 T
(NumberBuf) 285.98 388.33 T
(ferSize \050optional\051) 333.55 388.33 T
2 F
(itemBuffer) 431.98 412.33 T
(, itemID-) 473.07 412.33 T
(Buffer) 431.98 400.33 T
(, application-) 455.86 400.33 T
(ItemNumberBuffer) 431.98 388.33 T
(\050optional\051) 431.98 376.33 T
1 F
(ID mapping) 127.98 358.33 T
(GetT) 194.98 358.33 T
(ypeIDMapping) 214.82 358.33 T
(applicationT) 285.98 358.33 T
(ypeID) 335.81 358.33 T
(typeID) 431.98 358.33 T
(operations) 127.98 340.33 T
(GetItemIDMapping) 194.98 340.33 T
(typeID, applicationItemNumber) 285.98 340.33 T
(itemID) 431.98 340.33 T
123.98 686 123.98 334 2 L
V
2 H
0 Z
N
190.98 688 190.98 332 2 L
V
N
281.98 688 281.98 332 2 L
V
0.5 H
N
427.98 688 427.98 332 2 L
V
N
521.98 686 521.98 334 2 L
V
2 H
N
122.98 687 522.98 687 2 L
V
N
124.98 670.25 520.98 670.25 2 L
V
0.5 H
N
124.98 667.75 520.98 667.75 2 L
V
N
189.98 627 522.98 627 2 L
V
N
122.98 609 522.98 609 2 L
V
2 H
N
189.98 579 522.98 579 2 L
V
0.5 H
N
189.98 561 522.98 561 2 L
V
N
189.98 543 522.98 543 2 L
V
N
122.98 513 522.98 513 2 L
V
2 H
N
189.98 471 522.98 471 2 L
V
0.5 H
N
189.98 453 522.98 453 2 L
V
N
189.98 423 522.98 423 2 L
V
N
122.98 369 522.98 369 2 L
V
2 H
N
189.98 351 522.98 351 2 L
V
0.5 H
N
122.98 333 522.98 333 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "84" 96
%%Page: "85" 96
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(85) 282 55 T
1 11 Q
0.69 (Interface functions operating on individual recovery box items include) 82.8 712.67 P
2 F
0.69 (InsertItem) 401.72 712.67 P
1 F
0.69 (,) 446.88 712.67 P
2 F
0.69 (DeleteItem) 453.06 712.67 P
1 F
0.69 (,) 501.25 712.67 P
2 F
0.45 (UpdateItem) 72 699.67 P
1 F
0.45 (, and) 123.87 699.67 P
2 F
0.45 (ReturnItem) 148.88 699.67 P
1 F
0.45 (. T) 198.31 699.67 P
0.45 (o insert an item in the recovery box, the caller provides the item\325) 210.2 699.67 P
0.45 (s) 499.73 699.67 P
1.54 (typeID, a pointer to the data for the item, and an optional applicationItemNumber) 72 686.67 P
1.54 (. DeleteItem) 448.15 686.67 P
0.36 (frees the space in the recovery box allocated for an item. T) 72 673.67 P
0.36 (o update the contents of an item in the) 333.29 673.67 P
0.03 (recovery box, the caller must provide the itemID and a pointer to the new data for the item. Retur-) 72 660.67 P
(nItem returns a copy of the speci\336ed item in a buf) 72 647.67 T
(fer provided by the caller) 290.88 647.67 T
(.) 401.33 647.67 T
1.62 (Additional interface functions, such as) 82.8 622.67 P
2 F
1.62 (InsertItemArray) 262.99 622.67 P
1 F
1.62 ( and) 333.78 622.67 P
2 F
1.62 (ReturnItemArray) 358.38 622.67 P
1 F
1.62 (, allow applica-) 432.72 622.67 P
0.93 (tions to operate on multiple items, avoiding the system call overhead that would be incurred by) 72 609.67 P
2.26 (multiple operations on individual items. T) 72 596.67 P
2.26 (o insert multiple items the caller must provide the) 267.45 596.67 P
0.26 (typeID, the number of items it wishes to insert, an optional array giving the application\325) 72 583.67 P
0.26 (s itemIDs) 461.32 583.67 P
-0.07 (for each item, and an array of items to insert. The function returns an array giving the new system-) 72 570.67 P
1.28 (assigned itemIDs for the inserted items. ReturnItemArray returns copies of all the items for an) 72 557.67 P
-0.11 (item type and an array of itemIDs. If there is insuf) 72 544.67 P
-0.11 (\336cient space in the buf) 291.3 544.67 P
-0.11 (fers given to it as parame-) 390.14 544.67 P
0.08 (ters, the function returns an error and an indication of the amount of room required for each of the) 72 531.67 P
(buf) 72 518.67 T
(fers.) 86.45 518.67 T
0.52 (There are two safety issues to note in the or) 82.8 493.67 P
0.52 (ganization of parameters and results of these func-) 278.57 493.67 P
-0.2 (tions. First, the recovery box never returns a pointer to a result. In this way) 72 480.67 P
-0.2 (, it avoids passing point-) 397.08 480.67 P
2.97 (ers to its internal memory back to its caller) 72 467.67 P
2.97 (. This makes it less likely that the caller will) 283.15 467.67 P
-0.11 (accidentally access recovery box memory directly) 72 454.67 P
-0.11 (. Instead, the caller must always supply a param-) 290.7 454.67 P
0.43 (eter that is a pointer to its own buf) 72 441.67 P
0.43 (fer for results. The recovery box merely copies the results into) 226 441.67 P
(the buf) 72 428.67 T
(fer) 102.62 428.67 T
(. This incurs an extra copy) 114.21 428.67 T
(, but it provides extra safety) 230.05 428.67 T
(.) 352 428.67 T
0.02 (The second safety issue is that the caller must also indicate as a parameter the size of any buf) 82.8 403.67 P
0.02 (fer) 491.8 403.67 P
0.67 (it supplies to the recovery box. The caller supplies both the size of the buf) 72 390.67 P
0.67 (fer and the number of) 406.14 390.67 P
1.39 (objects it should be able to contain. The recovery box does its own calculation given the item) 72 377.67 P
0.67 (type\325) 72 364.67 P
0.67 (s size and checks this against the buf) 93.97 364.67 P
0.67 (fer size supplied by the caller) 259.88 364.67 P
0.67 (. It reports an error if the) 391.68 364.67 P
1.71 (caller) 72 351.67 P
1.71 (\325) 96.81 351.67 P
1.71 (s buf) 99.86 351.67 P
1.71 (fer is not lar) 123.04 351.67 P
1.71 (ge enough. Although the caller may not supply a buf) 181.35 351.67 P
1.71 (fer as lar) 427.82 351.67 P
1.71 (ge as it) 469.46 351.67 P
1.7 (claims, this extra check helps eliminate mistakes due to incorrect computations in the caller) 72 338.67 P
1.7 (\325) 496.67 338.67 P
1.7 (s) 499.73 338.67 P
-0.02 (code. The recovery box code is less likely to make these mistakes; it is likely to be exercised more) 72 325.67 P
(frequently) 72 312.67 T
(, so mistakes will be exposed early on. It is important that it be well-tested.) 116.44 312.67 T
0.05 (Finally) 82.8 287.67 P
0.05 (, there is another technique to reduce mistaken accesses to recovery box memory) 113.22 287.67 P
0.05 (. Before) 468.56 287.67 P
0.34 (returning to its caller) 72 274.67 P
0.34 (, the recovery box code should zero out the part of the system stack used for) 164.44 274.67 P
-0.09 (any recovery box functions. If this is done, the caller will not \336nd recovery box addresses in unini-) 72 261.67 P
(tialized stack variables during its next function call. I have not implemented this technique.) 72 248.67 T
0 12 Q
(5.2.2. Recovery Box Structur) 72 217 T
(e) 219.68 217 T
1 11 Q
-0.16 (The recovery box implementation is designed to provide fast atomic insert and delete operations) 82.8 191.67 P
0.14 (and fast access to items and their type information. It is important that the operations be atomic to) 72 178.67 P
1.89 (avoid leaving the recovery box in an inconsistent state due to a failure. For example, atomic) 72 165.67 P
1.54 (updates ensure that a system failure that interrupts an update will not cause checksum failure,) 72 152.67 P
(because the old value will be left intact.) 72 139.67 T
0.59 (Figure 5-2 shows the recovery box layout in memory) 82.8 114.67 P
0.59 (. There are three sections of the recovery) 320.52 114.67 P
0 (box: a header) 72 101.67 P
0 (, followed by an array of per) 130.75 101.67 P
0 (-type information, followed by the item area. In the item) 255.92 101.67 P
0.21 (area there are two arrays for each item type: an array of per) 72 88.67 P
0.21 (-item information and an array storing) 334.82 88.67 P
FMENDPAGE
%%EndPage: "85" 97
%%Page: "86" 97
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(86) 318 55 T
1 11 Q
0.18 (the items themselves. As described below) 108 132.69 P
0.18 (, a portion of the per) 291.9 132.69 P
0.18 (-item information array implements) 382.3 132.69 P
0.91 (a stack of the free items for each type, providing constant-time item insertion and deletion. The) 108 119.69 P
0.5 (type information, item information and item storage are all implemented as arrays for fast access) 108 106.69 P
-0.01 (given an array index; the recovery box typeIDs and itemNumbers are actually indices into the per) 108 93.69 P
-0.01 (-) 536.34 93.69 P
(Figure 5-2. Layout of recovery box in memory) 220.16 279.69 T
(.) 425.1 279.69 T
1 10 Q
-0.05 (The recovery box layout in memory starts with a header that gives the next typeID to allo-) 144 257.36 P
0.41 (cate, and provides a code for the current operation. The current operation code is used to) 144 246.36 P
1.43 (ensure atomicity of recovery box insertions, deletions, and updates. The header is fol-) 144 235.36 P
0.41 (lowed by an array that gives information about each type of item stored in the table. The) 144 224.36 P
0.35 (per) 144 213.36 P
0.35 (-type information is followed by the per) 156.56 213.36 P
0.35 (-item information array for the \336rst item type.) 318.35 213.36 P
-0.14 (Following the per) 144 202.36 P
-0.14 (-item information array for each item type is the array of the items them-) 214.6 202.36 P
108 170.02 540 188.02 C
108 170.02 540 188.02 R
7 X
0 K
V
108 179.02 540 179.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(selves, shown as a shaded entry in the \336gure.) 144 191.36 T
108 305.02 540 720 C
108 305.02 540 708 C
351 422.83 495 458.83 R
5 X
0 K
V
351 314.83 495 350.83 R
V
351 494.83 495 530.83 R
V
351 314.83 495 692.83 R
0.5 H
0 Z
0 X
N
1 10 Q
(currentOperation) 352.5 659.67 T
(nextT) 352.5 679.82 T
(ypeID) 375.12 679.82 T
(information for type 0) 352.5 642.82 T
(information for type 1) 352.5 625.82 T
351 674.83 495 674.83 2 L
2 Z
N
351 656.83 495 656.83 2 L
1 H
N
351 638.83 495 638.83 2 L
0.5 H
N
351 566.83 495 566.83 2 L
1 H
N
351 620.83 495 620.83 2 L
0.5 H
N
351 584.83 495 584.83 2 L
N
(information for last type) 352.5 572.82 T
351 530.83 495 530.83 2 L
N
351 494.83 495 494.83 2 L
N
351 350.83 495 350.83 2 L
N
351 458.83 495 458.83 2 L
N
351 422.83 495 422.83 2 L
N
351 386.83 495 386.83 2 L
N
(item information array for type 0) 352.5 546.82 T
(item storage array for type 0) 352.5 511.17 T
(item information array for type 1) 352.5 474.82 T
(item storage array for type 1) 352.5 436.82 T
(item information array for last type) 352.02 365.93 T
(item storage array for last type) 352.5 328.82 T
1 12 Q
(Header) 279 671.83 T
(Array of per) 171 608.83 T
(-type information) 230.03 608.83 T
(Per) 210 444.83 T
(-item information) 225.75 444.83 T
1 18 Q
(. . .) 0 -270 400 592 TF
332 599.8 332 579.27 2 L
N
180 270 9 10.27 341 579.27 A
0 90 9 10.27 323 600.76 A
332 623.2 332 643.73 2 L
N
90 180 9 10.27 341 643.73 A
270 360 9 10.27 323 622.24 A
332 670.04 332 661.35 2 L
N
180 270 9 4.35 341 661.35 A
0 90 9 4.35 323 670.45 A
332 679.96 332 688.65 2 L
N
90 180 9 4.35 341 688.65 A
270 360 9 4.35 323 679.55 A
333 410.5 333 348.81 2 L
N
180 270 9 29.48 342 348.81 A
0 90 9 29.47 324 410.5 A
333 470.84 333 532.53 2 L
N
90 180 9 29.47 342 532.53 A
270 360 9 29.47 324 470.84 A
(. . .) 0 -270 403 392 TF
1 12 Q
(arrays & item storage) 210 432.83 T
108 305.02 540 720 C
108 305.02 540 708 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "86" 98
%%Page: "87" 98
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(87) 282 55 T
1 11 Q
-0.03 (type and per) 72 712.67 P
-0.03 (-item information arrays, respectively) 126.02 712.67 P
-0.03 (. \050Since small integers are more likely than lar) 291.19 712.67 P
-0.03 (ge) 493.63 712.67 P
0.51 (ones to be used accidentally as incorrect IDs, a better implementation would be to add a positive) 72 699.67 P
(of) 72 686.67 T
(fset to all indices to create their corresponding IDs. I have not implemented this.\051) 80.95 686.67 T
0.58 (The header at the very beginning of the of the recovery box contains information that must be) 82.8 661.67 P
1.35 (saved across fast reboots. The \336rst \336eld in the header) 72 648.67 P
1.35 (,) 316.85 648.67 P
2 F
1.35 (nextT) 323.69 648.67 P
1.35 (ypeID) 347.29 648.67 P
1 F
1.35 (, gives the index of the next) 374.13 648.67 P
0.09 (typeID to be allocated. The second \336eld in the header speci\336es the current operation on the recov-) 72 635.67 P
0.47 (ery box in order to ensure that insert, delete, and update item operations are atomic. \050Other func-) 72 622.67 P
2.52 (tions, except those operating on multiple items, are already assured of being atomic in this) 72 609.67 P
0.28 (implementation, because they do not modify data.\051 At the beginning of an insert, delete or update) 72 596.67 P
0.72 (operation, this \336eld is set with a code for the current operation. In the case of a delete or update) 72 583.67 P
0.13 (operation, it also includes the tar) 72 570.67 P
0.13 (get itemID. The \336eld is not cleared until the operation completes,) 215.87 570.67 P
0.07 (making it possible to detect and back out of incomplete operations. At the beginning of an update,) 72 557.67 P
-0.17 (the original value of the item is copied to an extra item space at the end of the item storage array) 72 544.67 P
-0.17 (. If) 491.36 544.67 P
(the machine crashes during the update, the original value of the item can be retrieved.) 72 531.67 T
1.07 (The recovery box header is followed by an array) 82.8 157.69 P
1.07 (, accessed by typeID, that gives information) 304.16 157.69 P
0.74 (about each item type. Figure 5-3 shows the information stored in an entry of this per) 72 144.69 P
0.74 (-type array) 453.34 144.69 P
0.74 (.) 501.25 144.69 P
-0.25 (Each entry lists the item size, the maximum possible number of items, the current number of items,) 72 131.69 P
-0.01 (the application typeID, if any) 72 118.69 P
-0.01 (, the index in the item storage array of the \336rst free item, the memory) 200.3 118.69 P
1.31 (address of the per) 72 105.69 P
1.31 (-item information array) 153.5 105.69 P
1.31 (, the memory address of the item storage array) 258.53 105.69 P
1.31 (, and a) 472.4 105.69 P
(pointer to a checksum routine.) 72 92.69 T
(Figure 5-3. Contents of type array) 212.23 284.69 T
(.) 361.03 284.69 T
1 10 Q
0.49 (This \336gure shows the contents of an entry in the per) 108 262.36 P
0.49 (-type array) 320.3 262.36 P
0.49 (. This array lists, for each) 363.7 262.36 P
-0.17 (type, the size of the items, the maximum number of items that can be allocated, the current) 108 251.36 P
0.3 (number of allocated items, the itemNumber of the \336rst free item, the memory address for) 108 240.36 P
-0.11 (the per) 108 229.36 P
-0.11 (-item information array) 135.16 229.36 P
-0.11 (, the memory address for the item storage array) 228.11 229.36 P
-0.11 (, and a possi-) 415.59 229.36 P
72 197.02 504 215.02 C
72 197.02 504 215.02 R
7 X
0 K
V
72 206.02 504 206.02 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(ble checksum routine.) 108 218.36 T
72 310.02 504 510 C
72 310.02 504 498 C
177.69 336.01 375.69 480.01 R
0.5 H
0 Z
0 X
0 K
N
1 10 Q
(itemSize) 195.69 471.01 T
(maxNumItems) 195.69 453.01 T
(currentNumItems) 195.69 435.01 T
(applicationT) 195.69 417.01 T
(ypeID) 245.51 417.01 T
(\336rstFreeItem) 195.69 399.01 T
(address of item info array) 195.69 381.01 T
(address of item storage array) 195.69 363.01 T
(checksumFunc \050optional\051) 195.69 345.01 T
177.69 462.01 375.69 462.01 2 L
2 Z
N
177.69 444.01 375.69 444.01 2 L
N
177.69 426.01 375.69 426.01 2 L
N
177.69 408.01 375.69 408.01 2 L
N
177.69 390.01 375.69 390.01 2 L
N
177.69 372.01 375.69 372.01 2 L
N
177.69 354.01 375.69 354.01 2 L
N
72 310.02 504 510 C
72 310.02 504 498 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "87" 99
%%Page: "88" 99
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(88) 318 55 T
1 11 Q
0.32 (The caller of InitT) 118.8 712.67 P
0.32 (ype provides a checksum routine, if the caller is part of the system code. For) 199.85 712.67 P
0.34 (implementation reasons, it is currently not possible for a user) 108 699.67 P
0.34 (-level application to provide its own) 379.33 699.67 P
0.54 (type-speci\336c checksum routine. The checksum routine must take as a parameter the size in bytes) 108 686.67 P
0.53 (of the item to be checksummed. However) 108 673.67 P
0.53 (, the checksum routine used for the type containing the) 294.14 673.67 P
-0.11 (Sprite kernel\325) 108 660.67 P
-0.11 (s \336le handle items is unrolled to optimize for the 52-byte \336le handle items. If a type\325) 167.39 660.67 P
-0.11 (s) 535.73 660.67 P
(checksum routine \336eld is zero, then no checksums are calculated for that type\325) 108 647.67 T
(s items.) 451.86 647.67 T
1.55 (The per) 118.8 622.67 P
1.55 (-item information arrays are used for item allocation and for storing checksums and) 153.99 622.67 P
0.67 (application itemNumbers. An alternative to grouping the per) 108 609.67 P
0.67 (-item information into an array is to) 378.54 609.67 P
-0.2 (preface each item with a header that includes its per) 108 596.67 P
-0.2 (-item information. I chose to separate the items) 333.9 596.67 P
-0.13 (and per) 108 583.67 P
-0.13 (-item information to make the ReturnItemArray function faster and easier) 140.29 583.67 P
-0.13 (. All that function) 462.26 583.67 P
0.45 (needs to do is copy a contiguous area of memory to return to its caller) 108 570.67 P
0.45 (. Separating the two arrays) 420.72 570.67 P
(also makes memory management and debugging easier) 108 557.67 T
(.) 350.27 557.67 T
0.44 (Figure 5-4 shows the contents of an entry in an item information array) 118.8 532.67 P
0.44 (. Each entry in the array) 432.22 532.67 P
0.17 (consists of two \336elds. The \336rst is only valid if the item has been allocated. It contains the applica-) 108 519.67 P
0.98 (tion\325) 108 506.67 P
0.98 (s choice of itemNumber) 128.15 506.67 P
0.98 (, if the application provided one while inserting the item, or a -1 if) 236.51 506.67 P
2.36 (there is no application itemNumber) 108 493.67 P
2.36 (. The second \336eld has a dif) 272.45 493.67 P
2.36 (ferent meaning depending on) 404.48 493.67 P
0.86 (whether the item has been allocated or not. If the item has been allocated with a checksum per-) 108 480.67 P
0.86 (formed on it, the \336eld contains the checksum result. If the item has not been allocated, the \336eld) 108 467.67 P
1.63 (contains the index of another unallocated item in the array) 108 454.67 P
1.63 (, thus implementing a stack of free) 377.95 454.67 P
0.47 (items. For the last item in the stack this \336eld is -1. The index of the \336rst free item on the stack is) 108 441.67 P
0.69 (stored in the per) 108 428.67 P
0.69 (-type information. Upon deleting an item, its itemNumber is added to the top of) 180.96 428.67 P
(the stack. The stack of free items makes it fast to \336nd free spaces in which to insert new items.) 108 415.67 T
1.4 (Storing the application itemNumbers in the per) 118.8 111.67 P
1.4 (-item array provides quick mapping from the) 333.88 111.67 P
0.75 (recovery box system\325) 108 98.67 P
0.75 (s itemIDs to the application\325) 203.48 98.67 P
0.75 (s itemIDs; however) 331.01 98.67 P
0.75 (, mapping from application) 418.12 98.67 P
0.76 (IDs to system IDs is not particularly fast. This is why none of the functions in the recovery box) 108 85.67 P
(Figure 5-4. Contents of item information array) 220.61 227.67 T
(.) 424.65 227.67 T
1 10 Q
0.97 (This \336gure shows the contents of an entry in the per) 144 205.33 P
0.97 (-item information array) 361.15 205.33 P
0.97 (. This array) 456.26 205.33 P
0.93 (lists, for each item, the application itemNumber) 144 194.33 P
0.93 (, if one exists, and a possible checksum) 340.13 194.33 P
0.43 (value for the item. If the item is not allocated, the checksum \336eld instead gives the item-) 144 183.33 P
108 151 540 169 C
108 151 540 169 R
7 X
0 K
V
108 160 540 160 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(Number of the next unallocated item.) 144 172.33 T
108 253 540 394 C
108.5 253 539.5 382 C
217.69 270.91 415.69 342.91 R
0.5 H
0 Z
0 X
0 K
N
1 12 Q
(if allocated) 235.69 351.91 T
(if free) 343.69 351.91 T
1 10 Q
(application item #) 235.69 333.91 T
(\050-1 if none\051) 253.69 315.91 T
(checksum) 235.69 297.91 T
(index of next) 343.69 297.91 T
(free item) 361.69 285.91 T
(unused) 343.69 333.91 T
217.69 306.91 415.69 306.91 2 L
2 Z
N
325.69 342.91 325.69 270.91 2 L
N
108 253 540 394 C
108.5 253 539.5 382 R
1 H
0 Z
0 X
0 K
N
0 0 612 792 C
FMENDPAGE
%%EndPage: "88" 100
%%Page: "89" 100
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(89) 282 55 T
1 11 Q
-0.07 (interface take the application IDs as a parameter) 72 712.67 P
-0.07 (, except for the functions that return the system ID) 283.1 712.67 P
1.72 (given the application ID. Applications can maintain their own hash tables to do this mapping) 72 699.67 P
(quickly) 72 686.67 T
(, but I leave this functionality outside of the recovery box for the sake of simplicity) 104.25 686.67 T
(.) 468.48 686.67 T
0.67 (Besides considering the internal memory structure of the recovery box, we must also consider) 82.8 661.67 P
0.84 (where it is placed in memory) 72 648.67 P
0.84 (. First, the system must be able to \336nd the recovery box\325) 203.36 648.67 P
0.84 (s memory) 459.52 648.67 P
0.99 (location after a reboot. For this reason, the recovery box is always allocated at the same virtual) 72 635.67 P
0.06 (address. Keeping the recovery box at the same virtual address also ensures that absolute addresses) 72 622.67 P
-0.24 (inside the recovery box \050specifying the per) 72 609.67 P
-0.24 (-item information arrays and storage areas\051 remain valid) 258.27 609.67 P
1.34 (across fast reboots. Finally) 72 596.67 P
1.34 (, the virtual address of the recovery box must also map to the same) 193.08 596.67 P
-0.09 (physical address upon every fast reboot so that the memory location actually contains the recovery) 72 583.67 P
0.41 (box data. The operating system must avoid clearing and initializing this area of physical memory) 72 570.67 P
(on a fast reboot.) 72 557.67 T
-0.12 (The recovery box is located in a special area of the kernel text segment to minimize damage due) 82.8 532.67 P
1.18 (to memory corruption. The memory pages for the recovery box are marked writable as well as) 72 519.67 P
-0 (readable, in contrast to the rest of the text segment. I chose the text segment because it reduces the) 72 506.67 P
1.11 (sources of possible system address errors that could overwrite the recovery box. Except for the) 72 493.67 P
0.74 (recovery box, there are no writable data structures in the text segment and no sources of pointer) 72 480.67 P
1.19 (manipulation using text segment addresses. Since error statistics \050presented in the next section\051) 72 467.67 P
1.45 (show that most addressing errors are localized around the intended data structures, this should) 72 454.67 P
1.57 (eliminate most addressing errors except for those caused by manipulation of the recovery box) 72 441.67 P
(itself.) 72 428.67 T
0 12 Q
(5.2.3. Implementation Shortcomings) 72 397 T
1 11 Q
-0.11 (This section discusses four shortcomings in the current recovery box implementation: its lack of) 82.8 371.67 P
1.47 (access protection, its static memory allocation, its lack of atomicity for operations on multiple) 72 358.67 P
(items and the cost of creating and deleting types.) 72 345.67 T
0.07 (At present, there is no security provided by the recovery box, except that only applications with) 82.8 320.67 P
0.11 (root privilege can access items allocated by the kernel. Thus any privileged application can exam-) 72 307.67 P
1.56 (ine or modify items stored by another application or by the operating system itself. Also, any) 72 294.67 P
0.12 (unprivileged application can access items stored by another unprivileged application. This has not) 72 281.67 P
-0.06 (been a problem in Sprite, because we do not yet have many applications that use the recovery box.) 72 268.67 P
-0.05 (The second problem, static memory allocation, imposes a limit on the number of item types that) 82.8 243.67 P
0.67 (can be initialized and a limit on the overall size of the recovery box. This is one reason why the) 72 230.67 P
-0.2 (maximum number of items that will be valid simultaneously for a type must be speci\336ed when that) 72 217.67 P
0.33 (type is initialized. The type initialization function returns an error if there is insuf) 72 204.67 P
0.33 (\336cient space for) 433.16 204.67 P
0.08 (the desired number of items. Currently) 72 191.67 P
0.08 (, the size of the recovery box is compiled into the operating) 241.95 191.67 P
0.41 (system. If the recovery box resides in non-volatile memory such as battery-backed RAM \050to pro-) 72 178.67 P
-0.16 (tect its contents in the event of a power failure\051, it is likely that the amount of non-volatile memory) 72 165.67 P
0.18 (will already impose a size restriction. Even without such a restriction, placing the recovery box in) 72 152.67 P
0.07 (a static area of system memory) 72 139.67 P
0.07 (, such as the text segment, makes it dif) 208.01 139.67 P
0.07 (\336cult to expand the recovery) 378.02 139.67 P
-0.06 (box in physical and virtual memory while guaranteeing the same virtual/physical address mapping) 72 126.67 P
0.59 (across reboots. More complex solutions are possible, such as putting a page map of the recovery) 72 113.67 P
(box in a well-known location and allocating the recovery box pages non-contiguously) 72 100.67 T
(.) 448.73 100.67 T
FMENDPAGE
%%EndPage: "89" 101
%%Page: "90" 101
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(90) 318 55 T
1 11 Q
-0.13 (The third problem is that operations on multiple items are currently not atomic. It would be easy) 118.8 712.67 P
0.27 (to change the implementation to provide atomicity of multiple item inserts, but providing atomic-) 108 699.67 P
0.89 (ity of multiple updates and deletes would signi\336cantly increase recovery box complexity) 108 686.67 P
0.89 (. While) 506.76 686.67 P
1.43 (neither the operating system nor the applications I considered would bene\336t from atomicity of) 108 673.67 P
(multiple updates, this could be a worthwhile problem to tackle in other environments.) 108 660.67 T
0.09 (The \336nal problem is the cost of creating and deleting types. If these operations occur frequently) 118.8 635.67 P
-0.25 (they will have poor performance. Freeing a type from the middle of other allocated types can result) 108 622.67 P
-0.25 (in a fragmentation problem. The space consumed by the freed type may not be enough for any type) 108 609.67 P
0.35 (allocated subsequently) 108 596.67 P
0.35 (. If this occurs, all the item information and storage arrays could be shifted) 207.42 596.67 P
0.6 (down \050copied\051 in memory to leave enough space for the new type. The addresses in the per) 108 583.67 P
0.6 (-type) 517.42 583.67 P
0.28 (information would be updated to point to the new location of the item arrays. This shift operation) 108 570.67 P
0.1 (would not af) 108 557.67 P
0.1 (fect clients of the recovery box, because the clients have no direct pointers to internal) 163.55 557.67 P
1.82 (recovery box data. Although shifting the item data would only occur on type initialization, it) 108 544.67 P
0.01 (would be costly and the shift is not an atomic operation. It is necessary to put a code in the current) 108 531.67 P
0.43 (operation \336eld of the header to signal whether a crash occurred in the middle of a shift. If so, the) 108 518.67 P
-0.12 (recovery box would be unusable and the system would not be able to use it for fast recovery) 108 505.67 P
-0.12 (. If cli-) 510.05 505.67 P
0.84 (ents of the recovery box need to delete types frequently) 108 492.67 P
0.84 (, a dif) 358.6 492.67 P
0.84 (ferent recovery box design will be) 385.4 492.67 P
(necessary) 108 479.67 T
(.) 149.99 479.67 T
0 14 Q
(5.3. How Sprite Uses the Recovery Box) 108 446.67 T
1 11 Q
1.45 (The previous sections have described in general the motivation for the recovery box and its) 118.8 420.67 P
-0.11 (interface and design. This section turns to a more speci\336c use of the recovery box: how Sprite uses) 108 407.67 P
1.82 (it to preserve a copy of the server) 108 394.67 P
1.82 (\325) 267.89 394.67 P
1.82 (s distributed state information across failures. This section) 270.94 394.67 P
0.59 (explains when Sprite must update the recovery box, what it stores there, and how much memory) 108 381.67 P
(this requires.) 108 368.67 T
1.71 (Sprite must update recovery box items every time the distributed cache or \336le system state) 118.8 343.67 P
0.61 (changes. This occurs whenever a client opens or closes a \336le or other object. In Sprite, all opens) 108 330.67 P
0.94 (and closes are processed on the \336le server anyway) 108 317.67 P
0.94 (, which provides the opportunity to insert the) 335.68 317.67 P
0.04 (appropriate calls to recovery box functions. Cache state must also be updated when a process with) 108 304.67 P
0.27 (associated open \336les migrates from one machine to another) 108 291.67 P
0.27 (, but this is treated as if the source cli-) 370.32 291.67 P
(ent has closed its \336les and the destination client has opened them.) 108 278.67 T
0.57 (T) 118.8 253.67 P
0.57 (able 5-5 lists the components of each of the cache and \336le system state items Sprite stores in) 124.74 253.67 P
0.17 (the recovery box. Although there is a single item type for this \336le system data, the meaning of the) 108 240.67 P
1.03 (item contents dif) 108 227.67 P
1.03 (fers depending upon what is stored. Each item stores information about an I/O) 183.72 227.67 P
0.34 (handle or stream. Chapter 3 explains how the recovery system uses each \336eld of these items. The) 108 214.67 P
0.16 (\336rst \336eld of each item is an) 108 201.67 P
2 F
0.16 (ID) 231.45 201.67 P
1 F
0.16 (. For \336les, pseudo devices and other objects in the \336le systems, this) 243.04 201.67 P
-0.25 (is the \336le ID that identi\336es the object via its I/O handle. For streams, this is the stream ID that iden-) 108 188.67 P
0.39 (ti\336es the open stream that references an I/O handle. I have modi\336ed these IDs to include the host) 108 175.67 P
0.12 (number of the client responsible for the item reference. I/O handle and stream IDs usually include) 108 162.67 P
0.61 (the server) 108 149.67 P
0.61 (\325) 152.03 149.67 P
0.61 (s number) 155.08 149.67 P
0.61 (, but the server is well-known in this case. The second \336eld,) 195.83 149.67 P
2 F
0.61 (otherID) 468.9 149.67 P
1 F
0.61 (, is only) 503.68 149.67 P
0.28 (used if the ID is for a stream. If so, then otherID is the \336le ID of the I/O handle referenced by the) 108 136.67 P
-0.02 (stream. The) 108 123.67 P
2 F
-0.02 (use) 162.57 123.67 P
1 F
-0.02 (\336eld gives the number of references a client has to the handle or stream, separated) 179.95 123.67 P
0.07 (into read and write references. For an I/O handle, this is how many open streams the client has for) 108 110.67 P
0.91 (that I/O handle. For streams, this is the number of times the client has) 108 97.67 P
2 F
0.91 (dup) 429.57 97.67 P
1 F
0.91 (\325ed the stream or the) 446.05 97.67 P
0.56 (stream has been inherited by another process on that client. The) 108 84.67 P
2 F
0.56 (info) 396.75 84.67 P
1 F
0.56 ( \336eld gives information spe-) 413.85 84.67 P
FMENDPAGE
%%EndPage: "90" 102
%%Page: "91" 102
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(91) 282 55 T
1 11 Q
-0.15 (ci\336c to the type of handle. For \336le I/O handles this gives the version number of the \336le. For pseudo) 72 712.67 P
0.13 (devices this gives the ID of the host running the pseudo-device server) 72 699.67 P
0.13 (. For streams it gives further) 378.86 699.67 P
1.05 (stream-speci\336c user \337ags. The) 72 686.67 P
2 F
1.05 (clientData) 212.59 686.67 P
1 F
1.05 ( \336eld is also speci\336c to the handle type. For \336les, this) 258.97 686.67 P
1.03 (\336eld indicates whether the \336le is cached or uncacheable. For pseudo devices, it gives a number) 72 673.67 P
0.34 (called the seed which indicates the instantiation of the pseudo device. For streams, the \336eld gives) 72 660.67 P
(the current of) 72 647.67 T
(fset into the stream.) 130.99 647.67 T
0.16 (Using the recovery box requires the addition of a some new bookkeeping code in the Sprite \336le) 82.8 329.69 P
0.52 (system for a couple of reasons. First, this code is responsible for inserting, deleting and updating) 72 316.69 P
0.35 (items in the recovery box. It copies the relevant portions of I/O handles and streams into items to) 72 303.69 P
0.83 (store in the recovery box. It currently uses a hash table to map from I/O handles and streams to) 72 290.69 P
-0.07 (their recovery box items. Second, for convenience this extra code also maintains the per) 72 277.69 P
-0.07 (-client ref-) 457.4 277.69 P
(erence counts in these hash table entries, to avoid extra accesses to the recovery box. \050These refer-) 72 264.69 T
0.37 (ence counts are dif) 72 251.69 P
0.37 (ferent from the ones already in I/O handles, because the I/O handle use counts) 155.6 251.69 P
0.19 (on the server include the total references from all clients to the object, rather than per) 72 238.69 P
0.19 (-client refer-) 448.61 238.69 P
0.12 (ences.\051 Much of this extra bookkeeping could be eliminated if I were to restructure Sprite\325) 72 225.69 P
0.12 (s server) 470.02 225.69 P
(\336le handles to include the per) 72 212.69 T
(-client reference counts and the recovery box item ID.) 201.46 212.69 T
-0.01 (The recovery box does not need much of the \336le server) 82.8 187.69 P
-0.01 (\325) 325.37 187.69 P
-0.01 (s memory) 328.42 187.69 P
-0.01 (. On average, the server main-) 371.34 187.69 P
1.5 (tains 10,000 to 15,000 handles and streams for about 40 clients, as measured on the main \336le) 72 174.69 P
0.33 (server in the production Sprite system. However) 72 161.69 P
0.33 (, only about half of these need to be stored in the) 286.2 161.69 P
0.36 (recovery box, because only half are streams or I/O handles for objects that are open or have dirty) 72 148.69 P
0.43 (cache blocks on a client. \050The ratio of unopened, clean \336les to open or dirty \336les is higher on the) 72 135.69 P
-0.06 (server than the ratio described in chapter 3 for the clients, because the server recycles the unneces-) 72 122.69 P
0.51 (sary I/O handles faster than its clients do.\051 W) 72 109.69 P
0.51 (ith 40 clients this gives us 5000 to 7500 handles on) 274.28 109.69 P
0.72 (average that need to be stored in the recovery box. From each of these structures the server pre-) 72 96.69 P
72 81 504 720 C
72 351.02 504 644 C
70.99 358 506.99 638 R
7 X
0 K
V
1 11 Q
0 X
(T) 166.86 425.67 T
(able 5-5. Components of distributed cache state items.) 172.8 425.67 T
1 10 Q
0.28 (This table lists the components of each item Sprite stores in the recovery box. These com-) 106.99 401.33 P
0.28 (ponents are further described in the text. There is one item for each I/O handle and stream) 106.99 390.33 P
72 358 504 376 C
70.99 358 506.99 376 R
7 X
0 K
V
70.99 367 502.99 367 2 L
V
0.5 H
2 Z
0 X
N
72 351.02 504 644 C
1 10 Q
0 X
0 K
(accessed by each client.) 106.99 379.33 T
(Field) 138.21 598.33 T
(Purpose) 315.89 598.33 T
(ID) 109.49 580.33 T
-0.33 (File ID for I/O handle \050\336le, pseudo device, or other\051 or stream ID for) 195.49 580.33 P
(stream. This includes the client host ID.) 195.49 568.33 T
(otherID) 109.49 550.33 T
(If ID was for a stream, this is the ID of the associated I/O handle.) 195.49 550.33 T
(Otherwise it\325) 195.49 538.33 T
(s empty) 247.4 538.33 T
(.) 278.12 538.33 T
(use) 109.49 520.33 T
(Number of client\325) 195.49 520.33 T
(s references to handle or stream.) 266.55 520.33 T
(info) 109.49 502.33 T
(For \336les: version number) 195.49 502.33 T
(. For pseudo devices, serverID. For) 295.71 502.33 T
(streams: more use \337ags. Otherwise unused.) 195.49 490.33 T
(clientData) 109.49 472.33 T
(For \336les: whether cacheable. For pseudo devices: seed number) 195.49 472.33 T
(. For) 445.58 472.33 T
(streams: of) 195.49 460.33 T
(fset. Otherwise unused.) 239.44 460.33 T
105.49 608 105.49 454 2 L
V
2 H
0 Z
N
191.49 610 191.49 452 2 L
V
N
472.49 608 472.49 454 2 L
V
N
104.49 609 473.49 609 2 L
V
N
106.49 592.25 471.49 592.25 2 L
V
0.5 H
N
106.49 589.75 471.49 589.75 2 L
V
N
104.49 561 473.49 561 2 L
V
N
104.49 531 473.49 531 2 L
V
N
104.49 513 473.49 513 2 L
V
N
104.49 483 473.49 483 2 L
V
N
104.49 453 473.49 453 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "91" 103
%%Page: "92" 103
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(92) 318 55 T
1 11 Q
1.25 (serves 52 bytes of essential information in the recovery box, making the server) 108 712.67 P
1.25 (\325) 469.76 712.67 P
1.25 (s recovery box) 472.82 712.67 P
-0.01 (space requirements less than 400 kilobytes for 40 clients, including space for the per) 108 699.67 P
-0.01 (-type and per) 478.62 699.67 P
-0.01 (-) 536.34 699.67 P
(object information arrays.) 108 686.67 T
0 14 Q
(5.4. Results and Measur) 108 653.67 T
(ements) 251.17 653.67 T
1 11 Q
1 (This section evaluates the performance of transparent recovery and the recovery box itself. It) 118.8 627.67 P
0.55 (\336rst gives the transparent distributed state recovery time, including measurements across varying) 108 614.67 P
-0.05 (numbers of clients to show how it scales to lar) 108 601.67 P
-0.05 (ger systems. This is followed by timings of the indi-) 310.92 601.67 P
-0.19 (vidual components of transparent recovery) 108 588.67 P
-0.19 (. Besides recovery timings, I also include measurements) 294.47 588.67 P
0.24 (of the \336le system overhead caused by maintaining the recovery box during normal operation. The) 108 575.67 P
0.49 (ef) 108 562.67 P
0.49 (fect of the recovery box on regular execution is only a few percent. The overall ef) 116.34 562.67 P
0.49 (fect of trans-) 482.89 562.67 P
0.09 (parent recovery on reboot times depends on how often the recovery box is corrupted. If the recov-) 108 549.67 P
0.02 (ery box has been corrupted by a software error or power failure, recovery time will take as long as) 108 536.67 P
-0.27 (the backup recovery mechanism plus the time it took to start transparent recovery and discover that) 108 523.67 P
1.01 (the recovery box was corrupted. Unless otherwise speci\336ed, all measurements were done in the) 108 510.67 P
(testbed setup described in chapter 3 using the basic state setup presented in T) 108 497.67 T
(able 3-5.) 446.23 497.67 T
0 12 Q
(5.4.1. Recovery T) 108 466 T
(imes) 196.71 466 T
1 11 Q
1.01 (T) 118.8 440.67 P
1.01 (ransparent recovery is the fastest method for recovering the distributed cache state informa-) 125.13 440.67 P
0.08 (tion. The time required to recover state for ten clients in the testbed setup is 1.47 seconds. Run six) 108 427.67 P
-0.02 (times, this test showed a standard deviation of 3%. However) 108 414.67 P
-0.02 (, transparent recovery in Sprite is disk) 373.19 414.67 P
-0.05 (I/O bound, so it scales no better to lar) 108 401.67 P
-0.05 (ger numbers of clients than does server) 272.51 401.67 P
-0.05 (-driven recovery) 444.09 401.67 P
-0.05 (. Fig-) 516.24 401.67 P
0.24 (ure 5-5 shows transparent recovery times for varying numbers of clients. From the apparent slope) 108 388.67 P
0.16 (of the measurements, we see that each additional client in the testbed setup adds 130 milliseconds) 108 375.67 P
0.08 (to the recovery time. Figure 5-6 and Figure 5-7 show us that with three or more clients, the disk is) 108 362.67 P
(75 to 80% utilized, while the CPU is only 45 to 50% utilized.) 108 349.67 T
0.16 (T) 118.8 324.67 P
0.16 (able 5-6 shows a breakdown into component parts of the transparent recovery time for ten cli-) 124.74 324.67 P
1.01 (ents. I/O handle recovery is the most expensive part of transparent recovery) 108 311.67 P
1.01 (, because the server) 450.95 311.67 P
0.13 (spends the bulk of this time retrieving \336le descriptor information from disk for the I/O handles, as) 108 298.67 P
0.73 (described in section 3.1.4. This transparent recovery test causes 632 descriptor read requests. Of) 108 285.67 P
0.14 (these requests, 600 correspond to the 60 unshared \336les per client. There are 30 additional requests) 108 272.67 P
1.93 (for the shared \336les, since these need only be read once. There are two additional descriptors) 108 259.67 P
0.51 (fetched: one for the \336le system root directory and one for the \336le created and unlinked by one of) 108 246.67 P
0.01 (the clients. However) 108 233.67 P
0.01 (, many of these descriptor read requests do not require an actual disk I/O. File) 198.19 233.67 P
0.54 (descriptors for \336les in the same directory are usually placed together in a disk block, so one disk) 108 220.67 P
0.86 (I/O may read in many \336le descriptors \050up to 32 descriptors\051, which the server then caches in its) 108 207.67 P
0.27 (main memory) 108 194.67 P
0.27 (. Thus some requests \336nd the descriptor already cached. I arbitrarily spread the \336les) 168.89 194.67 P
0.91 (out through about 30 directories, with the result that 51 disk accesses are necessary for the test.) 108 181.67 P
(Direct measurements con\336rm that the disk is 95% busy during this part of transparent recovery) 108 168.67 T
(.) 524.7 168.67 T
-0.16 ( I/O handle recovery would take even longer if I did not enable overlap of I/O and CPU process-) 118.8 143.67 P
0.08 (ing. One of the problems for transparent recovery in Sprite is that the distributed state information) 108 130.67 P
1 (is not retrieved from the recovery box through RPC requests. In client-driven and server) 108 117.67 P
1 (-driven) 508.27 117.67 P
0.13 (recovery) 108 104.67 P
0.13 (, RPC server processes automatically provide us with multiple processes to handle recov-) 145.72 104.67 P
FMENDPAGE
%%EndPage: "92" 104
%%Page: "93" 104
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(93) 282 55 T
1 11 Q
0.55 (ery) 72 230.92 P
0.55 (. This allows for automatic overlap of I/O and CPU processing as the dif) 85.32 230.92 P
0.55 (ferent processes exe-) 410.79 230.92 P
(cute. For transparent recovery) 72 217.92 T
(, I had to create extra processes speci\336cally to enable this overlap.) 203.08 217.92 T
2.33 (T) 82.8 192.92 P
2.33 (o improve transparent recovery time further it is necessary to eliminate disk I/O for \336le) 88.74 192.92 P
1.59 (descriptor fetches. There are two options for avoiding this I/O. As described for server) 72 179.92 P
1.59 (-driven) 472.27 179.92 P
0.58 (recovery) 72 166.92 P
0.58 (, one possibility is to delay the I/O until after recovery) 109.72 166.92 P
0.58 (, and only fetch the descriptors as) 353.14 166.92 P
(they are referenced. This may not save much time, since the descriptors are likely to be referenced) 72 153.92 T
1.45 (quickly) 72 140.92 P
1.45 (. T) 104.25 140.92 P
1.45 (ransparent recovery presents a new option: the system can store some of the needed) 117.51 140.92 P
-0.26 (descriptor information in the recovery box, so that the server can recover it too from main memory) 72 127.92 P
-0.26 (.) 501.25 127.92 P
(I have not implemented either of these options.) 72 114.92 T
(Figure 5-5. T) 167.52 399.92 T
(ransparent recovery by number of clients.) 225.42 399.92 T
1 10 Q
-0.12 (This graph gives the time for transparent recovery as a function of the number of clients in) 108 377.58 P
-0.05 (the testbed setup. The X axis gives the number of clients in the timings, and the Y axis the) 108 366.58 P
-0.09 (number of seconds required for recovery) 108 355.58 P
-0.09 (. There are \336ve to six data points for each number) 269.84 355.58 P
-0.08 (of clients, but some of the points lie on top of each other so they are not separately visible.) 108 344.58 P
0.79 (The dotted line gives the apparent slope of the measurements, using least-squares linear) 108 333.58 P
0.51 (regression. The slope of the line is 0.129 seconds per client. The per) 108 322.58 P
0.51 (-client setup for this) 386.24 322.58 P
0.86 (data is shown in T) 108 311.58 P
0.86 (able 3-5, with one modi\336cation: to make the setup more realistic, for) 184.02 311.58 P
0.15 (timings of one to nine clients, only one client repeatedly truncated and wrote a \336le. When) 108 300.58 P
72 268.25 504 286.25 C
72 268.25 504 286.25 R
7 X
0 K
V
72 277.25 504 277.25 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(ten clients were available, two clients participated in this activity) 108 289.58 T
(.) 366.62 289.58 T
72 425.25 504 720 C
72 425.25 504 708 C
0 0 0 539 449 402.75 281.25 87.75 424.5 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/transVary.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 449
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 7360 3 just-string
200 /Times-Roman choose-font
() 7106 6608 2 just-string
() 7106 6316 2 just-string
() 7106 6024 2 just-string
() 7106 5732 2 just-string
() 7106 5440 2 just-string
() 7106 5148 2 just-string
() 7106 4856 2 just-string
() 7106 4564 2 just-string
() 7106 4272 2 just-string
() 7106 3980 2 just-string
() 7106 3688 2 just-string
() 7106 3396 2 just-string
() 7106 3104 2 just-string
() 7106 2812 2 just-string
() 7106 2520 2 just-string
() 7106 2228 2 just-string
() 7106 1936 2 just-string
() 7106 1644 2 just-string
() 7106 1352 2 just-string
() 7106 1060 2 just-string
() 7106 768 2 just-string
14 setlinewidth
[] 0 setdash
(Seconds) 560 6800 2 just-string
(Number of clients) 7106 380 1 just-string
(0.00) 860 663 5 just-string
(0.20) 860 1292 5 just-string
(0.40) 860 1922 5 just-string
(0.60) 860 2551 5 just-string
(0.80) 860 3180 5 just-string
(1.00) 860 3810 5 just-string
(1.20) 860 4439 5 just-string
(1.40) 860 5068 5 just-string
(1.60) 860 5698 5 just-string
(1.80) 860 6327 5 just-string
(    0) 1226 90 7 just-string
(    2) 2329 90 7 just-string
(    4) 3432 90 7 just-string
(    6) 4534 90 7 just-string
(    8) 5637 90 7 just-string
(   10) 6740 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  950 663 moveto
  1225 663 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1292 moveto
  1225 1292 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1922 moveto
  1225 1922 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2551 moveto
  1225 2551 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3180 moveto
  1225 3180 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3810 moveto
  1225 3810 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4439 moveto
  1225 4439 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5068 moveto
  1225 5068 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5698 moveto
  1225 5698 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 6327 moveto
  1225 6327 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1226 663 moveto
  1226 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  2329 663 moveto
  2329 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  3432 663 moveto
  3432 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4534 663 moveto
  4534 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  5637 663 moveto
  5637 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6740 663 moveto
  6740 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1225 6327 moveto
  1225 663 lineto
  6740 663 lineto
  6740 6327 lineto
  1225 6327 lineto
stroke
1777 1796 24 mark0
1777 1796 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  1777 1796 moveto
  1777 1796 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 1733 24 mark0
1777 1733 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  1777 1733 moveto
  1777 1733 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 1796 24 mark0
1777 1796 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1777 1796 moveto
  1777 1796 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 1733 24 mark0
1777 1733 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  1777 1733 moveto
  1777 1733 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 1733 24 mark0
1777 1733 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  1777 1733 moveto
  1777 1733 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5068 24 mark0
6740 5068 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6740 5068 moveto
  6740 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5383 24 mark0
6740 5383 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6740 5383 moveto
  6740 5383 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5446 24 mark0
6740 5446 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6740 5446 moveto
  6740 5446 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5383 24 mark0
6740 5383 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6740 5383 moveto
  6740 5383 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5320 24 mark0
6740 5320 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6740 5320 moveto
  6740 5320 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5131 24 mark0
6740 5131 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  6740 5131 moveto
  6740 5131 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2299 24 mark0
2329 2299 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2329 2299 moveto
  2329 2299 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2236 24 mark0
2329 2236 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2329 2236 moveto
  2329 2236 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2111 24 mark0
2329 2111 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  2329 2111 moveto
  2329 2111 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2236 24 mark0
2329 2236 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  2329 2236 moveto
  2329 2236 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2173 24 mark0
2329 2173 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  2329 2173 moveto
  2329 2173 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 2677 24 mark0
2880 2677 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  2880 2677 moveto
  2880 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 2677 24 mark0
2880 2677 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2880 2677 moveto
  2880 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 2677 24 mark0
2880 2677 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2880 2677 moveto
  2880 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 2677 24 mark0
2880 2677 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2880 2677 moveto
  2880 2677 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 2488 24 mark0
2880 2488 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2880 2488 moveto
  2880 2488 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 2929 24 mark0
3432 2929 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3432 2929 moveto
  3432 2929 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 2929 24 mark0
3432 2929 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3432 2929 moveto
  3432 2929 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3054 24 mark0
3432 3054 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3432 3054 moveto
  3432 3054 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 2992 24 mark0
3432 2992 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  3432 2992 moveto
  3432 2992 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 2992 24 mark0
3432 2992 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  3432 2992 moveto
  3432 2992 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3180 24 mark0
3983 3180 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  3983 3180 moveto
  3983 3180 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3306 24 mark0
3983 3306 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3983 3306 moveto
  3983 3306 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3306 24 mark0
3983 3306 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3983 3306 moveto
  3983 3306 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3432 24 mark0
3983 3432 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3983 3432 moveto
  3983 3432 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3306 24 mark0
3983 3306 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3983 3306 moveto
  3983 3306 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3998 24 mark0
4534 3998 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  4534 3998 moveto
  4534 3998 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4061 24 mark0
4534 4061 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  4534 4061 moveto
  4534 4061 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 4061 24 mark0
4534 4061 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  4534 4061 moveto
  4534 4061 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3936 24 mark0
4534 3936 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  4534 3936 moveto
  4534 3936 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3998 24 mark0
4534 3998 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  4534 3998 moveto
  4534 3998 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4187 24 mark0
5086 4187 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5086 4187 moveto
  5086 4187 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4124 24 mark0
5086 4124 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5086 4124 moveto
  5086 4124 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4250 24 mark0
5086 4250 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5086 4250 moveto
  5086 4250 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4313 24 mark0
5086 4313 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5086 4313 moveto
  5086 4313 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 4187 24 mark0
5086 4187 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  5086 4187 moveto
  5086 4187 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4879 24 mark0
5637 4879 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  5637 4879 moveto
  5637 4879 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4879 24 mark0
5637 4879 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  5637 4879 moveto
  5637 4879 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4817 24 mark0
5637 4817 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5637 4817 moveto
  5637 4817 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4691 24 mark0
5637 4691 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5637 4691 moveto
  5637 4691 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 4817 24 mark0
5637 4817 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5637 4817 moveto
  5637 4817 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5131 24 mark0
6189 5131 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6189 5131 moveto
  6189 5131 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5068 24 mark0
6189 5068 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6189 5068 moveto
  6189 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5194 24 mark0
6189 5194 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6189 5194 moveto
  6189 5194 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 5068 24 mark0
6189 5068 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6189 5068 moveto
  6189 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 1226 1396 24 mark0
6740 5456 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1226 1396 moveto
  6740 5456 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
72 425.25 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "93" 105
%%Page: "94" 105
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(94) 318 55 T
0 F
(5.4.2. File System Overhead) 108 274.25 T
1 11 Q
0.12 (Maintaining the contents of the recovery box during normal system processing does not signi\336-) 118.8 248.92 P
0.5 (cantly reduce the performance of Sprite. T) 108 235.92 P
0.5 (able 5-7 shows the breakdown of time required for the) 296.62 235.92 P
1.29 (Sprite \336le system recovery box operations. The table gives accumulative measurements for the) 108 222.92 P
0.27 (recovery box code itself, for the \336le system layer that calls the recovery box code, and for the \336le) 108 209.92 P
1.51 (open and close times seen by a SP) 108 196.92 P
1.51 (ARCstation-2 client of the \336le server) 268.03 196.92 P
1.51 (, with and without the) 437.81 196.92 P
0.63 (recovery box. The \336le open/close measurements include the time for the kernel-to-kernel remote) 108 183.92 P
0.81 (procedure calls between the client and \336le server) 108 170.92 P
0.81 (. For convenience I report the measurements in) 327.5 170.92 P
-0.09 (terms of pairs of operations) 108 157.92 P
3 F
-0.09 (-) 231.15 157.92 P
1 F
-0.09 ( recovery box item insert/delete operations and \336le open/close opera-) 237.18 157.92 P
(tions.) 108 144.92 T
1.02 (For a SP) 118.8 119.92 P
1.02 (ARCstation-2 Sprite \336le server) 157.67 119.92 P
1.02 (, the time to insert, checksum and delete a \336le handle) 296.7 119.92 P
-0.04 (item in the recovery box is 28 microseconds on average. This includes four microseconds per han-) 108 106.92 P
(Figure 5-6. Disk utilization during transparent recovery) 201.09 399.92 T
(.) 444.17 399.92 T
1 10 Q
1.5 (This graph gives the percent of disk utilization during transparent recovery versus the) 144 377.58 P
0.41 (number of clients in the testbed setup. The X axis gives the number of clients in the tim-) 144 366.58 P
0.1 (ings, and the Y axis gives the percent utilization. There are \336ve to six data points for each) 144 355.58 P
-0.16 (number of clients, but some of the points lie on top of each other so they are not separately) 144 344.58 P
108 312.25 540 330.25 C
108 312.25 540 330.25 R
7 X
0 K
V
108 321.25 540 321.25 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(visible.) 144 333.58 T
108 425.25 540 720 C
108 425.25 540 708 C
0 0 0 539 449 393.75 279 126.95 429 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/transUtilDisk.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 449
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 7360 3 just-string
200 /Times-Roman choose-font
() 7106 6608 2 just-string
() 7106 6316 2 just-string
() 7106 6024 2 just-string
() 7106 5732 2 just-string
() 7106 5440 2 just-string
() 7106 5148 2 just-string
() 7106 4856 2 just-string
() 7106 4564 2 just-string
() 7106 4272 2 just-string
() 7106 3980 2 just-string
() 7106 3688 2 just-string
() 7106 3396 2 just-string
() 7106 3104 2 just-string
() 7106 2812 2 just-string
() 7106 2520 2 just-string
() 7106 2228 2 just-string
() 7106 1936 2 just-string
() 7106 1644 2 just-string
() 7106 1352 2 just-string
() 7106 1060 2 just-string
() 7106 768 2 just-string
14 setlinewidth
[] 0 setdash
(Percent utilized) 560 6800 2 just-string
(Number of clients) 7106 380 1 just-string
(    0) 860 663 5 just-string
(   10) 860 1230 5 just-string
(   20) 860 1796 5 just-string
(   30) 860 2362 5 just-string
(   40) 860 2929 5 just-string
(   50) 860 3495 5 just-string
(   60) 860 4061 5 just-string
(   70) 860 4628 5 just-string
(   80) 860 5194 5 just-string
(   90) 860 5760 5 just-string
(  100) 860 6327 5 just-string
(    0) 1226 90 7 just-string
(    2) 2329 90 7 just-string
(    4) 3432 90 7 just-string
(    6) 4534 90 7 just-string
(    8) 5637 90 7 just-string
(   10) 6740 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  950 663 moveto
  1225 663 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1230 moveto
  1225 1230 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1796 moveto
  1225 1796 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2362 moveto
  1225 2362 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2929 moveto
  1225 2929 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3495 moveto
  1225 3495 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4061 moveto
  1225 4061 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4628 moveto
  1225 4628 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5194 moveto
  1225 5194 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5760 moveto
  1225 5760 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 6327 moveto
  1225 6327 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1226 663 moveto
  1226 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  2329 663 moveto
  2329 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  3432 663 moveto
  3432 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4534 663 moveto
  4534 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  5637 663 moveto
  5637 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6740 663 moveto
  6740 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1225 6327 moveto
  1225 663 lineto
  6740 663 lineto
  6740 6327 lineto
  1225 6327 lineto
stroke
8 setlinewidth 1777 5068 24 mark0
1777 5068 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  1777 5068 moveto
  1777 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4994 24 mark0
1777 4994 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  1777 4994 moveto
  1777 4994 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 5068 24 mark0
1777 5068 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  1777 5068 moveto
  1777 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4661 24 mark0
1777 4661 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1777 4661 moveto
  1777 4661 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 4661 24 mark0
1777 4661 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  1777 4661 moveto
  1777 4661 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5113 24 mark0
6740 5113 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6740 5113 moveto
  6740 5113 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 4968 24 mark0
6740 4968 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6740 4968 moveto
  6740 4968 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 4985 24 mark0
6740 4985 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6740 4985 moveto
  6740 4985 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 4968 24 mark0
6740 4968 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6740 4968 moveto
  6740 4968 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 5102 24 mark0
6740 5102 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6740 5102 moveto
  6740 5102 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 4971 24 mark0
6740 4971 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6740 4971 moveto
  6740 4971 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4802 24 mark0
2329 4802 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2329 4802 moveto
  2329 4802 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 5194 24 mark0
2329 5194 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2329 5194 moveto
  2329 5194 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4849 24 mark0
2329 4849 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2329 4849 moveto
  2329 4849 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 4741 24 mark0
2329 4741 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  2329 4741 moveto
  2329 4741 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 5147 24 mark0
2329 5147 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  2329 5147 moveto
  2329 5147 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 5088 24 mark0
2880 5088 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  2880 5088 moveto
  2880 5088 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 5265 24 mark0
2880 5265 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  2880 5265 moveto
  2880 5265 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 5088 24 mark0
2880 5088 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2880 5088 moveto
  2880 5088 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 5265 24 mark0
2880 5265 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2880 5265 moveto
  2880 5265 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 4960 24 mark0
2880 4960 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2880 4960 moveto
  2880 4960 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5068 24 mark0
3432 5068 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3432 5068 moveto
  3432 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5068 24 mark0
3432 5068 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3432 5068 moveto
  3432 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 4985 24 mark0
3432 4985 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3432 4985 moveto
  3432 4985 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5102 24 mark0
3432 5102 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3432 5102 moveto
  3432 5102 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 5255 24 mark0
3432 5255 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  3432 5255 moveto
  3432 5255 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 5053 24 mark0
3983 5053 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  3983 5053 moveto
  3983 5053 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4843 24 mark0
3983 4843 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  3983 4843 moveto
  3983 4843 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4978 24 mark0
3983 4978 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3983 4978 moveto
  3983 4978 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 5168 24 mark0
3983 5168 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3983 5168 moveto
  3983 5168 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 4843 24 mark0
3983 4843 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3983 4843 moveto
  3983 4843 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 5151 24 mark0
4534 5151 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  4534 5151 moveto
  4534 5151 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 5068 24 mark0
4534 5068 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  4534 5068 moveto
  4534 5068 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 5173 24 mark0
4534 5173 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  4534 5173 moveto
  4534 5173 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 5238 24 mark0
4534 5238 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  4534 5238 moveto
  4534 5238 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 5258 24 mark0
4534 5258 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  4534 5258 moveto
  4534 5258 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 5113 24 mark0
5086 5113 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5086 5113 moveto
  5086 5113 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 5194 24 mark0
5086 5194 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5086 5194 moveto
  5086 5194 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 5134 24 mark0
5086 5134 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5086 5134 moveto
  5086 5134 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 5350 24 mark0
5086 5350 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5086 5350 moveto
  5086 5350 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 5214 24 mark0
5086 5214 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5086 5214 moveto
  5086 5214 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5059 24 mark0
5637 5059 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  5637 5059 moveto
  5637 5059 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5143 24 mark0
5637 5143 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  5637 5143 moveto
  5637 5143 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5125 24 mark0
5637 5125 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  5637 5125 moveto
  5637 5125 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5176 24 mark0
5637 5176 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5637 5176 moveto
  5637 5176 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 5211 24 mark0
5637 5211 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5637 5211 moveto
  5637 5211 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4971 24 mark0
6189 4971 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6189 4971 moveto
  6189 4971 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4951 24 mark0
6189 4951 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6189 4951 moveto
  6189 4951 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4990 24 mark0
6189 4990 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6189 4990 moveto
  6189 4990 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 4870 24 mark0
6189 4870 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6189 4870 moveto
  6189 4870 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
108 425.25 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "94" 106
%%Page: "95" 106
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(95) 282 55 T
1 11 Q
1.03 (dle for the checksum calculation. The open/close test performs two insert operations during \336le) 72 274.92 P
(open and two delete operations during \336le close for reasons explained below) 72 261.92 T
(.) 407.83 261.92 T
-0.13 (The \336le system bookkeeping code that calls the recovery box adds more time to the insert/delete) 82.8 236.92 P
0.36 (operation, for a total of 72.3 microseconds on average. This includes the 28 microseconds for the) 72 223.92 P
1.2 (recovery box functions. In part, the extra time results from setting up the items to insert in the) 72 210.92 P
0.41 (recovery box, but it is also due to a problem in the current implementation. Inserts and deletes of) 72 197.92 P
-0.21 (\336le handle items currently require some extra bookkeeping and a hash table lookup. The hash table) 72 184.92 P
1.41 (maps from \336le handles to itemNumbers and recovery box item reference counts. Much of this) 72 171.92 P
-0.13 (extra code would be unnecessary if we could avoid this mapping by changing the format of the \336le) 72 158.92 P
0.51 (handle structure in Sprite to include the itemNumber and recovery box reference count. Unfortu-) 72 145.92 P
1.88 (nately modifying the I/O handle structure would require recompiling and rebooting the entire) 72 132.92 P
1.64 (Sprite cluster) 72 119.92 P
1.64 (, because the hosts in my test network still depend on the real Sprite servers for) 131.49 119.92 P
0.21 (accessing the root \336le system and other services. The resulting outage would af) 72 106.92 P
0.21 (fect many irritable) 422.43 106.92 P
(graduate students and aggressive faculty members.) 72 93.92 T
(Figure 5-7. CPU utilization during transparent recovery) 164.78 399.92 T
(.) 408.48 399.92 T
1 10 Q
1.27 (This graph gives the percent of CPU utilization during transparent recovery versus the) 108 377.58 P
0.41 (number of clients in the testbed setup. The X axis gives the number of clients in the tim-) 108 366.58 P
0.1 (ings, and the Y axis gives the percent utilization. There are \336ve to six data points for each) 108 355.58 P
-0.16 (number of clients, but some of the points lie on top of each other so they are not separately) 108 344.58 P
72 312.25 504 330.25 C
72 312.25 504 330.25 R
7 X
0 K
V
72 321.25 504 321.25 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
1 10 Q
0 X
0 K
(visible) 108 333.58 T
72 425.25 504 720 C
73.12 425.25 502.88 708 C
0 0 0 539 449 396 281.25 88.88 426.75 FMBEGINEPSF
%%BeginDocument: /home/ginger/sprite/users/mgbaker/thesis/tech-report/transUtilCpu.ps
%!PS-Adobe-2.0 EPSF-1.2
%%BoundingBox: 0 0 539 449
%%EndComments
%
% Xgraph postscript output
% Rick Spickelmier and David Harrison
% University of California, Berkeley
%
% Output produced for inclusion in another document.
% This file will not work properly if sent directly to a printer.
%
% Rotation and centering are turned off for inclusion in a document
% Set the scale
0.06 0.06 scale
% Font Handling Functions
%
% Function giving y-offset to center of font
% Assumes font is set and uses numbers to gauge center
%
/choose-font	% stack: fontsize fontname => ---
{
   findfont 
   exch scalefont 
   setfont
   newpath
   0 0 moveto (0) true charpath flattenpath pathbbox
   /top exch def pop
   /bottom exch def pop
   bottom top bottom top add 2 div
   /center-font-val exch def 
   /upper-font-val exch def 
   /lower-font-val exch def
} def
%
% Justfication offset routines
%
/center-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop 2 div sub exch
} def
%
/left-x-just	% stack: (string) x y => (string) newx y
{ 
} def
%
/right-x-just	% stack: (string) x y => (string) newx y
{
   exch 2 index stringwidth pop sub exch
} def
%
/center-y-just	% stack: (string) x y => (string) x newy
{
   center-font-val sub
} def
%
/lower-y-just	% stack: (string) x y => (string) x newy
{
   lower-font-val sub
} def
%
/upper-y-just	% stack: (string) x y => (string) x newy
{
   upper-font-val sub
} def
%
% Shows a string on the page subject to justification
%   
/just-string	% stack: (string) x y just => ---
{
   dup 0 eq { pop center-x-just center-y-just 		} if
   dup 1 eq { pop left-x-just center-y-just		} if
   dup 2 eq { pop left-x-just upper-y-just	 	} if
   dup 3 eq { pop center-x-just upper-y-just 		} if
   dup 4 eq { pop right-x-just upper-y-just	 	} if
   dup 5 eq { pop right-x-just center-y-just 		} if
   dup 6 eq { pop right-x-just lower-y-just	 	} if
   dup 7 eq { pop center-x-just lower-y-just  		} if
   dup 8 eq { pop left-x-just lower-y-just	 	} if
   moveto show
} def
%
% Marker definitions
/mark0 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath fill} def
/mark1 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto
size size add 0 rlineto 0 size size add rlineto
0 size size add sub 0 rlineto closepath stroke} def
/mark2 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc stroke} def
/mark3 {/size exch def /y exch def /x exch def
newpath x size sub y size sub moveto x size add y size add lineto
x size sub y size add moveto x size add y size sub lineto stroke} def
/mark4 {/size exch def /y exch def /x exch def
newpath x size sub y moveto x y size add lineto
x size add y lineto x y size sub lineto
closepath stroke} def
/mark5 {/size exch def /y exch def /x exch def
x y size mark1
newpath x size sub y moveto size size add 0 rlineto stroke} def
/mark6 {/size exch def /y exch def /x exch def
newpath x y moveto x y size 0 360 arc fill} def
/mark7 {/size exch def /y exch def /x exch def
newpath x y moveto x size sub y size sub lineto
x size add y size sub lineto closepath fill
newpath x y moveto x size add y size add lineto
x size sub y size add lineto closepath fill} def
%
% Main body begins here
%
300 /Times-Bold choose-font
() 4488 7360 3 just-string
200 /Times-Roman choose-font
() 7106 6608 2 just-string
() 7106 6316 2 just-string
() 7106 6024 2 just-string
() 7106 5732 2 just-string
() 7106 5440 2 just-string
() 7106 5148 2 just-string
() 7106 4856 2 just-string
() 7106 4564 2 just-string
() 7106 4272 2 just-string
() 7106 3980 2 just-string
() 7106 3688 2 just-string
() 7106 3396 2 just-string
() 7106 3104 2 just-string
() 7106 2812 2 just-string
() 7106 2520 2 just-string
() 7106 2228 2 just-string
() 7106 1936 2 just-string
() 7106 1644 2 just-string
() 7106 1352 2 just-string
() 7106 1060 2 just-string
() 7106 768 2 just-string
14 setlinewidth
[] 0 setdash
(Percent utilized) 560 6800 2 just-string
(Number of clients) 7106 380 1 just-string
(    0) 860 663 5 just-string
(   10) 860 1230 5 just-string
(   20) 860 1796 5 just-string
(   30) 860 2362 5 just-string
(   40) 860 2929 5 just-string
(   50) 860 3495 5 just-string
(   60) 860 4061 5 just-string
(   70) 860 4628 5 just-string
(   80) 860 5194 5 just-string
(   90) 860 5760 5 just-string
(  100) 860 6327 5 just-string
(    0) 1226 90 7 just-string
(    2) 2329 90 7 just-string
(    4) 3432 90 7 just-string
(    6) 4534 90 7 just-string
(    8) 5637 90 7 just-string
(   10) 6740 90 7 just-string
[] 0 setdash
8 setlinewidth
newpath
  950 663 moveto
  1225 663 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1230 moveto
  1225 1230 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 1796 moveto
  1225 1796 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2362 moveto
  1225 2362 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 2929 moveto
  1225 2929 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 3495 moveto
  1225 3495 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4061 moveto
  1225 4061 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 4628 moveto
  1225 4628 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5194 moveto
  1225 5194 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 5760 moveto
  1225 5760 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  950 6327 moveto
  1225 6327 lineto
stroke
[] 0 setdash
8 setlinewidth
newpath
  1226 663 moveto
  1226 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  2329 663 moveto
  2329 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  3432 663 moveto
  3432 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  4534 663 moveto
  4534 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  5637 663 moveto
  5637 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  6740 663 moveto
  6740 380 lineto
stroke
[] 0 setdash
2 setlinewidth
newpath
  1225 6327 moveto
  1225 663 lineto
  6740 663 lineto
  6740 6327 lineto
  1225 6327 lineto
stroke
8 setlinewidth 1777 3105 24 mark0
1777 3105 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  1777 3105 moveto
  1777 3105 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3036 24 mark0
1777 3036 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  1777 3036 moveto
  1777 3036 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3095 24 mark0
1777 3095 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  1777 3095 moveto
  1777 3095 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3367 24 mark0
1777 3367 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  1777 3367 moveto
  1777 3367 lineto
stroke
[] 0 setdash 8 setlinewidth 1777 3198 24 mark0
1777 3198 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  1777 3198 moveto
  1777 3198 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3644 24 mark0
6740 3644 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  6740 3644 moveto
  6740 3644 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3463 24 mark0
6740 3463 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6740 3463 moveto
  6740 3463 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3408 24 mark0
6740 3408 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6740 3408 moveto
  6740 3408 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3479 24 mark0
6740 3479 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6740 3479 moveto
  6740 3479 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3484 24 mark0
6740 3484 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6740 3484 moveto
  6740 3484 lineto
stroke
[] 0 setdash 8 setlinewidth 6740 3557 24 mark0
6740 3557 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  6740 3557 moveto
  6740 3557 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 2998 24 mark0
2329 2998 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2329 2998 moveto
  2329 2998 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3110 24 mark0
2329 3110 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2329 3110 moveto
  2329 3110 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3372 24 mark0
2329 3372 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  2329 3372 moveto
  2329 3372 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3057 24 mark0
2329 3057 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  2329 3057 moveto
  2329 3057 lineto
stroke
[] 0 setdash 8 setlinewidth 2329 3190 24 mark0
2329 3190 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  2329 3190 moveto
  2329 3190 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3247 24 mark0
2880 3247 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  2880 3247 moveto
  2880 3247 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3258 24 mark0
2880 3258 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  2880 3258 moveto
  2880 3258 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3167 24 mark0
2880 3167 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  2880 3167 moveto
  2880 3167 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3116 24 mark0
2880 3116 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  2880 3116 moveto
  2880 3116 lineto
stroke
[] 0 setdash 8 setlinewidth 2880 3570 24 mark0
2880 3570 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  2880 3570 moveto
  2880 3570 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3405 24 mark0
3432 3405 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3432 3405 moveto
  3432 3405 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3430 24 mark0
3432 3430 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3432 3430 moveto
  3432 3430 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3293 24 mark0
3432 3293 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  3432 3293 moveto
  3432 3293 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3428 24 mark0
3432 3428 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  3432 3428 moveto
  3432 3428 lineto
stroke
[] 0 setdash 8 setlinewidth 3432 3338 24 mark0
3432 3338 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  3432 3338 moveto
  3432 3338 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3482 24 mark0
3983 3482 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  3983 3482 moveto
  3983 3482 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3487 24 mark0
3983 3487 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  3983 3487 moveto
  3983 3487 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3425 24 mark0
3983 3425 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  3983 3425 moveto
  3983 3425 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3275 24 mark0
3983 3275 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  3983 3275 moveto
  3983 3275 lineto
stroke
[] 0 setdash 8 setlinewidth 3983 3473 24 mark0
3983 3473 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  3983 3473 moveto
  3983 3473 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3172 24 mark0
4534 3172 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  4534 3172 moveto
  4534 3172 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3129 24 mark0
4534 3129 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  4534 3129 moveto
  4534 3129 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3240 24 mark0
4534 3240 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  4534 3240 moveto
  4534 3240 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3282 24 mark0
4534 3282 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  4534 3282 moveto
  4534 3282 lineto
stroke
[] 0 setdash 8 setlinewidth 4534 3183 24 mark0
4534 3183 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  4534 3183 moveto
  4534 3183 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3463 24 mark0
5086 3463 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5086 3463 moveto
  5086 3463 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3413 24 mark0
5086 3413 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5086 3413 moveto
  5086 3413 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3399 24 mark0
5086 3399 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  5086 3399 moveto
  5086 3399 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3258 24 mark0
5086 3258 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  5086 3258 moveto
  5086 3258 lineto
stroke
[] 0 setdash 8 setlinewidth 5086 3420 24 mark0
5086 3420 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  5086 3420 moveto
  5086 3420 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3255 24 mark0
5637 3255 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  5637 3255 moveto
  5637 3255 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3225 24 mark0
5637 3225 24 mark0
14 setlinewidth
[60 60 ] 0 setdash
newpath
  5637 3225 moveto
  5637 3225 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3230 24 mark0
5637 3230 24 mark0
14 setlinewidth
[15 15 15 45 ] 0 setdash
newpath
  5637 3230 moveto
  5637 3230 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3317 24 mark0
5637 3317 24 mark0
14 setlinewidth
[45 15 ] 0 setdash
newpath
  5637 3317 moveto
  5637 3317 lineto
stroke
[] 0 setdash 8 setlinewidth 5637 3297 24 mark0
5637 3297 24 mark0
14 setlinewidth
[120 120 ] 0 setdash
newpath
  5637 3297 moveto
  5637 3297 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3412 24 mark0
6189 3412 24 mark0
14 setlinewidth
[30 30 60 0 ] 0 setdash
newpath
  6189 3412 moveto
  6189 3412 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3423 24 mark0
6189 3423 24 mark0
14 setlinewidth
[30 30 45 45 ] 0 setdash
newpath
  6189 3423 moveto
  6189 3423 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3359 24 mark0
6189 3359 24 mark0
14 setlinewidth
[] 0 setdash
newpath
  6189 3359 moveto
  6189 3359 lineto
stroke
[] 0 setdash 8 setlinewidth 6189 3375 24 mark0
6189 3375 24 mark0
14 setlinewidth
[30 30 ] 0 setdash
newpath
  6189 3375 moveto
  6189 3375 lineto
stroke
% End of xgraph output

%%EndDocument
FMENDEPSF
72 425.25 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "95" 107
%%Page: "96" 107
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(96) 318 55 T
1 11 Q
0.31 ( The latency experienced by a client opening and closing a \336le on a server with a recovery box) 118.8 420.67 P
0.06 (includes twice the cost of a recovery box insert/delete operation, along with the corresponding \336le) 108 407.67 P
1.14 (system bookkeeping code, because each \336le open/close pair requires inserting and deleting two) 108 394.67 P
1.01 (items in the recovery box: an I/O handle and a stream. The extra latency for remote open/close) 108 381.67 P
0.17 (pairs from the client\325) 108 368.67 P
0.17 (s view is 166 microseconds on top of 3450 microseconds, or a little less than) 200.37 368.67 P
-0.19 (\336ve percent extra latency) 108 355.67 P
-0.19 (. W) 217.44 355.67 P
-0.19 (rite protection adds eight microseconds \050two microseconds for each of) 232.67 355.67 P
0.92 (the four recovery box updates\051 bringing the cost to 174 microseconds) 108 342.67 P
3 F
0.92 (-) 425.95 342.67 P
1 F
0.92 ( almost exactly an extra) 431.98 342.67 P
(\336ve percent latency) 108 329.67 T
(.) 193.32 329.67 T
1.5 (While the recovery box adds a \336ve percent latency to the open/close times seen by a client) 118.8 304.67 P
0.88 (workstation, the ef) 108 291.67 P
0.88 (fect on \336le server throughput is not as lar) 191.64 291.67 P
0.88 (ge. On average, the main Sprite \336le) 379.11 291.67 P
-0.16 (server for 40 clients receives two \336le open/close pairs per second. The current recovery box imple-) 108 278.67 P
0.85 (mentation thus adds, on average, an extra 332 microseconds of server processing per second, or) 108 265.67 P
1.57 (less than a 0.1% increase in processing demand at the server) 108 252.67 P
1.57 (. However) 388.24 252.67 P
1.57 (, \336le system activity is) 435.13 252.67 P
-0.01 (bursty) 108 239.67 P
-0.01 (, and the server sometimes sees as many as 50 \336le open/close pairs in a second. During peak) 134.75 239.67 P
0.57 (activity) 108 226.67 P
0.57 (, the recovery box would thus add 8.3 milliseconds of server processing per second, for a) 140.24 226.67 P
0.57 (potential 0.8% reduction in server throughput. W) 108 213.67 P
0.57 (ith write-protection, this comes to about a 0.9%) 327 213.67 P
0.04 (reduction in server throughput. I believe this means the recovery box overhead is acceptable, even) 108 200.67 P
0.56 (in a high performance system. And if we were able to eliminate much of the overhead in the \336le) 108 187.67 P
0.43 (system bookkeeping code on the \336le server) 108 174.67 P
0.43 (, then the increase in latency seen by the clients could) 299.9 174.67 P
(be cut in half.) 108 161.67 T
0 14 Q
(5.5. Disadvantages of T) 108 128.67 T
(ranspar) 245.73 128.67 T
(ent Recovery) 292.89 128.67 T
1 11 Q
1.07 ( This section lists some of the disadvantages of transparent recovery and dif) 118.8 102.67 P
1.07 (\336culties with the) 464.62 102.67 P
1.04 (recovery box. There are three main problems. First, transparent recovery requires more special-) 108 89.67 P
108 81 540 720 C
110.01 428 537.99 720 C
108.51 435 536.51 713 R
7 X
0 K
V
1 11 Q
0 X
(T) 191.43 548.67 T
(able 5-6. T) 197.38 548.67 T
(ransparent recovery time and component times.) 244.89 548.67 T
1 10 Q
0.02 (This table gives the time in seconds for dif) 144.51 524.33 P
0.02 (ferent steps of distributed cache state recovery) 314.97 524.33 P
0.62 (for the server using a recovery box in the testbed setup. Only 0.08 seconds are actually) 144.51 513.33 P
0.03 (spent retrieving information from the recovery box. The rest of the time is spent building) 144.51 502.33 P
0.26 (the server) 144.51 491.33 P
0.26 (\325) 184.27 491.33 P
0.26 (s main memory data structures, including a hash table of handles. Most of the) 187.05 491.33 P
-0.25 (time is spent recovering I/O handle information, since this requires disk I/O operations on) 144.51 480.33 P
1.07 (the \336le server) 144.51 469.33 P
1.07 (. The test was run six times. The results do not quite add to 1.47 due to) 200.5 469.33 P
110.01 437 536.51 455 C
108.51 437 536.51 455 R
7 X
0 K
V
108.51 446 540.51 446 2 L
V
0.5 H
2 Z
0 X
N
110.01 428 537.99 720 C
1 10 Q
0 X
0 K
(rounding errors.) 144.51 458.33 T
(Operation) 219.53 673.33 T
(Seconds) 328.95 673.33 T
(Standard deviation) 391 673.33 T
(Item retrieval from recovery box) 170.91 655.33 T
(0.08) 357.62 655.33 T
(0.007) 451.62 655.33 T
(Hash table creation) 170.91 637.33 T
(0.08) 357.62 637.33 T
(0.007) 451.62 637.33 T
(I/O handle recovery) 170.91 619.33 T
(1.20) 357.62 619.33 T
(0.040) 451.62 619.33 T
(Stream handle recovery) 170.91 601.33 T
(0.10) 357.62 601.33 T
(0.007) 451.62 601.33 T
(T) 170.91 583.33 T
(otal) 176.32 583.33 T
(1.47) 357.62 583.33 T
(0.044) 451.62 583.33 T
166.91 683 166.91 577 2 L
V
2 H
0 Z
N
312.11 685 312.11 575 2 L
V
N
379.11 685 379.11 575 2 L
V
0.5 H
N
478.11 683 478.11 577 2 L
V
2 H
N
165.91 684 479.11 684 2 L
V
N
167.91 667.25 477.11 667.25 2 L
V
0.5 H
N
167.91 664.75 477.11 664.75 2 L
V
N
165.91 648 479.11 648 2 L
V
N
165.91 630 479.11 630 2 L
V
N
165.91 612 479.11 612 2 L
V
N
167.91 595.25 477.11 595.25 2 L
V
N
167.91 592.75 477.11 592.75 2 L
V
N
165.91 576 479.11 576 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "96" 108
%%Page: "97" 108
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(97) 282 55 T
1 11 Q
1 (purpose code on the server than the other recovery techniques. Second, it requires more careful) 72 287.67 P
-0.18 (bookkeeping to avoid inconsistencies between the clients and the server) 72 274.67 P
-0.18 (. Third, the recovery box is) 385.59 274.67 P
0.22 (dif) 72 261.67 P
0.22 (\336cult to incorporate into a system in which operations that change the \336le system state, such as) 84.01 261.67 P
0 (opens and closes, are hard to isolate or handle atomically) 72 248.67 P
0 (. Another issue is what to do if the recov-) 322.12 248.67 P
-0.01 (ery box is corrupted. For extra robustness, a system may need to use client-driven or server) 72 235.67 P
-0.01 (-driven) 472.27 235.67 P
1.01 (recovery as a backup recovery technique. Finally) 72 222.67 P
1.01 (, this section also discusses two possible prob-) 293.06 222.67 P
(lems with implementing the recovery box: uncooperative hardware and power failures.) 72 209.67 T
-0.2 (Unfortunately) 82.8 184.67 P
-0.2 (, transparent recovery requires a signi\336cant amount of special-purpose code on the) 143.72 184.67 P
1.2 (\336le server) 72 171.67 P
1.2 (. The recovery box implementation takes 1475 lines of C code. The \336le system layer) 116.22 171.67 P
1.11 (above the recovery box \050for maintaining the hash table, and for logging directory operations as) 72 158.67 P
0.67 (described in the next section\051 takes about 2700 lines. Finally) 72 145.67 P
0.67 (, there is code executed only during) 343.44 145.67 P
0.7 (recovery for each type of I/O handle: 130 lines for \336les, 40 for pipes, 65 for devices, and 40 for) 72 132.67 P
0.04 (pseudo-devices. This gives us 4450 total extra lines. These numbers include all testing and debug-) 72 119.67 P
(ging code, and about one quarter of the lines are comments.) 72 106.67 T
72 81 504 720 C
73 295 503 720 C
73 302 505 713 R
7 X
0 K
V
1 11 Q
0 X
(T) 191.61 428.67 T
(able 5-7. Sprite recovery box performance.) 197.55 428.67 T
1 10 Q
-0 (The \336rst two rows give the time to insert and delete a \336le handle item in the recovery box,) 109 404.33 P
-0.15 (with and without a checksum. The second two rows give the time to insert and delete a \336le) 109 393.33 P
0.85 (handle, including the extra overhead in the \336le system \050) 109 382.33 P
2 F
0.85 (FS) 338.74 382.33 P
1 F
0.85 (\051 bookkeeping code. The last) 349.84 382.33 P
0.83 (two rows give the time to execute a \336le open/close operation from a client workstation,) 109 371.33 P
0.24 (with and without a recovery box running on the \336le server) 109 360.33 P
0.24 (. This time includes the kernel-) 343.45 360.33 P
0.24 (to-kernel remote procedure calls between the client and \336le server) 109 349.33 P
0.24 (. The last row gives the) 374.54 349.33 P
0.21 (number of microseconds to add to the other results when using hardware write-protection) 109 338.33 P
73 306 503 324 C
73 306 505 324 R
7 X
0 K
V
73 315 505 315 2 L
V
0.5 H
2 Z
0 X
N
73 295 503 720 C
1 10 Q
0 X
0 K
(of the recovery box pages. Each result is the average of 50,000 operations.) 109 327.33 T
(Operation) 203.02 673.33 T
(A) 290.25 673.33 T
(verage time \050microseconds\051) 296.73 673.33 T
(Recovery box insert/delete) 167 655.33 T
(with checksum) 167 643.33 T
(28) 401.01 655.33 T
(Recovery box insert/delete) 167 625.33 T
(with no checksum) 167 613.33 T
(24) 401.01 625.33 T
(FS insert/delete with check-) 167 595.33 T
(sum) 167 583.33 T
(73) 401.01 595.33 T
(FS insert/delete with no) 167 565.33 T
(checksum) 167 553.33 T
(72) 401.01 565.33 T
(Open/close with recovery) 167 535.33 T
(box) 167 523.33 T
(3616) 391.01 535.33 T
(Open/close without recov-) 167 505.33 T
(ery box) 167 493.33 T
(3450) 391.01 505.33 T
(Added cost of write-protec-) 167 475.33 T
(tion) 167 463.33 T
(8) 406 475.33 T
163 683 163 457 2 L
V
2 H
0 Z
N
283 685 283 455 2 L
V
N
415 683 415 457 2 L
V
N
162 684 416 684 2 L
V
N
164 667.25 414 667.25 2 L
V
0.5 H
N
164 664.75 414 664.75 2 L
V
N
162 636 416 636 2 L
V
N
164 607.25 414 607.25 2 L
V
N
164 604.75 414 604.75 2 L
V
N
162 576 416 576 2 L
V
N
164 547.25 414 547.25 2 L
V
N
164 544.75 414 544.75 2 L
V
N
162 516 416 516 2 L
V
N
164 487.25 414 487.25 2 L
V
N
164 484.75 414 484.75 2 L
V
N
162 456 416 456 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "97" 109
%%Page: "98" 109
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(98) 318 55 T
1 11 Q
0.63 (The less code a system executes speci\336cally during recovery) 118.8 712.67 P
0.63 (, the less likely recovery is to fail) 389.76 712.67 P
0.52 (due to bugs. From this point of view transparent recovery does not fair too badly) 108 699.67 P
0.52 (, since only 615) 468.86 699.67 P
0.9 (lines of the 4450 are executed only during recovery) 108 686.67 P
0.9 (. The rest of the code is used during normal) 340.88 686.67 P
0.2 (processing to maintain the distributed state in the recovery box. One good feature is that transpar-) 108 673.67 P
-0.04 (ent recovery requires less special-purpose code on the clients, since they do not need to participate) 108 660.67 P
(in recovery) 108 647.67 T
(.) 157.01 647.67 T
0.74 (A second problem with transparent recovery is that it requires more careful bookkeeping than) 118.8 622.67 P
-0.03 (the communication-based techniques, particularly with reference counts. An example of this prob-) 108 609.67 P
-0.13 (lem concerns close RPC requests that hang waiting for a \336le server to recover) 108 596.67 P
-0.13 (. In Sprite, users may) 447.14 596.67 P
-0.11 (terminate the hung operation at a high level on their workstations. This is convenient if a user does) 108 583.67 P
-0.04 (not want the request to hang until the server reboots, but it should be disallowed when using trans-) 108 570.67 P
0.35 (parent recovery) 108 557.67 P
0.35 (. A successful close request decrements the reference count on a \336le. A \336le server) 176.27 557.67 P
-0.08 (may crash after decrementing this reference count in the recovery box but before it responds to the) 108 544.67 P
0.31 (client. In this case the client\325) 108 531.67 P
0.31 (s state information becomes inconsistent with the server) 235.28 531.67 P
0.31 (\325) 484.13 531.67 P
0.31 (s. This does) 487.19 531.67 P
0.22 (not matter with server) 108 518.67 P
0.22 (-driven or client-driven recovery) 205.16 518.67 P
0.22 (, since the server does not preserve its state) 348.79 518.67 P
1.29 (information across failures. After server) 108 505.67 P
1.29 (-driven or client-driven recovery) 288.99 505.67 P
1.29 (, the server) 435.86 505.67 P
1.29 (\325) 487.36 505.67 P
1.29 (s state will) 490.41 505.67 P
0.1 (match the clients\325 state, because the server simply uses the clients\325 state information. But in trans-) 108 492.67 P
0.25 (parent recovery) 108 479.67 P
0.25 (, the clients and the server have no natural opportunity to resynchronize their state) 176.16 479.67 P
0.44 (information. The solution to this problem is to disallow termination of RPCs that modify the dis-) 108 466.67 P
(tributed cache or \336le system state information.) 108 453.67 T
-0.25 (Additionally) 118.8 428.67 P
-0.25 (, these RPCs must be idempotent: when retried by the client, the server must be able) 173.63 428.67 P
-0.18 (to detect whether it has already modi\336ed the reference count. One way to implement this is to keep) 108 415.67 P
(a log in the recovery box of the status of outstanding RPCs, but I have not implemented this.) 108 402.67 T
0.67 (A third problem with transparent recovery is the dif) 118.8 377.67 P
0.67 (\336culty of incorporating it into \336le systems) 351.01 377.67 P
0.24 (that were not designed for it from the beginning. In Sprite, the most dif) 108 364.67 P
0.24 (\336cult aspect of incorporat-) 423.04 364.67 P
-0.09 (ing the recovery box was isolating the locations in the code where the Sprite server updates its dis-) 108 351.67 P
-0.05 (tributed cache state information. The \336le server processes all \336le open and close operations, which) 108 338.67 P
0.8 (makes it theoretically possible to \336nd all the distributed cache state changes. However) 108 325.67 P
0.8 (, isolating) 495.86 325.67 P
0.88 (the important changes proved dif) 108 312.67 P
0.88 (\336cult. This is because the changes are not well-con\336ned, much) 256.56 312.67 P
-0.02 (less atomic. For example, a Sprite \336le server processes an open request in several steps, \336rst trans-) 108 299.67 P
0.04 (lating the name of the \336le to its descriptor) 108 286.67 P
0.04 (, then updating or creating an I/O handle for the \336le, and) 291.55 286.67 P
0.84 (only at the end creating the open stream handle for the \336le. A \336le is not of) 108 273.67 P
0.84 (\336cially open until all) 446.22 273.67 P
0.79 (steps are complete, and the server executes all these steps before responding to the client. How-) 108 260.67 P
0.94 (ever) 108 247.67 P
0.94 (, there can be an error during any step, making it necessary to back out of all the steps and) 126.47 247.67 P
-0.22 (undo all associated changes to the recovery box. T) 108 234.67 P
-0.22 (wo of these steps require updates to.the recovery) 327.33 234.67 P
0.7 (box \050modifying the \336le I/O handle and creating the stream handle\051, so we must undo changes in) 108 221.67 P
0.5 (the recovery box as well. Unfortunately) 108 208.67 P
0.5 (, this problem is likely to be present in many \336le systems) 284.29 208.67 P
-0.14 (that were not designed from the beginning to have atomic, or at least well-con\336ned, state changes.) 108 195.67 P
0.54 (A fourth potential problem involves a trade-of) 118.8 170.67 P
0.54 (f between robustness and complexity) 325.04 170.67 P
0.54 (. Switching) 489.41 170.67 P
1.27 (to transparent recovery does not necessarily mean we should leave out a communication-based) 108 157.67 P
0.28 (recovery technique, such as client-driven or server) 108 144.67 P
0.28 (-driven recovery) 331.24 144.67 P
0.28 (. Although the failure statistics) 403.7 144.67 P
0.25 (included in this chapter indicate that recovery box corruption is unlikely) 108 131.67 P
0.25 (, and even though we can) 427.1 131.67 P
-0.1 (write-protect the recovery box, it is still possible to lose the recovery box contents. If this happens,) 108 118.67 P
0.3 (we could recovery the system by retrieving the \336le system state information from the clients with) 108 105.67 P
0.04 (client-driven or server) 108 92.67 P
0.04 (-driven recovery) 205.48 92.67 P
0.04 (. However) 277.7 92.67 P
0.04 (, this makes the system more complex, because it) 323.06 92.67 P
FMENDPAGE
%%EndPage: "98" 110
%%Page: "99" 110
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(99) 282 55 T
1 11 Q
0.71 (requires implementing two types of recovery) 72 712.67 P
0.71 (. For simplicity) 272.23 712.67 P
0.71 (, we could instead just reboot all the) 340.38 712.67 P
-0.2 (clients to restart the system. This would disrupt many users, but it should only be necessary on rare) 72 699.67 P
(occasions.) 72 686.67 T
0.07 (Although implementing two forms of recovery is complex, it is worth mentioning that this two-) 82.8 661.67 P
0.13 (tier recovery mechanism is much less complicated than systems using error) 72 648.67 P
0.13 (-repair and other high-) 404.46 648.67 P
0.06 (availability techniques described in chapter 2. If any part of transparent recovery fails, we can just) 72 635.67 P
0.09 (back out to client-driven or server) 72 622.67 P
0.09 (-driven recovery) 221.42 622.67 P
0.09 (, and we need not try any intermediate recovery) 293.7 622.67 P
(techniques.) 72 609.67 T
0.04 (Memory corruption in the recovery box is not the only reason we may need to back out to some) 82.8 584.67 P
0.63 (other form of recovery or system reboot. Another reason is that the contents of the recovery box) 72 571.67 P
-0.21 (could be logically incorrect. This can occur if the same incorrect object that caused the system fail-) 72 558.67 P
0.57 (ure was also copied into the recovery box. This is an example of error propagation. If an item in) 72 545.67 P
0.61 (the recovery box is wrong, the system may fail soon after it retrieves the item from the recovery) 72 532.67 P
0.44 (box. Thus, the system should back out to another form of recovery \050or at least indicate that a full) 72 519.67 P
0.75 (system restart is necessary\051 if any failure occurs within some period of time after recovery from) 72 506.67 P
0.6 (the recovery box. So far) 72 493.67 P
0.6 (, though, I have no data to suggest what this period of time should be or) 179.82 493.67 P
(how much it will vary across systems.) 72 480.67 T
0.45 (Finally) 82.8 455.67 P
0.45 (, there are a couple of reasons why the recovery box itself may be impractical to imple-) 113.22 455.67 P
0.21 (ment on some architectures and in some environments. The \336rst problem is power failures. While) 72 442.67 P
0.68 (our department rarely suf) 72 429.67 P
0.68 (fers from power failures, this is not true in many geographical areas. If) 185.21 429.67 P
0.84 (the recovery box is stored in the server) 72 416.67 P
0.84 (\325) 248.84 416.67 P
0.84 (s volatile main memory) 251.89 416.67 P
0.84 (, the contents will be lost after a) 357.76 416.67 P
0.36 (power failure. One solution is to use a half-megabyte or so of non-volatile RAM for the recovery) 72 403.67 P
-0.25 (box. This is less costly than an uninterruptable power supply [Baker92b]. However) 72 390.67 P
-0.25 (, our experience) 434.04 390.67 P
-0.16 (has been that the client workstations also lose power during a power failure. In this case, there\325) 72 377.67 P
-0.16 (s no) 486.16 377.67 P
0.74 (point in preserving their state on the server across the failure, because they must all be rebooted) 72 364.67 P
0.86 (from scratch anyway) 72 351.67 P
0.86 (. So we have found little need to use non-volatile memory for the recovery) 165.13 351.67 P
(box.) 72 338.67 T
0.91 (The second problem is that the boot PROMs of some machines modify or clear memory) 82.8 313.67 P
0.91 (. For) 482.34 313.67 P
0.69 (example, the memory check initiated by the boot PROM of the MicroV) 72 300.67 P
0.69 (ax 3500 modi\336es a word) 392.62 300.67 P
0.43 (for every 1024 words in memory [Johnso93]. If it is not possible to turn of) 72 287.67 P
0.43 (f such activities as the) 405.25 287.67 P
0.22 (memory check, it may be impossible to \336nd a lar) 72 274.67 P
0.22 (ge enough area of physical memory that remains) 288.59 274.67 P
0.38 (unmodi\336ed by the boot PROM. In this case, the recovery box cannot be implemented in contigu-) 72 261.67 P
(ous physical memory and non-contiguous memory layout complicates the implementation.) 72 248.67 T
0 14 Q
(5.6. File System T) 72 215.67 T
(r) 177.07 215.67 T
(ends and Their Implications) 183.03 215.67 T
1 11 Q
0.16 (This section turns to a couple of trends in distributed \336le systems, and their ef) 82.8 189.67 P
0.16 (fect on the recov-) 426.33 189.67 P
-0.25 (ery box. There is a trend toward more asynchronous \336le system operations and towards stateful \336le) 72 176.67 P
0.65 (servers. Both of these trends make the recovery box more attractive, but also lead to some prob-) 72 163.67 P
(lems with the recovery box.) 72 150.67 T
FMENDPAGE
%%EndPage: "99" 111
%%Page: "100" 111
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(100) 315.01 55 T
0 F
(5.6.1. Logging Asynchr) 108 712 T
(onous Dir) 226.06 712 T
(ectory Operations) 276.16 712 T
1 11 Q
0.65 (For higher performance, new \336le systems tend to use more non-blocking asynchronous opera-) 118.8 686.67 P
0.91 (tions than their predecessors. Applications need not wait for these operations to complete, since) 108 673.67 P
0.73 (they can be handled in background. But if such an operation modi\336es the distributed \336le system) 108 660.67 P
0.23 (state, its asynchronous properties make bookkeeping more dif) 108 647.67 P
0.23 (\336cult. However) 381.59 647.67 P
0.23 (, it is possible to use) 449.73 647.67 P
(the recovery box to handle this bookkeeping problem.) 108 634.67 T
-0.19 (Examples of such asynchronous operations in Sprite are directory modi\336cations. In Sprite, oper-) 118.8 609.67 P
2.37 (ations such as \336le creation and deletion are executed asynchronously on the \336le server) 108 596.67 P
2.37 (. For) 516.87 596.67 P
0.34 (instance, when the server gets a request for a \336le creation from a client workstation, it updates its) 108 583.67 P
0.81 (main memory data structures and responds to the client indicating that the \336le has been created,) 108 570.67 P
0.64 (but only queues the disk write to be handled later) 108 557.67 P
0.64 (. The client assumes the \336le was created, but it) 329.5 557.67 P
1.55 (may be 30 seconds before server actually creates the \336le on disk. Non-blocking asynchronous) 108 544.67 P
0.93 (directory operations make many applications faster) 108 531.67 P
0.93 (, because these applications create temporary) 337.06 531.67 P
0.47 (\336les to hold intermediate results, and they delete the \336les soon afterwards. Handling these opera-) 108 518.67 P
0.41 (tions synchronously would require applications to wait for the operations to complete, tying their) 108 505.67 P
(performance to the speed of the disk.) 108 492.67 T
0.21 (The problem with asynchronous non-blocking directory operations is that Sprite clients and the) 118.8 467.67 P
1.52 (server can end up with dif) 108 454.67 P
1.52 (ferent directory state after a server crash. If the server crashes after) 229.82 454.67 P
-0.02 (responding to a client but before updating its disk to re\337ect the new state, a client may believe that) 108 441.67 P
0.79 (a \336le has been created while the server knows nothing about it. In client-driven or server) 108 428.67 P
0.79 (-driven) 508.27 428.67 P
0.57 (recovery) 108 415.67 P
0.57 (, the client and server communicate during recovery and have the opportunity to resolve) 145.72 415.67 P
-0.17 (the inconsistency) 108 402.67 P
-0.17 (. If the client attempts to reopen a \336le that the server does not \336nd on disk, the cli-) 183.09 402.67 P
-0.22 (ent will receive an error message \050although currently Sprite clients take no corrective action except) 108 389.67 P
-0.2 (to issue an error to the application program if it is still running\051. W) 108 376.67 P
-0.2 (ith transparent recovery) 398.45 376.67 P
-0.2 (, we lose) 501.66 376.67 P
-0.13 (even this opportunity to resolve the inconsistency during recovery) 108 363.67 P
-0.13 (. If a client created a \336le and still) 396.73 363.67 P
-0.15 (has it open, the server will \336nd an item in its recovery box for an open cached \336le, but it won\325) 108 350.67 P
-0.15 (t \336nd) 517.26 350.67 P
(this \336le on disk.) 108 337.67 T
0.52 (T) 118.8 312.67 P
0.52 (o solve this problem in transparent recovery) 124.74 312.67 P
0.52 (, we must record the directory operations \050create,) 320.63 312.67 P
0.41 (unlink, link, and rename\051 in some way) 108 299.67 P
0.41 (. I record them in the recovery box. The \336le server can log) 278.8 299.67 P
1.1 (\336le creation and deletion events at main memory speed in a section of the recovery box before) 108 286.67 P
0.68 (responding to the client. When the associated disk operations complete, the server removes their) 108 273.67 P
0.29 (log entries. The log in the recovery box is of \336xed length. If it becomes full, then the server emp-) 108 260.67 P
-0.07 (ties it by forcing to disk all the directory changes. The I/O is amortized across all of the changes in) 108 247.67 P
0.47 (the recovery box. Logging the directory change events does not signi\336cantly increase the latency) 108 234.67 P
-0.26 (of the clients\325 operations, and it allows the server to make its directory state on disk consistent with) 108 221.67 P
(the clients\325 views by processing the directory change log during crash recovery) 108 208.67 T
(.) 455.41 208.67 T
-0.22 (During recovery) 118.8 183.67 P
-0.22 (, the server processes the log by examining the directory events and checking its) 190.16 183.67 P
0.12 (disk to see if the \336le has actually been created or deleted as requested. This adds I/O operations to) 108 170.67 P
1.52 (recovery) 108 157.67 P
1.52 (, but not many) 145.72 157.67 P
1.52 (. On average, there are only three of these events pending on the main) 213.04 157.67 P
-0.09 (Sprite \336le server) 108 144.67 P
-0.09 (. In the worst case, each of these events would require checking the disk and mod-) 179.83 144.67 P
0.21 (ifying the disk to create or delete a \336le. This would be six I/O operations and would add, on aver-) 108 131.67 P
0.17 (age, 0.18 seconds to recover for 40 clients, assuming 30 milliseconds per I/O operation. Although) 108 118.67 P
0.1 (I have implemented recovery from this log in Sprite, it is not yet reliable enough for better perfor-) 108 105.67 P
(mance measurements. Unfortunately) 108 92.67 T
(, handling this log is complicated.) 268.69 92.67 T
FMENDPAGE
%%EndPage: "100" 112
%%Page: "101" 112
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(101) 279.01 55 T
0 F
(5.6.2. Stateful File Servers) 72 712 T
1 11 Q
-0.07 (Besides the trend towards asynchronous operations, recent \336le systems are increasingly stateful,) 82.8 686.67 P
-0.22 (and this too has implications for the recovery box. While NFS avoided maintaining state on the \336le) 72 673.67 P
1.43 (server in order to make crash recovery easier) 72 660.67 P
1.43 (, recent \336le systems such as DEcorum, Echo and) 278.96 660.67 P
1.61 (Sprite keep state information in order to increase performance, as described in chapter 2. The) 72 647.67 P
0.84 (closer information is kept to where it is processed, the faster the system runs, so it is likely that) 72 634.67 P
-0.12 (future \336le systems will also keep state on their servers. W) 72 621.67 P
-0.12 (ith more state kept on the \336le servers, the) 323.98 621.67 P
0.39 (recovery box becomes more attractive for preserving the state across failures. However) 72 608.67 P
0.39 (, the more) 458.99 608.67 P
0.7 (state that is maintained in the recovery box, the more likely some of it is to be wrong and cause) 72 595.67 P
-0.16 (error propagation problems. This is a trade-of) 72 582.67 P
-0.16 (f that will vary from system to system, so it is hard to) 271.28 582.67 P
(make generalizations about how much state should be kept in the recovery box.) 72 569.67 T
0 14 Q
(5.7. Applicability to Other Systems) 72 536.67 T
1 11 Q
0.6 (So far this chapter has primarily described how Sprite makes use of the recovery box, but this) 82.8 510.67 P
0.44 (section) 72 497.67 P
0.44 (addres) 106.31 497.67 P
0.44 (ses the requirements for other systems and user) 134.98 497.67 P
0.44 (-level applications that could use it.) 345.59 497.67 P
0.39 (Many client/server systems with state information that changes in response to client requests will) 72 484.67 P
(\336nd the recovery box useful.) 72 471.67 T
-0.22 (There are several requirements that must be met before a system will \336nd the recovery box prac-) 82.8 446.67 P
0.36 (tical. For instance, it must be possible to identify and isolate the changes to the state information.) 72 433.67 P
1.18 (As mentioned earlier) 72 420.67 P
1.18 (, this can be dif) 166.06 420.67 P
1.18 (\336cult in a pre-existing system where state changes may be) 238.01 420.67 P
1.29 (made incrementally and in several places. Also, there are four desired characteristics about the) 72 407.67 P
0.59 (type of state items the system stores in the recovery box. W) 72 394.67 P
0.59 (ithout these characteristics, magnetic) 339.9 394.67 P
0.2 (disk is likely to be a better form of stable storage. First, the items should be expensive to regener-) 72 381.67 P
1.46 (ate from scratch, or there\325) 72 368.67 P
1.46 (s no point in preserving them across failures. Second, the individual) 191.01 368.67 P
-0.12 (items should be small, so that the cost of copying them into the recovery box is not great. The total) 72 355.67 P
0.3 (size of the recovery box is also likely to be limited, so for example, copying all kernel data struc-) 72 342.67 P
0.5 (tures to it is probably a bad idea. Third, the items should be updated too frequently to be reason-) 72 329.67 P
0.22 (ably stored on disk. If they are rarely updated and the latency of a synchronous disk write is not a) 72 316.67 P
1.34 (problem, disk storage is preferable to the recovery box because it is simpler) 72 303.67 P
1.34 (. Fourth, the items) 419.72 303.67 P
(should be correct. This last requirement is the most dif) 72 290.67 T
(\336cult.) 311.64 290.67 T
0.01 (The items stored in the recovery box should be correct in order to avoid error propagation prob-) 82.8 265.67 P
0.06 (lem, as described on page 81. Ensuring that the items are correct is dif) 72 252.67 P
0.06 (\336cult and hard to generalize) 381.1 252.67 P
0.32 (across systems. This requires some experience with the system to know what types of state infor-) 72 239.67 P
0.42 (mation do not have a history of causing system failures. In Sprite, for example, I do not store the) 72 226.67 P
0.89 (internal \336le system locking information in the recovery box, because incorrect locking has been) 72 213.67 P
(the cause of many of our failures.) 72 200.67 T
0 14 Q
(5.8. Application Use of Recovery Box) 72 167.67 T
1 11 Q
0.9 (Up to this point, this chapter has mostly described the operating system\325) 82.8 141.67 P
0.9 (s use of the recovery) 409.48 141.67 P
-0.21 (box, but user) 72 128.67 P
-0.21 (-level applications can also use the recovery box to preserve state across failures. This) 128.42 128.67 P
0.22 (section describes how one application, an experimental version of the POSTGRES database man-) 72 115.67 P
(agement system \050DBMS\051 [Stoneb86], uses the recovery box.) 72 102.67 T
FMENDPAGE
%%EndPage: "101" 113
%%Page: "102" 113
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(102) 315.01 55 T
1 11 Q
1.89 (In this experimental version, written by Mark Sullivan [Baker92a], POSTGRES runs as an) 118.8 712.67 P
0.26 (application program on a Sprite \336le server and responds to requests from client programs running) 108 699.67 P
0.75 (on other Sprite machines. POSTGRES accesses the recovery box using the system call interface) 108 686.67 P
(described in section 5.2.1.) 108 673.67 T
0 12 Q
(5.8.1. How POSTGRES Uses the Recovery Box) 108 642 T
1 11 Q
1.26 (Recovery performance in the POSTGRES database management system is dominated by the) 118.8 616.67 P
-0.04 (cost of reinitializing the DBMS server) 108 603.67 P
-0.04 (\325) 276.36 603.67 P
-0.04 (s connections with clients. In a conventional database man-) 279.41 603.67 P
0.63 (agement system, recovery includes the cost of write-ahead log processing \050recovering disk state\051) 108 590.67 P
1.68 (in addition to client connection reestablishment. However) 108 577.67 P
1.68 (, POSTGRES has an unconventional) 371.84 577.67 P
0.49 (storage manager that maintains consistency of the data on disk without requiring write-ahead log) 108 564.67 P
(processing [Stoneb87], so it does not need the recovery box to avoid this costly recovery step.) 108 551.67 T
0.68 (W) 118.8 526.67 P
0.68 (ithout the recovery box, connection reestablishment is driven by the clients. When the data-) 128.73 526.67 P
0.76 (base manager fails, all transactions executing on behalf of clients are aborted and all connection) 108 513.67 P
0.19 (state held at the server is lost. Connection state includes such things as authentication information) 108 500.67 P
-0.03 (\050secret keys or authentication tokens\051, client addresses, packet sequence numbers, and any packets) 108 487.67 P
(queued at the DBMS.) 108 474.67 T
0.08 (When the server recovers, it must wait for the clients to detect that it has failed. After a connec-) 118.8 449.67 P
1.96 (tion times out, the client must reopen a connection with the DBMS and reauthenticate itself.) 108 436.67 P
1.09 (POSTGRES can establish and authenticate \050application-level\051 connections with only three mes-) 108 423.67 P
1.32 (sages, because it uses a sequenced packet protocol built on top of a datagram protocol \050UDP\051,) 108 410.67 P
1 (rather than a protocol based on streams \050TCP/IP\051. After establishing the connection, each client) 108 397.67 P
0.98 (must query the database to \336nd out if its last transaction committed. Then, it must resubmit the) 108 384.67 P
(transaction or take some other recovery action.) 108 371.67 T
0.68 (In the system with a recovery box, the DBMS stores authentication information and the client) 118.8 346.67 P
0.28 (address associated with each connection in a recovery box item. The DBMS also stores the trans-) 108 333.67 P
0.57 (action ID of the last transaction it was executing on behalf of each client. Every time the DBMS) 108 320.67 P
-0.27 (begins a new transaction, it updates the recovery box item with the new transaction ID. Storing this) 108 307.67 P
-0.14 (transaction ID on disk would be a bad idea, since POSTGRES is already disk bound for workloads) 108 294.67 P
(with high transaction rates.) 108 281.67 T
-0.27 (After a failure, the DBMS reinitializes its connection data structures from the backup data stored) 118.8 256.67 P
-0.23 (in the recovery box. Once the connections are reinitialized, the DBMS sends a message to each cli-) 108 243.67 P
-0.05 (ent indicating that recovery has occurred \050a new DBMS server ID is sent\051 and that a new sequence) 108 230.67 P
0.97 (number has been chosen by the DBMS. The restart message also indicates the status of the last) 108 217.67 P
0.57 (transaction that the DBMS executed on behalf of the client. If the message initiating the transac-) 108 204.67 P
0.91 (tion was lost in the failure, or if the transaction was aborted, the client must either resubmit the) 108 191.67 P
0.37 (transaction or take some other recovery action. Authentication of the client is reveri\336ed when the) 108 178.67 P
(DBMS receives the next message from the client.) 108 165.67 T
0.62 (POSTGRES does not use the recovery box to store any of the state associated with its storage) 118.8 140.67 P
0.94 (system. Storage system performance optimizations requiring non-volatile RAM are discussed in) 108 127.67 P
0.54 ([Stoneb87]; for example, to reduce commit latency) 108 114.67 P
0.54 (, committed data can be stored in non-volatile) 334.81 114.67 P
0.81 (RAM instead of on disk. But this technique requires the operating system to guarantee that data) 108 101.67 P
1.57 (stored in non-volatile memory be permanent. The recovery box does not make this guarantee,) 108 88.67 P
FMENDPAGE
%%EndPage: "102" 114
%%Page: "103" 114
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(103) 279.01 55 T
1 11 Q
0.89 (because if the system detects any errors during the fast recovery path, it will revert to the tradi-) 72 712.67 P
(tional recovery path and will discard the contents of the recovery box.) 72 699.67 T
0 12 Q
(5.8.2. POSTGRES Performance with the Recovery Box) 72 668 T
1 11 Q
0.79 (The most lengthy step for POSTGRES recovery is reinitializing the server) 82.8 642.67 P
0.79 (\325) 417.59 642.67 P
0.79 (s connections with) 420.64 642.67 P
1.28 (client applications. W) 72 629.67 P
1.28 (ithout the recovery box, POSTGRES clients discover failures using time-) 170.24 629.67 P
-0.04 (outs. After the time-out, each client must query the database to \336nd out whether its last transaction) 72 616.67 P
0.23 (committed. The time-out alone requires several seconds since it must allow for worst-case queue-) 72 603.67 P
0.14 (ing delays before assuming that the DBMS is down. Eliminating this communication by using the) 72 590.67 P
(recovery box is an easy way to \336x this problem.) 72 577.67 T
0.51 (T) 82.8 552.67 P
0.51 (o measure POSTGRES recovery times, Mark Sullivan ran a debit/credit benchmark based on) 88.74 552.67 P
1.24 (TP1 [Anonym88], but to expedite the measurements he used a much smaller database than the) 72 539.67 P
0.09 (actual TP1 benchmark requires. A single POSTGRES DBMS managed the database from a Sprite) 72 526.67 P
0.66 (\336le server) 72 513.67 P
0.66 (. T) 115.69 513.67 P
0.66 (en POSTGRES client processes running on a single Sprite client machine generated) 127.79 513.67 P
1.02 (the transactions. For the experiments, he used a version of the DBMS that was single-threaded.) 72 500.67 P
0.4 (While the DBMS executes a transaction for one client, transactions sent by the others are queued) 72 487.67 P
1.66 (in the DBMS address space. Single-threaded execution means that adding POSTGRES clients) 72 474.67 P
0.4 (increases recovery time \050due to client connections\051 without increasing the overall transaction rate) 72 461.67 P
(of the DBMS.) 72 448.67 T
0.58 (W) 82.8 423.67 P
0.58 (ith a fast reconnect protocol that relies on the recovery box, POSTGRES clients are noti\336ed) 92.73 423.67 P
3.21 (immediately of a DBMS failure and can resubmit lost transactions with a single message) 72 410.67 P
1.4 (exchange. The time to recover ten client connections using this protocol is less than a second.) 72 397.67 P
1.03 (Using the recovery box, total recovery time for POSTGRES and ten clients \050ignoring operating) 72 384.67 P
0.61 (system recovery time\051 is about six seconds. Most of this cost comes from reloading the database) 72 371.67 P
(code and system catalogs into main memory) 72 358.67 T
(.) 266.58 358.67 T
1.6 (Other systems have implemented client recovery with ad-hoc mechanisms involving several) 82.8 333.67 P
1.52 (message exchanges, queries of the database, and sometimes human intervention \050including the) 72 320.67 P
0.77 (original POSTGRES implementation\051. The times required by these mechanisms vary widely but) 72 307.67 P
(all are longer than a single message exchange per client.) 72 294.67 T
2.62 (Individual POSTGRES recovery box operations are slower than those for Sprite, because) 82.8 269.67 P
0.53 (POSTGRES must pay the overhead of system calls. T) 72 256.67 P
0.53 (able 5-8 shows the breakdown of times for) 312.61 256.67 P
0.28 (POSTGRES recovery box operations. POSTGRES updates a 92-byte item in the recovery box on) 72 243.67 P
1.72 (each transaction versus Sprite\325) 72 230.67 P
1.72 (s 52-byte items; the entire connection structure is updated even) 211.12 230.67 P
0.23 (though only the transaction ID changes. Because it is inserting lar) 72 217.67 P
0.23 (ger items into the recovery box,) 363.09 217.67 P
0.12 (the cost of copying data and computing checksums also increases. The operating system is able to) 72 204.67 P
0.3 (use an optimized checksum routine for \336le handles \050with an unrolled loop\051 while application pro-) 72 191.67 P
-0.17 (grams must use a generalized one. POSTGRES could compute and check its own checksums if the) 72 178.67 P
0.92 (dif) 72 165.67 P
0.92 (ference in performance were critical. However) 84.01 165.67 P
0.92 (, the measured cost of the recovery box opera-) 293.15 165.67 P
0.28 (tions is much smaller than the variance of POSTGRES transaction execution times, so there is no) 72 152.67 P
(reason to optimize checksum calculations further) 72 139.67 T
(.) 287.11 139.67 T
FMENDPAGE
%%EndPage: "103" 115
%%Page: "104" 115
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(104) 315.01 55 T
0 14 Q
(5.9. Summary) 108 441.7 T
1 11 Q
0.15 (While disk is the most common form of stable storage, it is not always a better storage medium) 118.8 415.7 P
0.27 (than main memory for frequently updated information. Systems designers commonly assume that) 108 402.7 P
0.2 (the contents of a disk are more reliable after a failure than the contents of memory) 108 389.7 P
0.2 (, but there is no) 471.17 389.7 P
0.25 (guarantee. W) 108 376.7 P
0.25 (ith suitable precautions, such as the checksum methods described in this chapter) 166.38 376.7 P
0.25 (, the) 520.83 376.7 P
0.21 (recovery box is an attractive form of stable storage for systems that are allowed to suf) 108 363.7 P
0.21 (fer an occa-) 487.74 363.7 P
(sional longer reboot.) 108 350.7 T
0.21 (T) 118.8 325.7 P
0.21 (ransparent recovery) 125.13 325.7 P
0.21 (, using the recovery box, is the fastest technique for recovering distributed) 211.55 325.7 P
-0.2 (state information in Sprite. It requires 1.47 seconds to recover the state for ten clients in the testbed) 108 312.7 P
0.69 (setup. The recovery box does not signi\336cantly degrade overall system performance, as it adds at) 108 299.7 P
(most a \336ve percent latency to remote open and close operations on client workstations.) 108 286.7 T
1.05 (The recovery box is useful for user) 118.8 261.7 P
1.05 (-level applications as well as the operating system kernel.) 278.65 261.7 P
-0.14 (State information suitable for storing in the recovery box should be expensive to regenerate, small,) 108 248.7 P
(updated too frequently to store on disk, and free from errors that would cause repeated failures.) 108 235.7 T
1.01 (The biggest problem for incorporating the recovery box into a pre-existing \336le system is that) 118.8 210.7 P
0.77 (may be hard to isolate the changes to the state information stored in the recovery box and make) 108 197.7 P
-0.22 (these changes atomic. This was true in Sprite. However) 108 184.7 P
-0.22 (, we can design future \336le systems with this) 349.86 184.7 P
(in mind: state recovery will be faster and easier if state changes are well-con\336ned.) 108 171.7 T
108 81 540 720 C
108.51 451.03 539.49 720 C
108.01 456 542.01 715 R
7 X
0 K
V
1 11 Q
0 X
(T) 213.27 545.67 T
(able 5-8. POSTGRES recovery box performance.) 219.21 545.67 T
1 10 Q
0.12 (This table shows a breakdown of the time required to update a POSTGRES client connec-) 144.01 521.33 P
-0.03 (tion in the recovery box, as measured by Mark Sullivan in the testbed setup. The \336rst three) 144.01 510.33 P
0.69 (entries give the major individual components of this cost) 144.01 499.33 P
3 F
0.69 (-) 379.81 499.33 P
1 F
0.69 ( system call overhead, check-) 385.3 499.33 P
0.31 (sum calculation, and copying costs. The results give the average across 100,000 measure-) 144.01 488.33 P
108.51 456 539.49 474 C
108.01 456 542.01 474 R
7 X
0 K
V
108.01 465 540.01 465 2 L
V
0.5 H
2 Z
0 X
N
108.51 451.03 539.49 720 C
1 10 Q
0 X
0 K
(ments.) 144.01 477.33 T
(Operation) 233.03 675.33 T
(A) 336.09 675.33 T
(verage time \050microseconds\051) 342.57 675.33 T
(System call overhead) 187.18 657.33 T
1 11 Q
(19) 337.64 656.67 T
1 10 Q
(Checksum 92 bytes) 187.18 638.33 T
1 11 Q
(10) 337.64 637.67 T
1 10 Q
(Copy 92 bytes) 187.18 619.33 T
1 11 Q
(8) 337.64 618.67 T
1 10 Q
(Other) 187.18 600.33 T
1 11 Q
(18) 337.64 599.67 T
1 10 Q
(T) 187.18 581.33 T
(otal for recovery box update) 192.59 581.33 T
1 11 Q
(55) 337.64 580.67 T
183.18 685 183.18 574 2 L
V
2 H
0 Z
N
322.84 687 322.84 572 2 L
V
N
466.84 685 466.84 574 2 L
V
N
182.18 686 467.84 686 2 L
V
N
184.18 669.25 465.84 669.25 2 L
V
0.5 H
N
184.18 666.75 465.84 666.75 2 L
V
N
182.18 649 467.84 649 2 L
V
N
182.18 630 467.84 630 2 L
V
N
182.18 611 467.84 611 2 L
V
N
184.18 593.25 465.84 593.25 2 L
V
N
184.18 590.75 465.84 590.75 2 L
V
N
182.18 573 467.84 573 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "104" 116
%%Page: "105" 116
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(105) 279.01 55 T
72 666 504 720 C
72 666 504 720 R
7 X
0 K
V
72 693 504 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
72 594 504 648 C
72 594 504 648 R
7 X
0 K
V
72 603 504 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(6) 108 638 T
0 18 Q
(Other Fast Reboot T) 144 654 T
(echniques) 301.74 654 T
1 11 Q
1.07 (The previous chapters describe how I reduced distributed state recovery in Sprite from many) 82.8 519.67 P
0.1 (minutes to a few seconds using server) 72 506.67 P
0.1 (-driven or transparent recovery) 238.97 506.67 P
0.1 (. However) 374.91 506.67 P
0.1 (, a \336le server exec-) 420.33 506.67 P
0.59 (tues several other steps during a reboot. This chapter turns to these other steps and gives mecha-) 72 493.67 P
0.3 (nisms for improving the time of each. Combining all these improvements, including those for \336le) 72 480.67 P
0.17 (system state recovery) 72 467.67 P
0.17 (, we have reduced the total time required for Sprite \336le server recovery from) 166.21 467.67 P
(45 minutes to under 29 seconds. This has improved overall \336le server availability) 72 454.67 T
(.) 429.22 454.67 T
1.24 (T) 82.8 429.67 P
1.24 (o reboot, a Sprite \336le server executes \336ve general steps. First, the server must reacquire an) 88.74 429.67 P
0.09 (image of the kernel code and data. Second, it runs start-up code to initialize its hardware and vari-) 72 416.67 P
0.16 (ous data structures. Third, it ensures that the \336le system is in a consistent state. Fourth, it recovers) 72 403.67 P
-0.07 (its distributed state information. Finally) 72 390.67 P
-0.07 (, it must start up various kernel and user) 245.27 390.67 P
-0.07 (-level daemon pro-) 420.55 390.67 P
0.24 (cesses to handle dif) 72 377.67 P
0.24 (ferent parts of its workload. The \336rst \336ve sections of this chapter \050sections 6.1) 158.25 377.67 P
1.16 (through 6.5\051 provide more details for each of these steps in turn. Section 6.6 lists some further) 72 364.67 P
(techniques for improving overall reboot times.) 72 351.67 T
2.29 (T) 82.8 326.67 P
2.29 (able 6-1 lists the \336ve reboot steps and gives the time for each, before and after various) 88.74 326.67 P
0.97 (improvements. The timings in the table come from the testbed setup described in chapter 3 and) 72 313.67 P
0.41 (have been scaled for 40 clients, except for the following three cases. First, the seven-second time) 72 300.67 P
0.1 (to download the kernel is taken from the production Sprite system. For reasons explained below) 72 287.67 P
0.1 (, I) 494.74 287.67 P
0.83 (could not take this measurement in the testbed setup. Second, the disk check and LFS times are) 72 274.67 P
-0.06 (also from the production Sprite system, since the testbed server has only one small disk. Third, the) 72 261.67 P
0.57 (4 1/2 minute timing for the original distributed state recovery is the length of the recovery storm) 72 248.67 P
0.41 (from chapter 3, Figure 3-6, using the testbed setup with only ten clients rather than 40. However) 72 235.67 P
0.41 (,) 501.25 235.67 P
0.4 (this recovery storm was arti\336cially induced, and since recovery storms are due to instability) 72 222.67 P
0.4 (, they) 479.19 222.67 P
(are of arbitrary length.) 72 209.67 T
0 14 Q
(6.1. Reusing T) 72 176.67 T
(ext and Initialized Data) 156.23 176.67 T
1 11 Q
0.04 (The \336rst step a server executes to reboot is to reacquire an image of its kernel to run. In particu-) 82.8 150.67 P
-0.23 (lar) 72 137.67 P
-0.23 (, it needs the text segment, because that contains the kernel code, and it needs the initialized data) 83.15 137.67 P
0.95 (segment, because that contains all the data structures that must start out with initial values. The) 72 124.67 P
-0.02 (server does not need to acquire the zero-\336lled data segment \050BSS segment\051, since it can create this) 72 111.67 P
(area merely by zeroing a section of memory) 72 98.67 T
(. The uninitialized data requires no start-up treatment.) 265.02 98.67 T
FMENDPAGE
%%EndPage: "105" 117
%%Page: "106" 117
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(106) 315.01 55 T
1 11 Q
( T) 118.8 415.66 T
(raditionally) 127.87 415.66 T
(, the \336le server) 177.82 415.66 T
2 F
(downloads) 245.85 415.66 T
1 F
( the kernel \050text and initialized data\051 from disk or across) 293.47 415.66 T
-0.04 (the network from another machine. On Sun workstations, the server) 108 402.66 P
-0.04 (\325) 406.2 402.66 P
-0.04 (s boot PROM \336rst locates \050on) 409.25 402.66 P
-0.06 (disk or across the network\051 a disk boot or network boot program and downloads this program. The) 108 389.66 P
1.66 (server then uses the boot program to download the kernel image. On the main Sun-4/280 \336le) 108 376.66 P
-0.13 (server) 108 363.66 P
-0.13 (, downloading the kernel from disk takes about seven seconds. On a SP) 134.4 363.66 P
-0.13 (ARCstation-2, down-) 445.52 363.66 P
0.08 (loading the kernel from across the network takes about 60 seconds, because the network boot pro-) 108 350.66 P
-0.01 (gram delivers the data in small packet sizes. Unfortunately) 108 337.66 P
-0.01 (, I could not measure the time for a disk) 364.99 337.66 P
-0 (boot on the SP) 108 324.66 P
-0 (ARCstation-2, because the only \336le system on that server is an LFS \336le system, and) 171.39 324.66 P
(we do not yet have a disk boot program that works for LFS.) 108 311.66 T
1.2 (T) 118.8 286.66 P
1.2 (o reduce the time needed to reacquire the kernel image, we have two options: optimize the) 124.74 286.66 P
0.2 (download programs, or reuse the kernel image already in the server) 108 273.66 P
0.2 (\325) 406.67 273.66 P
0.2 (s memory) 409.73 273.66 P
0.2 (. I chose the second) 452.85 273.66 P
0.19 (option, because it will always be faster than downloading the kernel. T) 108 260.66 P
0.19 (o do this, we must treat the) 420.18 260.66 P
1.79 (text segment and initialized data segments separately) 108 247.66 P
1.79 (. The kernel text can be reused in place,) 351.16 247.66 P
0.4 (because it does not change during the operation of the system. The text segment is also read-pro-) 108 234.66 P
0.26 (tected, so it will not be corrupted by kernel addressing errors. Reusing the initialized data is more) 108 221.66 P
-0.16 (complicated, because it is modi\336ed during system execution. T) 108 208.66 P
-0.16 (o solve this problem, the \336rst time a) 383.03 208.66 P
0.28 (host downloads the kernel image, the system copies the initialized data to an area of memory that) 108 195.66 P
0.73 (is then read-protected. For convenience, I use a few pages of the text segment. T) 108 182.66 P
0.73 (o reboot after a) 471.01 182.66 P
0.66 (crash, the system merely copies the original initialized data out of the text segment to its correct) 108 169.66 P
(address and then begins execution with the fresh copy of the data.) 108 156.66 T
-0.26 (The time required to reuse the kernel image this way depends on the time needed to copy the ini-) 118.8 131.66 P
0.21 (tialized data to the correct place in memory plus the time needed to clear the zero-\336lled data area.) 108 118.66 P
0.82 (In turn, this depends on the size of these segments and the speed and memory bandwidth of the) 108 105.66 P
-0.26 (server) 108 92.66 P
-0.26 (. T) 134.24 92.66 P
-0.26 (able 6-2 shows the size of the kernel segments and the time required to copy or clear them,) 145.41 92.66 P
108 81 540 720 C
108 422.99 540 720 C
108 430 542 714 R
7 X
0 K
V
1 11 Q
0 X
(T) 230.79 531.67 T
(able 6-1. Server reboot steps and timings.) 236.73 531.67 T
1 10 Q
1.73 (This table lists the steps a server goes through during rebooting. It gives rough times) 144 507.33 P
2.33 (required for these steps originally) 144 496.33 P
2.33 (, and the time required after various improvements) 287.03 496.33 P
-0.1 (described in this chapter) 144 485.33 P
-0.1 (. The times are scaled for 40 clients in the testbed setup, except for) 240.57 485.33 P
0.3 (three cases. The time to download the kernel from disk and the disk check and LFS times) 144 474.33 P
0.3 (were measured in the production Sprite system. The original 4 1/2-minute recovery storm) 144 463.33 P
108 431 540 449 C
108 431 542 449 R
7 X
0 K
V
108 440 540 440 2 L
V
0.5 H
2 Z
0 X
N
108 422.99 540 720 C
1 10 Q
0 X
0 K
(was measured in the testbed setup with only ten clients and was arti\336cially induced.) 144 452.33 T
(Reboot step) 167.26 674.33 T
(T) 293.12 674.33 T
(ime) 298.88 674.33 T
(Improvement) 379.07 674.33 T
(New time) 483.93 674.33 T
(Download kernel image) 119 656.33 T
(7 seconds) 296.86 656.33 T
(Reuse text and initialized data) 344 656.33 T
(0.03 seconds) 479.36 656.33 T
(Initialize kernel modules) 119 638.33 T
(23 seconds) 291.86 638.33 T
(Store pre-computed values) 344 638.33 T
(18 seconds) 486.86 638.33 T
(Check disks) 119 620.33 T
(40 minutes) 291.85 620.33 T
(Switch to LFS) 344 620.33 T
(3 seconds) 491.86 620.33 T
(Recover distributed state) 119 602.33 T
(4 1/2 minutes) 281.58 602.33 T
(T) 344 602.33 T
(ransparent recovery) 349.75 602.33 T
(5.3 seconds) 484.36 602.33 T
(Start kernel and daemon processes) 119 584.33 T
(10 seconds) 291.86 584.33 T
(Delay some processes) 344 584.33 T
(2 seconds) 491.86 584.33 T
(T) 119 566.33 T
(otal) 124.4 566.33 T
(~ 45 minutes) 283.95 566.33 T
(New total) 344 566.33 T
(28.3 seconds) 479.36 566.33 T
115 684 115 560 2 L
V
2 H
0 Z
N
267 686 267 558 2 L
V
0.5 H
N
340 686 340 558 2 L
V
2 H
N
472 686 472 558 2 L
V
0.5 H
N
535 684 535 560 2 L
V
2 H
N
114 685 536 685 2 L
V
N
116 668.25 534 668.25 2 L
V
0.5 H
N
116 665.75 534 665.75 2 L
V
N
114 649 536 649 2 L
V
N
114 631 536 631 2 L
V
N
114 613 536 613 2 L
V
N
114 595 536 595 2 L
V
N
116 578.25 534 578.25 2 L
V
N
116 575.75 534 575.75 2 L
V
N
114 559 536 559 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "106" 118
%%Page: "107" 118
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(107) 279.01 55 T
1 11 Q
-0.15 (as necessary) 72 471.7 P
-0.15 (. These measurements assume that the SP) 125.74 471.7 P
-0.15 (ARCstation-2 can copy uncached data at \336ve) 306.59 471.7 P
0.65 (megabytes/second and can zero uncached data twice that fast. \050My measurements use an unopti-) 72 458.7 P
0.35 (mized byte-copy routine at user) 72 445.7 P
0.35 (-level, so the time should be even less inside the kernel. This step) 212.32 445.7 P
1.36 (occurs too early in the boot procedure to time it during reboot.\051 The text segment is reused in) 72 432.7 P
0.52 (place, so there is no need to copy it. The initialized data segment is 76 kilobytes and takes 0.015) 72 419.7 P
-0.18 (seconds to copy) 72 406.7 P
-0.18 (. The zero-\336lled data segment is 148 kilobytes and takes 0.014 seconds to clear) 141.11 406.7 P
-0.18 (, for) 485.88 406.7 P
0.95 (a total of 0.029 seconds to initialize the kernel image. Reusing the text and initialized data seg-) 72 393.7 P
0.21 (ments allows us to avoid downloading over a megabyte of text and data in Sprite, saving seven to) 72 380.7 P
(60 seconds.) 72 367.7 T
0.5 (Reusing the kernel image may also enable switching to a new version of the kernel with mini-) 82.8 342.7 P
0.28 (mal downtime. It should be possible to download a new version of the kernel while executing the) 72 329.7 P
0.03 (previous version and then jump to the location of the new kernel to begin executing it. This would) 72 316.7 P
0.52 (eliminate the downtime suf) 72 303.7 P
0.52 (fered by systems when they are upgraded to new versions of the soft-) 193.28 303.7 P
0.63 (ware, but it would necessitate some cooperation and compatibility between the old and new ver-) 72 290.7 P
0.49 (sions of the software. The old version must have the ability to jump to the correct location in the) 72 277.7 P
0.73 (new version. And it must be possible to start execution of the new version at a dif) 72 264.7 P
0.73 (ferent address) 441.96 264.7 P
(than the address used in the previous version. This has not been implemented in Sprite.) 72 251.7 T
0 14 Q
(6.2. Using Pr) 72 218.7 T
(e-Computed V) 148.71 218.7 T
(alues) 234.86 218.7 T
1 11 Q
0.74 (The second step a Sprite \336le server executes to reboot is to initialize various system modules.) 82.8 192.7 P
0.14 (Some of these modules initialize parts of the hardware, and almost all of them set up various soft-) 72 179.7 P
0.06 (ware data structures. For example, the virtual memory module sets up the virtual address space by) 72 166.7 P
1.43 (initializing the hardware page tables and \336lling in software data structures that represent those) 72 153.7 P
(hardware page tables.) 72 140.7 T
0.14 (Module initialization is the step I have optimized least, because it is generally the most dif) 82.8 115.7 P
0.14 (\336cult) 481.41 115.7 P
0.22 (to optimize. The virtual memory module, for instance, is the slowest module to initialize, but I do) 72 102.7 P
(not see an easy way to improve it.) 72 89.7 T
72 81 504 720 C
72.5 479.03 503.5 720 C
70 488 505 714 R
7 X
0 K
V
1 11 Q
0 X
(T) 142.18 567.67 T
(able 6-2. Size and initialization times for Sprite kernel segments.) 148.13 567.67 T
1 10 Q
1.59 (This table gives the size in kilobytes of the Sprite kernel from a binary image for the) 106 543.33 P
1.52 (SP) 106 532.33 P
1.52 (ARCstation-2 and the times to initialize the segments. The text segment requires no) 116.2 532.33 P
0.27 (time, because it is reused in place. The initialized data segment must be copied to the cor-) 106 521.33 P
72.5 489 503.5 507 C
70 489 505 507 R
7 X
0 K
V
70 498 502 498 2 L
V
0.5 H
2 Z
0 X
N
72.5 479.03 503.5 720 C
1 10 Q
0 X
0 K
(rect location, and memory pages for the zero-\336lled segment must be cleared.) 106 510.33 T
(Segment) 143.01 674.33 T
(Size \050kilobytes\051) 249 674.33 T
(T) 352.85 674.33 T
(ime to initialize \050seconds\051) 358.61 674.33 T
(T) 104.5 656.33 T
(ext) 109.91 656.33 T
(1059.0) 309.02 656.33 T
(0) 465.51 656.33 T
(Initialized data) 104.5 638.33 T
(76.1) 319.01 638.33 T
(0.015) 448.02 638.33 T
(Zero-\336lled data) 104.5 620.33 T
(147.6) 314.02 620.33 T
(0.014) 448.02 620.33 T
(T) 104.5 602.33 T
(otal) 109.91 602.33 T
(1282.7) 309.02 602.33 T
(0.029) 448.02 602.33 T
100.5 684 100.5 596 2 L
V
2 H
0 Z
N
220.5 686 220.5 594 2 L
V
N
340.5 686 340.5 594 2 L
V
0.5 H
N
474.5 684 474.5 596 2 L
V
2 H
N
99.5 685 475.5 685 2 L
V
N
101.5 668.25 473.5 668.25 2 L
V
0.5 H
N
101.5 665.75 473.5 665.75 2 L
V
N
99.5 649 475.5 649 2 L
V
N
99.5 631 475.5 631 2 L
V
N
101.5 614.25 473.5 614.25 2 L
V
N
101.5 611.75 473.5 611.75 2 L
V
N
99.5 595 475.5 595 2 L
V
2 H
N
72 81 504 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "107" 119
%%Page: "108" 119
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(108) 315.01 55 T
1 11 Q
0.63 (However) 118.8 712.67 P
0.63 (, some other modules are easy to improve, because we can preserve information they) 158.62 712.67 P
1.14 (need across reboots, so they need not recalculate it. For example, the Sprite timer module cali-) 108 699.67 P
0.34 (brates the speed of the machine by idling for \336ve seconds and counting the number of timer ticks) 108 686.67 P
0.16 (that occur during that time. Although this number is dif) 108 673.67 P
0.16 (ferent for each machine, it will not change) 352.77 673.67 P
0.72 (across reboots on the same machine. The \336rst time the kernel boots, it computes the number the) 108 660.67 P
-0.04 (old way) 108 647.67 P
-0.04 (. It then stores the value in an area of memory that is made read-only) 142.34 647.67 P
-0.04 (. For a fast reboot, the) 443.46 647.67 P
(kernel retrieves this value from memory without a need to idle for \336ve seconds.) 108 634.67 T
0.57 (This technique is very similar to preserving a copy of the initialized data in memory) 118.8 609.67 P
0.57 (. In fact, I) 495.28 609.67 P
-0.27 (implement the technique by writing the computed value into a variable in the preserved copy of the) 108 596.67 P
-0.25 (initialized data. One low-level routine in the kernel makes the appropriate page of the saved initial-) 108 583.67 P
0.91 (ized data writable, updates the value, and makes the page read-only again. On a fast reboot, we) 108 570.67 P
0.86 (then get the correct value of the variable automatically in the initialized data. However) 108 557.67 P
0.86 (, the \336rst) 499.52 557.67 P
0.68 (time the kernel) 108 544.67 P
0.68 ( boots, the variable in the initialized data segment must have a value that signals) 178.02 544.67 P
(the system to execute the necessary computation.) 108 531.67 T
0.19 (A) 118.8 506.67 P
0.19 (voiding this computation in the timer module reduces overall module initialization from 23 to) 125.92 506.67 P
2.09 (18 seconds, but there are many other values we could pre-compute in this fashion. A Sprite) 108 493.67 P
1.39 (machine\325) 108 480.67 P
1.39 (s host ID and Internet address are possibilities. When a Sprite host boots, it currently) 148.28 480.67 P
0.3 (broadcasts its ethernet address on the network and waits for another machine to respond to it tell-) 108 467.67 P
0.82 (ing it what its host ID or Internet address is. Storing these values across reboots would save the) 108 454.67 P
0.43 (time consumed by this broadcast. W) 108 441.67 P
0.43 (ith optimizations such as these I believe we could reduce the) 269.61 441.67 P
(time needed for module initialization by several more seconds.) 108 428.67 T
0.95 (Finally) 118.8 403.67 P
0.95 (, the ability to preserve the values of certain variables across reboots is useful for pur-) 149.22 403.67 P
0.02 (poses other than fast recovery) 108 390.67 P
0.02 (. I have found it particularly useful for timing events during start-up.) 238.57 390.67 P
0.41 (T) 108 377.67 P
0.41 (o time reboots, I need to know exactly when they start. When the \336le server goes through a fast) 113.94 377.67 P
0.45 (reboot test, its last task before booting is to record the current time in a variable that is preserved) 108 364.67 P
1.29 (across the reboot. Because this is the server) 108 351.67 P
1.29 (\325) 308.47 351.67 P
1.29 (s last task, this time is identical to the start of the) 311.52 351.67 P
0.69 (reboot. I\325ve thus been able to take much more accurate start-up measurements than I could have) 108 338.67 P
(otherwise.) 108 325.67 T
0 14 Q
(6.3. Using LFS) 108 292.67 T
1 11 Q
0.26 (The lengthiest step in rebooting most UNIX-like operating systems is checking the consistency) 118.8 266.67 P
0.64 (of the \336le system on disk. For \336le systems such as the BSD Fast File System \050FFS\051 [McKusi84]) 108 253.67 P
-0 (and the original Sprite \336le system \050OFS\051, this operation is carried out by the) 108 240.67 P
2 F
-0 (fsck) 444.51 240.67 P
1 F
-0 ( \336le system check) 461.6 240.67 P
2.05 (program. In Sprite, fsck requires about 40 minutes to check \336ve gigabytes of disk. W) 108 227.67 P
2.05 (e have) 509.58 227.67 P
0.05 (reduced the time to check and recover the \336le system to about three seconds by switching to Men-) 108 214.67 P
1.07 (del Rosenblum\325) 108 201.67 P
1.07 (s Log-Structured File System \050LFS\051 [Rosenb91]. It was this switch that made it) 178.35 201.67 P
2.36 (reasonable to consider speeding up the other aspects of recovery) 108 188.67 P
2.36 (. W) 411.36 188.67 P
2.36 (ithout this switch, other) 429.15 188.67 P
(improvements would lar) 108 175.67 T
(gely be unnoticed.) 215.22 175.67 T
1.02 (There are two steps to recovering most \336le systems [Seltz93a]; checking the physical consis-) 118.8 150.67 P
-0.2 (tency of the \336le system on disk, and checking its logical structure. Both fsck and Sprite LFS recov-) 108 137.67 P
0.81 (ery perform the \336rst step. In FFS and OFS the \336rst step requires a lot of work, because a single) 108 124.67 P
0.15 (write to a \336le may result in several possible \336le system updates, all of which are performed at dif-) 108 111.67 P
0.89 (ferent locations on disk. If the server crashes, some updates may succeed while others may not,) 108 98.67 P
0.03 (leaving the \336le system physically inconsistent. Fsck must search the contents of the entire \336le sys-) 108 85.67 P
FMENDPAGE
%%EndPage: "108" 120
%%Page: "109" 120
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(109) 279.01 55 T
1 11 Q
-0.26 (tem to \336nd such inconsistencies. For example, a write to a \336le may add a new block to the \336le. This) 72 712.67 P
1.9 (may require updating an indirect block of the \336le, and also the metadata \050inode\051 for the \336le.) 72 699.67 P
0.99 (Because these operations are not performed atomically) 72 686.67 P
0.99 (, the system may create the new \336le data) 318.23 686.67 P
0.37 (block before the crash, but may not assign it to any \336le. Fsck must \336nd and \336x these inconsisten-) 72 673.67 P
(cies.) 72 660.67 T
0.02 (In LFS, by contrast, this \336rst step does not require much work. All \336le system modi\336cations are) 82.8 635.67 P
0.21 (made to the end of the log on disk, so it is only necessary to examine the end of the log to \336nd all) 72 622.67 P
0.93 (possible physical inconsistencies. This is done by \322rolling forward\323 from the last checkpoint on) 72 609.67 P
0.36 (the disk. At a checkpoint, the \336le system is physically consistent. All updates performed after the) 72 596.67 P
0.25 (checkpoint are written to the log on disk and can thus be repeated or undone. The amount of time) 72 583.67 P
-0.25 (to roll forward from the log depends on the number of updates performed since the last checkpoint.) 72 570.67 P
0.33 (Three seconds is a generously lar) 72 557.67 P
0.33 (ge estimate for a single disk, and multiple disks will be checked) 219.61 557.67 P
(in parallel [Rosenb92].) 72 544.67 T
-0.01 (The second part of recovering the \336le system is checking its logical structure, which can be cor-) 82.8 519.67 P
0.09 (rupted by a media failure. Fsck performs this task, while Sprite LFS recovery does not. For exam-) 72 506.67 P
0.81 (ple, a media failure or software bug can corrupt the contents of a directory) 72 493.67 P
0.81 (, so that \336les become) 408.29 493.67 P
1.87 (inaccessible. This leaves the \336le system logically incorrect. The BSD implementation of LFS) 72 480.67 P
0.25 ([Seltz93b] \050a more recent LFS implementation than Sprite\325) 72 467.67 P
0.25 (s\051 considers this an important \337aw and) 332.83 467.67 P
1.12 (thus performs the logical consistency check in background after roll-forward recovery from the) 72 454.67 P
-0.2 (log. This allows applications to begin running as soon as the roll-forward is done, while the system) 72 441.67 P
(eventually checks the logical consistency of the entire \336le system.) 72 428.67 T
0.54 (A background check of the Sprite LFS directory structure at recovery time is possible, but has) 82.8 403.67 P
0.55 (not been implemented for several reasons. First, media errors usually occur at the location of the) 72 390.67 P
1.23 (most recent update. In this case they can quickly be found during LFS\325) 72 377.67 P
1.23 (s roll-forward recovery) 397.63 377.67 P
1.23 (.) 501.25 377.67 P
0.2 (Second, other media errors can occur at any time anyway; if it is important to check for these, the) 72 364.67 P
0.28 (system should do this as a periodic background check during normal operation. The checks could) 72 351.67 P
1.26 (be performed during periods of low load, to avoid degrading performance. Third, checking the) 72 338.67 P
-0.19 (logical structure of the \336le system will not uncover media errors that af) 72 325.67 P
-0.19 (fect only the contents of \336le) 381.98 325.67 P
0.05 (data blocks, rather than the logical consistency of the \336le system. Fsck does not detect this kind of) 72 312.67 P
0.66 (\336le data corruption. Finally) 72 299.67 P
0.66 (, in highly reliable systems, disks are monitored for soft \050correctable\051) 193.5 299.67 P
0.51 (errors. If these become frequent, the disk should be replaced. By monitoring the error trends it is) 72 286.67 P
(usually possible to replace the faulty disk before it causes a permanent error [Lin90].) 72 273.67 T
-0.04 (There are two remaining problems with the Sprite implementation of LFS that have an ef) 82.8 248.67 P
-0.04 (fect on) 473.84 248.67 P
0.14 (the measurements in this dissertation. The \336rst is that we lack an LFS disk boot program. W) 72 235.67 P
0.14 (ithout) 478.36 235.67 P
0.66 (this boot program, we are obliged to boot Sprite from an OFS \336le system or across the network.) 72 222.67 P
0.21 (For this reason, I measured the disk boot times with the OFS disk boot program on the main Sun-) 72 209.67 P
0.19 (4/280. The second remaining problem is that Sprite does not actually use LFS roll-forward recov-) 72 196.67 P
0.16 (ery) 72 183.67 P
0.16 (, because it still has bugs. I have compensated for this problem by adding the three seconds for) 85.32 183.67 P
0.28 (roll-forward recovery to the reboot times listed in this thesis. Sprite currently just checkpoints the) 72 170.67 P
(\336le system every 30 seconds and recovers using the last checkpoint.) 72 157.67 T
0 14 Q
(6.4.) 72 124.67 T
(Recovering Distributed State) 96.49 124.67 T
1 11 Q
-0.27 (The previous chapters of this thesis describe how I\325ve improved distributed state recovery times.) 82.8 98.67 P
-0.16 (Before implementing congestion control in the RPC system and otherwise optimizing the recovery) 72 85.67 P
FMENDPAGE
%%EndPage: "109" 121
%%Page: "110" 121
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 315.23 55 T
(10) 320.78 55 T
1 11 Q
1.11 (protocol, client-driven recovery was unstable and could take many minutes to complete. Some-) 108 712.67 P
1.07 (times it did not complete at all. W) 108 699.67 P
1.07 (ith the improvements described in chapters 3-5, client-driven) 264.6 699.67 P
0.65 (recovery now takes no more than 30 seconds in the testbed setup. Other recovery techniques are) 108 686.67 P
2.02 (even faster) 108 673.67 P
2.02 (, with the fastest being transparent recovery) 157.47 673.67 P
2.02 (. Given its per) 360.78 673.67 P
2.02 (-client costs, transparent) 428.87 673.67 P
0.48 (recovery should less than six seconds in the testbed setup with 40 clients. Further improving dis-) 108 660.67 P
-0.27 (tributed \336le system state recovery in Sprite requires reducing the amount of disk I/O the server per-) 108 647.67 P
(forms.) 108 634.67 T
0 14 Q
(6.5. Delaying Daemon Start-Up) 108 601.67 T
1 11 Q
0.57 (A \336nal boot step that permits some performance improvement is the start-up of various kernel) 118.8 575.67 P
0.87 (processes and user) 108 562.67 P
0.87 (-level daemons. For this step I have not actually reduced the amount of work) 191.27 562.67 P
1.22 (that must be done but have chosen to delay some of it until after the server \336nishes rebooting.) 108 549.67 P
-0.01 (Delaying the start-up of some user) 108 536.67 P
-0.01 (-level daemon processes allows the most necessary processes to) 259.38 536.67 P
0.42 (start up more quickly) 108 523.67 P
0.42 (. For example, we can delay the line printer daemon, the tftp daemon, send-) 202.23 523.67 P
1.37 (mail, cron, the migration daemon, and the boot daemon for a few seconds with no harm. This) 108 510.67 P
0.81 (allows us to start up the necessary daemons \050such as Sprite\325) 108 497.67 P
0.81 (s user) 377.85 497.67 P
0.81 (-level IP server\051 eight seconds) 403.76 497.67 P
-0.04 (faster) 108 484.67 P
-0.04 (. Unfortunately) 131.8 484.67 P
-0.04 (, most kernel processes are immediately necessary) 198.17 484.67 P
-0.04 (, so they cannot be delayed.) 418.44 484.67 P
0.59 (For example, without the RPC server processes in the \336le server kernel, no requests from clients) 108 471.67 P
(can be handled.) 108 458.67 T
0.51 (While the choice of what to delay will be dif) 118.8 433.67 P
0.51 (ferent on dif) 319.37 433.67 P
0.51 (ferent systems, the important point is) 374.5 433.67 P
1.3 (that not all start-up work must be done during reboot. If any of the start-up work can be done) 108 420.67 P
0.88 (\322lazily) 108 407.67 P
0.88 (,\323 reboot will be faster) 136.57 407.67 P
0.88 (. By delaying less crucial services, we improve overall availability) 238.04 407.67 P
0.88 (.) 537.25 407.67 P
(This is one of the most generally useful techniques for increasing recovery speed.) 108 394.67 T
0 14 Q
(6.6. Further Impr) 108 361.67 T
(oving Reboot T) 214.23 361.67 T
(imes) 305.71 361.67 T
1 11 Q
0.99 (After the improvements described in this chapter) 118.8 335.67 P
0.99 (, the lar) 339.11 335.67 P
0.99 (gest amount of time during reboot is) 374.15 335.67 P
2.35 (now spent initializing kernel modules. T) 108 322.67 P
2.35 (o gain further signi\336cant improvements, we need to) 296.56 322.67 P
0.69 (reduce this amount of time from its current 18 seconds. Unfortunately) 108 309.67 P
0.69 (, this is the hardest area to) 421.44 309.67 P
0.07 (improve with general techniques, because dif) 108 296.67 P
0.07 (ferent modules do dif) 307.1 296.67 P
0.07 (ferent sorts of things for initial-) 401.4 296.67 P
0.91 (ization. For example, some modules must initialize hardware and are hampered by the response) 108 283.67 P
-0.27 (time of these devices. As another example, the virtual memory module must initialize software and) 108 270.67 P
0.14 (hardware page tables for a lar) 108 257.67 P
0.14 (ge amount of memory) 238.76 257.67 P
0.14 (. Neither of these examples is easily improved) 335.8 257.67 P
1.1 (by the techniques I have described, such as storing pre-computed values. Finding techniques to) 108 244.67 P
(improve these initialization times will greatly bene\336t fast recovery) 108 231.67 T
(.) 399.61 231.67 T
0 14 Q
(6.7. Summary) 108 198.67 T
1 11 Q
0.19 (T) 118.8 172.67 P
0.19 (o provide fast crash recovery) 124.74 172.67 P
0.19 (, we must reduce the time required by the complete server reboot) 252.31 172.67 P
0.87 (sequence, and not just distributed state recovery) 108 159.67 P
0.87 (. Combining the improvements described in this) 323.32 159.67 P
-0.18 (chapter) 108 146.67 P
-0.18 (, a Sprite \336le server can now recover in under 29 seconds. Using LFS to avoid a lengthy \336le) 139.89 146.67 P
0.31 (system check contributes the lar) 108 133.67 P
0.31 (gest improvement. The next lar) 250 133.67 P
0.31 (gest improvement comes from the) 388.64 133.67 P
-0.05 (distributed state recovery techniques described in previous chapters. In addition, Sprite \336le servers) 108 120.67 P
-0.25 (reuse the text and initialized data segments to avoid downloading new kernel images, and they pre-) 108 107.67 P
(serve pre-computed values across reboots to avoid time-consuming initialization.) 108 94.67 T
FMENDPAGE
%%EndPage: "110" 122
%%Page: "111" 122
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 279.45 55 T
(1) 285 55 T
(1) 290.55 55 T
72 666 504 720 C
72 666 504 720 R
7 X
0 K
V
72 693 504 693 2 L
0.5 H
2 Z
0 X
N
0 0 612 792 C
72 594 504 648 C
72 594 504 648 R
7 X
0 K
V
72 603 504 603 2 L
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(7) 108 638 T
0 18 Q
(Designing for Fast Crash Recovery) 144 654 T
1 11 Q
1.19 (This chapter contains some of the lessons I have learned about designing systems to recover) 82.8 519.67 P
0.89 (quickly after crashes. The overall lesson is that it is easier to design fast recovery into a system) 72 506.67 P
-0.2 (from the beginning than it is to \336x an existing system that suf) 72 493.67 P
-0.2 (fers from poor recovery performance.) 339.16 493.67 P
2.09 (The comments in this chapter come from my experience \336xing Sprite \336le servers to recover) 72 480.67 P
0.79 (quickly) 72 467.67 P
0.79 (, but most of the suggestions are applicable to other systems as well. The sections below) 104.25 467.67 P
1.05 (deal with issues such as compensating for the stress that recovery places on a system, avoiding) 72 454.67 P
0.11 (start-up overhead, using main memory to store data across failures, choosing and maintaining dis-) 72 441.67 P
(tributed state information, and debugging recovery code.) 72 428.67 T
0 14 Q
(7.1. Recovery Str) 72 395.67 T
(ess) 174.33 395.67 T
1 11 Q
0.84 (One of the \336rst lessons learned from \336xing Sprite\325) 82.8 369.67 P
0.84 (s \336le server crash recovery is that recovery) 309.87 369.67 P
1.88 (places a greater stress on the system than its normal activities. As the Sprite system grew to) 72 356.67 P
-0.17 (include more machines and users, the \336rst thing to break under the increased load was crash recov-) 72 343.67 P
0.61 (ery) 72 330.67 P
0.61 (. As described in chapter 3, the problem was a lack of negative acknowledgments in the RPC) 85.32 330.67 P
0.04 (system. This was a general \337aw) 72 317.67 P
0.04 (, but it surfaced \336rst during the communication load caused by cli-) 211.23 317.67 P
(ent-driven recovery storms.) 72 304.67 T
-0.22 (There are two reasons that recovery is stressful to a system. The \336rst is that the server is likely to) 82.8 279.67 P
0.22 (suf) 72 266.67 P
0.22 (fer a high load during recovery) 85.23 266.67 P
0.22 (. Designers must account for this when planning the capacity of) 221.99 266.67 P
1.71 (a system. Harp and other systems with backup servers provide an example. T) 72 253.67 P
1.71 (o avoid wasting) 431.01 253.67 P
0.81 (resources during normal execution, all backup servers in Harp are primary servers for their own) 72 240.67 P
-0.22 (\336le systems. After the failure of a primary server) 72 227.67 P
-0.22 (, its backup must handle its own load plus the load) 284.31 227.67 P
1.25 (of the failed primary) 72 214.67 P
1.25 (. If the backup is already loaded during normal execution, the load during) 165.63 214.67 P
1.42 (recovery may cause severe performance problems. It is necessary to make a trade-of) 72 201.67 P
1.42 (f between) 459.56 201.67 P
-0.08 (wasted capacity during normal system execution, and slow and perhaps unstable performance dur-) 72 188.67 P
(ing recovery) 72 175.67 T
(.) 126.5 175.67 T
0.04 (A second reason that recovery is stressful for systems is that it is less well tested than other sys-) 82.8 150.67 P
0.15 (tem activities. Recovery almost always exercises some special-purpose code. Because this code is) 72 137.67 P
0.46 (only exercised during recovery) 72 124.67 P
0.46 (, it is more likely to be faulty) 209.03 124.67 P
0.46 (, and recovery itself is more likely to) 339.08 124.67 P
(fail or cause damage.) 72 111.67 T
FMENDPAGE
%%EndPage: "111" 123
%%Page: "112" 123
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 315.23 55 T
(12) 320.78 55 T
1 11 Q
0.14 (Thus it seems like a good idea to design system recovery to use only commonly executed code,) 118.8 712.67 P
0.23 (but there is a trade-of) 108 699.67 P
0.23 (f involved. The problem is that commonly executed code is less ef) 202.69 699.67 P
0.23 (\336cient for) 496.75 699.67 P
1.41 (recovery) 108 686.67 P
1.41 (, since it is not optimized solely for that task. W) 145.72 686.67 P
1.41 (e \336nd an example of this trade-of) 369.52 686.67 P
1.41 (f in) 523.64 686.67 P
0.23 (Sprite. Client-driven recovery executes less special-purpose code than server) 108 673.67 P
0.23 (-driven and transpar-) 447.4 673.67 P
0.66 (ent recovery) 108 660.67 P
0.66 (, but it is also the slowest form of recovery) 162.55 660.67 P
0.66 (. Adding a reasonable amount of special-) 355.73 660.67 P
-0.02 (purpose code gives us server) 108 647.67 P
-0.02 (-driven recovery) 234 647.67 P
-0.02 (, which is faster and eliminates the cache consistency) 306.17 647.67 P
-0.2 (violations seen in client-driven recovery) 108 634.67 P
-0.2 (. T) 283.43 634.67 P
-0.2 (ransparent recovery is the fastest technique. However) 295.05 634.67 P
-0.2 (, it) 528.6 634.67 P
0.14 (uses the most special-purpose code, and therefore requires much more testing and debugging than) 108 621.67 P
(client-driven recovery) 108 608.67 T
(.) 204.6 608.67 T
0 14 Q
(7.2. Start-Up Overhead) 108 575.67 T
1 11 Q
0.67 (A) 118.8 549.67 P
0.67 (voiding start-up overhead is another pre-requisite for fast recovery) 125.92 549.67 P
0.67 (. A common design trade-) 422.88 549.67 P
0.65 (of) 108 536.67 P
0.65 (f is to perform extra processing during system start-up in order to avoid extra processing later) 116.95 536.67 P
0.65 (,) 537.25 536.67 P
0.27 (during normal execution. This is often the correct trade-of) 108 523.67 P
0.27 (f, but the amount of start-up processing) 365.36 523.67 P
0.96 (adds up quickly) 108 510.67 P
0.96 (, and can be prohibitive for fast recovery) 178.78 510.67 P
0.96 (. T) 363.55 510.67 P
0.96 (o avoid this overhead, designers can) 375.94 510.67 P
0.93 (consider each part of system start-up, to see if it can be delayed, optimized, or eliminated com-) 108 497.67 P
(pletely) 108 484.67 T
(.) 137.19 484.67 T
0.64 (There are examples of each of these three choices in Sprite. First, I delay the start-up of some) 118.8 459.67 P
0.74 (user) 108 446.67 P
0.74 (-level daemons until \336le server recovery \336nishes, allowing crucial services to start up faster) 126.08 446.67 P
0.74 (.) 537.25 446.67 P
0.63 (Delaying start-up work is perhaps the most generally applicable and easiest technique. Second, I) 108 433.67 P
-0.11 (optimize the initialization of some system modules by pre-computing and storing information they) 108 420.67 P
0.59 (need. Finally) 108 407.67 P
0.59 (, Sprite eliminates some overhead completely by using LFS rather than a traditional) 165.24 407.67 P
0.89 (UNIX-like \336le system. Using LFS allows us to skip the traditional consistency check of the \336le) 108 394.67 P
(systems in favor of quicker recovery from a short log.) 108 381.67 T
0 14 Q
(7.3. Using Main Memory) 108 348.67 T
1 11 Q
0.19 (Using main memory to store data across crashes is another example of a technique that reduces) 118.8 322.67 P
0.83 (start-up overhead while providing good overall performance. More systems should consider this) 108 309.67 P
0.12 (option, especially as decreasing RAM costs make lar) 108 296.67 P
0.12 (ge memories more attractive. Sprite recovery) 341.11 296.67 P
1.46 (uses main memory for several recovery tasks. The recovery box, used in transparent recovery) 108 283.67 P
1.46 (,) 537.25 283.67 P
0.15 (helps avoid communication overhead between clients and servers, can be used to avoid some disk) 108 270.67 P
0.65 (I/O, and adds negligible processing during normal execution of the system. Sprite also reuses its) 108 257.67 P
1.15 (kernel text and initialized data segments from main memory after a failure. This eliminates the) 108 244.67 P
-0.27 (overhead of downloading the kernel image. Using main memory this way is unconventional, and is) 108 231.67 P
-0.06 (not guaranteed to work after all failures. But it provides the fastest possible recovery with the least) 108 218.67 P
(overall performance loss during normal execution.) 108 205.67 T
0 14 Q
(7.4. Maintaining Corr) 108 172.67 T
(ect Distributed State Information) 239.12 172.67 T
1 11 Q
1.23 (Maintaining correct state information is a problem more systems designers will encounter as) 118.8 146.67 P
0.97 (they opt for the higher performance of stateful systems. Keeping extra state close to where it is) 108 133.67 P
2.6 (needed can provide huge performance bene\336ts. However) 108 120.67 P
2.6 (, maintaining state information also) 373.65 120.67 P
0.55 (requires extra processing overhead, extra space to store the state, and extra complexity to keep it) 108 107.67 P
0.32 (consistent and recover it correctly after failures. Thus it is a good idea to minimize the amount of) 108 94.67 P
FMENDPAGE
%%EndPage: "112" 124
%%Page: "113" 124
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 279.23 55 T
(13) 284.78 55 T
1 11 Q
0.43 (state a system keeps. Designers must choose what and how much state to store, where to store it,) 72 712.67 P
0.24 (when to update it, and how to retrieve it after a failure. In particular) 72 699.67 P
0.24 (, handling state is the trickiest) 371.57 699.67 P
-0.11 (recovery-related task. This section covers some of the lessons I\325ve learned about recovery of state-) 72 686.67 P
(ful systems.) 72 673.67 T
0 12 Q
(7.4.1. Managing State Recovery W) 72 642 T
(ith Mor) 248.66 642 T
(e State) 288.08 642 T
1 11 Q
0.29 (While minimizing the amount of necessary state information is usually a good idea, sometimes) 82.8 616.67 P
-0.21 (the solution to the state recovery problem is to maintain even more state. There are many examples) 72 603.67 P
-0.15 (of this phenomenon in Sprite. The \336rst obvious example is distributed cache state. For high perfor-) 72 590.67 P
0.8 (mance, Sprite allows clients to cache \336le data in their main memories. T) 72 577.67 P
0.8 (o provide cache consis-) 398.17 577.67 P
0.62 (tency) 72 564.67 P
0.62 (, the server keeps extra state information that records which clients are caching which \336les.) 95.08 564.67 P
0.04 (After a failure, the server must recover its distributed cache state to continue providing cache con-) 72 551.67 P
1.21 (sistency) 72 538.67 P
1.21 (. The solution to this recovery problem is to use distributed state. W) 106.68 538.67 P
1.21 (ith client-driven or) 419.2 538.67 P
0.06 (server) 72 525.67 P
0.06 (-driven recovery) 98.62 525.67 P
0.06 (, we can recover the server) 170.87 525.67 P
0.06 (\325) 289.3 525.67 P
0.06 (s state by retrieving the clients\325 state. Or we can) 292.35 525.67 P
-0.06 (improve recovery times by using transparent recovery) 72 512.67 P
-0.06 (, which maintains even more state on the \336le) 308.29 512.67 P
(server) 72 499.67 T
(, in a recovery box.) 98.4 499.67 T
0.58 (Another example of this phenomenon concerns the reliability of data after a server failure.The) 82.8 474.67 P
0.35 (\336le data cached by clients and the server is itself a form of distributed state. On many UNIX sys-) 72 461.67 P
-0.12 (tems, newly written data is vulnerable to loss for the length of a cache write interval \050about 30 sec-) 72 448.67 P
2.36 (onds\051. But on Sprite, new data from clients is vulnerable for the length of two cache write) 72 435.67 P
0.22 (intervals. When clients modify \336les, they cache the dirty data for about 30 seconds before writing) 72 422.67 P
0.01 (it back to the server) 72 409.67 P
0.01 (. The server then caches this dirty data for another 30 seconds before writing it) 158.1 409.67 P
0.93 (to disk. This new data will be lost if the clients reuse these cache blocks and the server crashes) 72 396.67 P
0.11 (before writing the data to disk. A solution to this problem is to keep more state on the clients. The) 72 383.67 P
-0.01 (clients can refuse to reuse dirty cache blocks until the server writes the data to disk. T) 72 370.67 P
-0.01 (o do this, the) 447.27 370.67 P
0.52 (clients can either set aside the cache blocks for the cache write interval of the server) 72 357.67 P
0.52 (, or they can) 448.15 357.67 P
-0.12 (wait until the server issues a call-back indicating the data is safe. Either way) 72 344.67 P
-0.12 (, the clients must mark) 404.7 344.67 P
0.34 (which cache blocks may be lost during a failure. Using this extra state information, they can then) 72 331.67 P
(resend the appropriate data to the server as part of recovery) 72 318.67 T
(.) 331.82 318.67 T
0 12 Q
(7.4.2.) 72 287 T
(Car) 101.98 287 T
(eful Bookkeeping) 121.75 287 T
1 11 Q
0.29 (Another lesson I\325ve learned is that the fastest recovery technique for stateful systems, transpar-) 82.8 261.67 P
1.39 (ent recovery) 72 248.67 P
1.39 (, requires more careful bookkeeping of state information than pre-existing systems) 127.28 248.67 P
-0 (may provide. For better performance, transparent recovery eliminates communication between the) 72 235.67 P
0.33 (clients and server during recovery) 72 222.67 P
0.33 (, but it is harder to keep distributed state consistent without this) 222.09 222.67 P
1.15 (extra communication. This problem is further explained in chapter 5, section 5.5. In Sprite, the) 72 209.67 P
0.45 (cache state maintained on the clients and the copy on the server can diver) 72 196.67 P
0.45 (ge. In client-driven and) 400.14 196.67 P
0.65 (server) 72 183.67 P
0.65 (-driven recovery) 98.62 183.67 P
0.65 (, this is usually not a problem, because the server refreshes its copy of the) 171.46 183.67 P
1.13 (state from that of the clients\325, ensuring consistency of state information after every failure. But) 72 170.67 P
0.62 (with transparent recovery we lose this opportunity to refresh the server) 72 157.67 P
0.62 (\325) 389.83 157.67 P
0.62 (s state information. Thus) 392.89 157.67 P
-0.23 (transparent recovery requires careful bookkeeping of such state as reference counts on \336les. Ensur-) 72 144.67 P
0.48 (ing the consistency of \336le reference counts requires hanging client close RPCs across server fail-) 72 131.67 P
(ures, so the server can process the close requests after recovery) 72 118.67 T
(.) 348.59 118.67 T
FMENDPAGE
%%EndPage: "113" 125
%%Page: "114" 125
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 315.23 55 T
(14) 320.78 55 T
1 11 Q
1.3 (T) 118.8 712.67 P
1.3 (ransparent recovery brings up another bookkeeping problem. As described in section 5.6.1,) 125.13 712.67 P
0.45 (Sprite servers handle directory modi\336cations asynchronously) 108 699.67 P
0.45 (, so the server) 378.37 699.67 P
0.45 (\325) 441.16 699.67 P
0.45 (s and clients\325 view of) 444.21 699.67 P
0.41 (the \336le system may diver) 108 686.67 P
0.41 (ge if a server crashes before issuing the necessary disk I/O. Because the) 219.91 686.67 P
0.28 (server does not communicate with the clients during transparent recovery) 108 673.67 P
0.28 (, it loses the opportunity) 432.35 673.67 P
0.49 (to refresh its directory state from that of the clients. The solution to this problem is to keep more) 108 660.67 P
0.48 (state on the server) 108 647.67 P
0.48 (, by logging directory operations to the recovery box. This allows the server to) 188.63 647.67 P
(\336nish the operations after it reboots.) 108 634.67 T
0 12 Q
(7.4.3. T) 108 603 T
(ools for Debugging Distributed State) 144.88 603 T
1 11 Q
1.29 (In the course of working with Sprite, I\325ve found two techniques that make management and) 118.8 577.67 P
1.01 (debugging of distributed state information easier) 108 564.67 P
1.01 (. First, designers should develop good tools for) 326.34 564.67 P
0.32 (examining state information. Second, it must be possible to clean up or destroy state information.) 108 551.67 P
(W) 108 538.67 T
(ith the proper tools, stateful systems need not be more mysterious than stateless ones.) 117.93 538.67 T
0.18 (T) 118.8 513.67 P
0.18 (o debug how the system handles state information, it must be possible to determine what state) 124.74 513.67 P
-0.18 (exists at any time. Therefore, a user) 108 500.67 P
-0.18 (-level program that gathers a snapshot of the distributed state is) 263.52 500.67 P
0.95 (essential. However) 108 487.67 P
0.95 (, developing such a tool for an existing system can be dif) 192.11 487.67 P
0.95 (\336cult. In Sprite, for) 452.61 487.67 P
0.06 (example, it is not always possible to view all the \336le system state on a machine, because some I/O) 108 474.67 P
0.64 (handles may be locked by parts of the kernel, and their contents cannot be fetched until they are) 108 461.67 P
-0.09 (unlocked. Unfortunately) 108 448.67 P
-0.09 (, it is often exactly these I/O handles that the person debugging the system) 214.6 448.67 P
-0.08 (most wishes to examine. When designing a system from scratch, it should be possible to develop a) 108 435.67 P
1.29 (mechanism to step around normal locks and minimize the times when it is impossible to get a) 108 422.67 P
(complete snapshot of important distributed state information.) 108 409.67 T
0.13 (A second technique that makes debugging a stateful system easier is the ability to destroy state.) 118.8 384.67 P
2.23 (For example, it should be possible to force a client workstation to give up all references to) 108 371.67 P
0.4 (resources on a server) 108 358.67 P
0.4 (. This ability makes it much easier to test and retest operations that accumu-) 201.01 358.67 P
0.4 (late or change distributed state. This in turn makes it possible to provoke and isolate state-related) 108 345.67 P
-0.2 (problems, such as circular resource dependencies amongst machines. In Sprite, such a tool must be) 108 332.67 P
0.3 (able to make a client do at least three things. First, the client must close all \336les and other objects) 108 319.67 P
0.8 (served by a particular server) 108 306.67 P
0.8 (. Second, it must release its references to any \336le system pre\336x ser-) 235.06 306.67 P
-0.26 (viced by that server) 108 293.67 P
-0.26 (. Third, it must delete that server from its recovery state information. This is the) 192.97 293.67 P
(state information clients use to determine which servers to monitor for failures and reboots.) 108 280.67 T
0 12 Q
(7.4.4. Isolating State Changes) 108 249 T
1 11 Q
0.17 (While working with Sprite, I have also learned that managing distributed state is much easier if) 118.8 223.67 P
-0.05 (the code that updates it is well-de\336ned and easy to isolate. This sounds simple, but may not be in a) 108 210.67 P
-0.06 (pre-existing system. In Sprite for example, it is not easy to isolate where \336les and other objects are) 108 197.67 P
0.99 (opened. This is because there are several tasks associated with opening a \336le, and they are per-) 108 184.67 P
0.38 (formed in dif) 108 171.67 P
0.38 (ferent places and at dif) 166.53 171.67 P
0.38 (ferent times: incrementing the \336le I/O handle reference count) 267.9 171.67 P
0.09 (and creating the stream handle for it are not executed atomically) 108 158.67 P
0.09 (. An error at any point in the code) 390.7 158.67 P
0.47 (that opens a \336le may invalidate previous state changes. Dealing with this was one of the trickiest) 108 145.67 P
1.28 (parts of implementing transparent recovery) 108 132.67 P
1.28 (. Modifying a pre-existing system to use transparent) 302.18 132.67 P
0.89 (recovery may necessitate rearranging some of the code that executes such state changes, so that) 108 119.67 P
0.85 (state updates to the recovery box can be made atomic, or at least con\336ned to only a few places.) 108 106.67 P
FMENDPAGE
%%EndPage: "114" 126
%%Page: "115" 126
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 279.23 55 T
(15) 284.78 55 T
1 11 Q
0.19 (When implementing a system from scratch, designers should try to isolate code that changes state) 72 712.67 P
(they may wish to recover) 72 699.67 T
(.) 182.46 699.67 T
0 14 Q
(7.5. Debugging Recovery Code) 72 666.67 T
1 11 Q
0.6 (Finally) 82.8 640.67 P
0.6 (, one of the dif) 113.22 640.67 P
0.6 (\336culties in debugging recovery code is that it is hard to force the system) 179.8 640.67 P
-0.1 (into all of the possible states that can occur during and after crashes. One of the reasons for a crash) 72 627.67 P
0.93 (is that something unexpected happens in the system, so it is hard to predict the existence of the) 72 614.67 P
0.75 (state that causes the crash. Nonetheless, it is worth testing recovery under many dif) 72 601.67 P
0.75 (ferent condi-) 446.81 601.67 P
0.63 (tions. A helpful tool is a test suite that drives the system through dif) 72 588.67 P
0.63 (ferent states and causes it to) 377.88 588.67 P
0.2 (recover from dif) 72 575.67 P
0.2 (ferent conditions. It is hard to guarantee the completeness of such a test suite, but) 144.2 575.67 P
(this does not negate its usefulness.) 72 562.67 T
0 14 Q
(7.6. Summary) 72 529.67 T
1 11 Q
0.22 (System designers generally acknowledge that failure recovery should be included as part of the) 82.8 503.67 P
0.71 (original design of a system, but in practice the attention paid to recovery in \336rst designs may be) 72 490.67 P
0.32 (cursory) 72 477.67 P
0.32 (. This is a pity) 104.23 477.67 P
0.32 (, since choices made early on may render fast recovery harder to implement) 167.35 477.67 P
0.24 (later) 72 464.67 P
0.24 (. Examples of such choices are planning the capacity of the system to accommodate recovery) 90.92 464.67 P
0.33 (loads, avoiding start-up overhead, using main memory for recovery information, and determining) 72 451.67 P
-0.06 (what state information to preserve across failures, how to maintain it, and when to update it. There) 72 438.67 P
0.77 (are several techniques to keep in mind that will save a lot of time during reboot without hurting) 72 425.67 P
0.5 (overall system performance. Examples in this thesis are choosing a \336le system that requires little) 72 412.67 P
1.24 (consistency checking during start-up, and saving state information in main memory rather than) 72 399.67 P
(retrieving it from disk or from other hosts. T) 72 386.67 T
(able 7-1 lists some of these techniques.) 266.83 386.67 T
FMENDPAGE
%%EndPage: "115" 127
%%Page: "116" 127
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 315.23 55 T
(16) 320.78 55 T
108 81 540 720 C
109.01 417 538.99 720 C
109.58 421 536.58 717 R
7 X
0 K
V
1 10 Q
0 X
(Fast crash recovery design techniques) 247.3 677.33 T
(Consider recovery issues early in the design process) 163.08 659.33 T
(Design recovery to handle extra stress) 163.08 641.33 T
(A) 163.08 623.33 T
(void start-up overhead) 169.55 623.33 T
(Use main memory to avoid communication and disk I/O costs) 163.08 605.33 T
(Manage state recovery with more state) 163.08 587.33 T
(Use careful bookkeeping of state information) 163.08 569.33 T
(Build tools for debugging distributed state) 163.08 551.33 T
(Isolate state changes in the code) 163.08 533.33 T
(Use a crash recovery test suite) 163.08 515.33 T
(Use a \336le system that requires no disk consistency check) 163.08 497.33 T
1 11 Q
(T) 214.84 472.67 T
(able 7-1. Fast crash recovery design techniques.) 220.79 472.67 T
1 10 Q
0.13 (This table lists some of the techniques described in this thesis for designing systems that) 145.58 448.33 P
(recover quickly from crashes.) 145.58 437.33 T
109.58 411 536.58 411 C
109.58 393 536.58 411 R
7 X
0 K
V
109.01 417 538.99 720 C
159.08 687 159.08 491 2 L
0 X
0 K
V
2 H
0 Z
N
487.08 687 487.08 491 2 L
V
N
158.08 688 488.08 688 2 L
V
N
160.08 671.25 486.08 671.25 2 L
V
0.5 H
N
160.08 668.75 486.08 668.75 2 L
V
N
158.08 652 488.08 652 2 L
V
N
158.08 634 488.08 634 2 L
V
N
158.08 616 488.08 616 2 L
V
N
158.08 598 488.08 598 2 L
V
N
158.08 580 488.08 580 2 L
V
N
158.08 562 488.08 562 2 L
V
N
158.08 544 488.08 544 2 L
V
N
158.08 526 488.08 526 2 L
V
N
158.08 508 488.08 508 2 L
V
N
158.08 490 488.08 490 2 L
V
2 H
N
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "116" 128
%%Page: "117" 128
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 279.23 55 T
(17) 284.78 55 T
72 666 504 720 C
72 666 504 720 R
7 X
0 K
V
72 693 504 693 2 L
0.5 H
2 Z
0 X
N
0 0 612 792 C
72 594 504 648 C
72 594 504 648 R
7 X
0 K
V
72 603 504 603 2 L
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 51 Q
0 X
0 K
(8) 108 638 T
0 18 Q
(Conclusion) 144 654 T
1 11 Q
0.35 (High-performance distributed \336le systems keep more state information than their predecessors.) 82.8 519.67 P
0.11 (Unfortunately) 72 506.67 P
0.11 (, this trend makes failure recovery slower and more complex, because these systems) 132.92 506.67 P
1.88 (must recover the distributed state. T) 72 493.67 P
1.88 (o combat the problem, we need techniques to make state) 238.7 493.67 P
0.29 (recovery fast and manageable. W) 72 480.67 P
0.29 (ith that goal, this thesis describes and evaluates three distributed) 219.45 480.67 P
0.48 (state recovery techniques for \336le servers and lists some lessons I\325ve learned about designing sys-) 72 467.67 P
(tems to provide fast recovery) 72 454.67 T
(.) 199.43 454.67 T
0.04 (The fast recovery approach is useful for more than state recovery) 82.8 429.67 P
0.04 (. It is an alternative for provid-) 368.61 429.67 P
2.74 (ing increased availability in environments where traditional fault-tolerant techniques are too) 72 416.67 P
0.11 (costly) 72 403.67 P
0.11 (, slow) 97.53 403.67 P
0.11 (, or complex. If non-stop availability is not essential, then we can increase overall sys-) 123.18 403.67 P
0.15 (tem availability with fast crash recovery) 72 390.67 P
0.15 (. The goal of fast crash recovery is not to prevent or mask) 248.68 390.67 P
-0.16 (failures, but instead to recover from them so quickly that they are not noticed. Therefore this thesis) 72 377.67 P
0.44 (lists all of the fast crash recovery techniques I\325ve used in the Sprite distributed system to make it) 72 364.67 P
(possible to recover our \336le servers in under 30 seconds.) 72 351.67 T
0.27 (This concluding chapter summarizes the results of this thesis, lists future work in this area, and) 82.8 326.67 P
(makes some \336nal comments about this project.) 72 313.67 T
0 14 Q
(8.1. Results) 72 280.67 T
1 11 Q
-0.24 (W) 82.8 254.67 P
-0.24 (ith the techniques described in this thesis, Sprite now recovers three orders of magnitude more) 92.73 254.67 P
0.1 (quickly than most distributed \336le systems. Most of this improvement comes from switching to the) 72 241.67 P
(LFS \336le system and using server) 72 228.67 T
(-driven or transparent distributed state recovery) 215.51 228.67 T
(.) 423.79 228.67 T
1.74 (T) 82.8 203.67 P
1.74 (able 8-1 summarizes the trade-of) 88.74 203.67 P
1.74 (fs between the three distributed state recovery techniques) 240.12 203.67 P
-0.18 (described in this thesis: client-driven, server) 72 190.67 P
-0.18 (-driven, and transparent recovery) 264.92 190.67 P
-0.18 (. Client-driven recov-) 409.48 190.67 P
0.7 (ery requires the least amount of special-purpose code, because clients initiate recovery using the) 72 177.67 P
0.57 (usual request/response RPC path. However) 72 164.67 P
0.57 (, client-driven recovery is also the most prone to con-) 263.93 164.67 P
0.45 (gestion on the server and may require careful optimization to scale to lar) 72 151.67 P
0.45 (ge numbers of clients. It) 395.72 151.67 P
0.55 (also necessitates a trade-of) 72 138.67 P
0.55 (f between slower recovery and cache consistency violations. In client-) 190.91 138.67 P
1.39 (driven recovery) 72 125.67 P
1.39 (, avoiding cache consistency violations requires a waiting period after recovery) 141.93 125.67 P
0.04 (before the server begins accepting new client requests. Even without this extra waiting period, cli-) 72 112.67 P
0.38 (ent-driven recovery is the slowest technique of the three: in the test-bed setup it takes 21 seconds) 72 99.67 P
(to recover ten clients on average and can easily take up to 30 seconds.) 72 86.67 T
FMENDPAGE
%%EndPage: "117" 129
%%Page: "118" 129
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 315.23 55 T
(18) 320.78 55 T
1 11 Q
0.15 (Server) 118.8 214.69 P
0.15 (-driven recovery is a modi\336cation of client-driven recovery that allows the server to con-) 147.26 214.69 P
0.13 (trol recovery) 108 201.69 P
0.13 (. It eliminates cache consistency violations, gives the server more congestion control,) 163.85 201.69 P
(and is faster) 108 188.69 T
(. Server) 160.48 188.69 T
(-driven recovery takes only two seconds on average for ten clients.) 194.43 188.69 T
1.2 (T) 118.8 163.69 P
1.2 (ransparent recovery is the fastest and most novel technique of the three, because the server) 125.13 163.69 P
-0.27 (recovers its distributed state information from its own main memory without the need to communi-) 108 150.69 P
0.35 (cate with clients. T) 108 137.69 P
0.35 (ransparent recovery takes only 1.5 seconds on average for ten clients. It elimi-) 192.27 137.69 P
0.04 (nates cache consistency violations and also allows the server to log directory modi\336cations. Using) 108 124.69 P
0.41 (this log, the server can ensure that no directory modi\336cations are lost in a failure, rather than just) 108 111.69 P
0.32 (report the errors to clients during recovery) 108 98.69 P
0.32 (. T) 295.29 98.69 P
0.32 (ransparent recovery uses main memory in an uncon-) 307.43 98.69 P
0.63 (ventional way) 108 85.69 P
3 F
0.63 (-) 173.96 85.69 P
1 F
0.63 ( as stable storage to preserve state information across failures. The recovery box) 179.99 85.69 P
108 81 540 720 C
109 222.02 539 720 C
107 228 538 718 R
7 X
0 K
V
1 10 Q
0 X
(Recovery) 133.2 678.33 T
(technique) 132.92 666.33 T
-1.31 (A) 192.97 678.33 P
-1.31 (verage recovery) 199.45 678.33 P
(speed \050seconds\051) 196.42 666.33 T
(Comments) 376.69 678.33 T
(Client-driven) 119.72 648.33 T
(21) 253.43 648.33 T
(+ Least special-purpose code for client/server RPC systems.) 271.42 648.33 T
(\320 T) 271.42 632.33 T
(ends to cause server load and congestion.) 284.33 632.33 T
-0.23 (\320 Requires trade-of) 271.42 616.33 P
-0.23 (f between slower recovery and cache consis-) 347.94 616.33 P
(tency violations.) 271.42 604.33 T
(\320 Slowest recovery \050can be at least as long as) 271.42 588.33 T
2 F
(ping) 454.61 588.33 T
(interval) 474.88 588.33 T
1 F
(\051.) 505.98 588.33 T
(Server) 119.72 570.33 T
(-driven) 145.61 570.33 T
(2.0) 250.93 570.33 T
(+ Few modi\336cations beyond client-driven.) 271.42 570.33 T
(+ Fixes caches consistency problems.) 271.42 554.33 T
(+ Faster recovery) 271.42 538.33 T
(.) 340.8 538.33 T
(+ More server control over congestion.) 271.42 522.33 T
(\320 T) 271.42 506.33 T
(ricky synchronization and locking in kernel) 284.68 506.33 T
(\320 Only as fast as the slowest client.) 271.42 490.33 T
(\320 May require client-driven recovery as backup.) 271.42 474.33 T
(T) 119.72 456.33 T
(ransparent) 125.48 456.33 T
(1.5) 250.93 456.33 T
(+ Recovery box useful for applications too.) 271.42 456.33 T
(+ Fixes cache consistency violations.) 271.42 440.33 T
(+ Fastest recovery) 271.42 424.33 T
(.) 344.14 424.33 T
(+ Allows recovery of directory operations too.) 271.42 408.33 T
(Unconventional use of main memory) 283.2 392.33 T
(.) 431.34 392.33 T
(\320 Most special-purpose code.) 271.42 376.33 T
(\320 T) 271.42 360.33 T
(ricky bookkeeping.) 284.68 360.33 T
(\320 May require client-driven recovery as backup.) 271.42 344.33 T
1 11 Q
(T) 186.04 319.67 T
(able 8-1. Evaluation of distributed state recovery techniques.) 191.98 319.67 T
1 10 Q
-0.23 (This table summarizes the trade-of) 143 295.33 P
-0.23 (fs among the three distributed state recovery techniques) 280.7 295.33 P
-0.12 (evaluated in this thesis. The second column gives the time in seconds to recover 10 clients) 143 284.33 P
-0.16 (of a SP) 143 273.33 P
-0.16 (ARCstation-2 server) 170.64 273.33 P
-0.16 (, with the average client state setup of T) 252.53 273.33 P
-0.16 (able 3-5. The third col-) 410.19 273.33 P
0.93 (umn lists advantages \050marked with a \324+\325\051 and disadvantages \050marked with a \324\320\325\051 of the) 143 262.33 P
109 230 538 248 C
107 230 538 248 R
7 X
0 K
V
107 239 539 239 2 L
0.5 H
2 Z
0 X
N
109 222.02 539 720 C
1 10 Q
0 X
0 K
(techniques.) 143 251.33 T
115.72 688 115.72 338 2 L
V
2 H
0 Z
N
188.97 690 188.97 336 2 L
V
N
267.42 690 267.42 336 2 L
V
0.5 H
N
529.28 688 529.28 338 2 L
V
2 H
N
114.72 689 530.28 689 2 L
V
N
116.72 660.25 528.28 660.25 2 L
V
0.5 H
N
116.72 657.75 528.28 657.75 2 L
V
N
114.72 581 530.28 581 2 L
V
N
114.72 467 530.28 467 2 L
V
N
114.72 337 530.28 337 2 L
V
2 H
N
267.42 337 529.28 467 C
271.42 389.45 283.2 399.36 C
3 9 Q
0 X
0 K
(\261) 272.42 392.33 T
267.42 337 529.28 467 C
109 222.02 539 720 C
108 81 540 720 C
0 0 612 792 C
FMENDPAGE
%%EndPage: "118" 130
%%Page: "119" 130
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(1) 279.23 55 T
(19) 284.78 55 T
1 11 Q
0.49 (can be used by applications as well as the kernel. The main disadvantage of transparent recovery) 72 712.67 P
1.61 (compared to the other techniques is that it requires the most special-purpose code and careful) 72 699.67 P
(bookkeeping of state information.) 72 686.67 T
0 14 Q
(8.2. Futur) 72 653.67 T
(e W) 131.21 653.67 T
(ork) 154.15 653.67 T
1 11 Q
0.75 (There are far more topics related to fast recovery than are covered by this thesis. This section) 82.8 627.67 P
(lists a few of these topics.) 72 614.67 T
0 12 Q
(8.2.1. Other Metrics for Comparing State Recovery T) 72 583 T
(echniques) 344.68 583 T
1 11 Q
1.18 (This dissertation has compared distributed state recovery techniques based upon speed, com-) 82.8 557.67 P
0.55 (plexity and reliability) 72 544.67 P
0.55 (, but there are other useful metrics. System security is one example. Client-) 166.98 544.67 P
2.82 (driven and server) 72 531.67 P
2.82 (-driven recovery may of) 153.69 531.67 P
2.82 (fer less system security than transparent recovery) 268.42 531.67 P
2.82 (,) 501.25 531.67 P
0.51 (because the server must trust the state information sent to it by clients. A system with signi\336cant) 72 518.67 P
0.54 (security requirements would need to authenticate the clients before they recover their state infor-) 72 505.67 P
0.17 (mation. This could be a very costly operation. Perhaps transparent recovery can provide this extra) 72 492.67 P
(security at less cost.) 72 479.67 T
0 12 Q
(8.2.2. Long-T) 72 448 T
(erm Evaluation of the Recovery Box) 139.54 448 T
1 11 Q
0.14 (While this thesis includes an initial evaluation of the recovery box, its true value must be deter-) 82.8 422.67 P
0.55 (mined over time. Sprite has not used transparent recovery enough for us to know whether it pro-) 72 409.67 P
0.61 (vides fast restart after the majority of failures, or whether too many failures corrupt the recovery) 72 396.67 P
1.21 (box. If the recovery box works for most failures, then its extra implementation ef) 72 383.67 P
1.21 (fort is worth-) 443.61 383.67 P
0.44 (while. But if the recovery box becomes corrupted frequently or the data it stores is susceptible to) 72 370.67 P
0.44 (error propagation, then the technique is not interesting in this environment. Measurements over a) 72 357.67 P
1.05 (period of several months would help answer this question. It would be useful if these measure-) 72 344.67 P
0.7 (ments were also performed in systems other than Sprite) 72 331.67 P
3 F
0.7 (-) 325.13 331.67 P
1 F
0.7 ( systems intended more for production) 331.16 331.67 P
(use and less for research.) 72 318.67 T
0 12 Q
(8.2.3. Long-T) 72 287 T
(erm Evaluation of Fast Recovery) 139.54 287 T
1 11 Q
0.87 (Along similar lines, a long-term evaluation of fast crash recovery is necessary) 82.8 261.67 P
0.87 (. W) 433.97 261.67 P
0.87 (e do not yet) 449.83 261.67 P
0.1 (know whether fast crash recovery signi\336cantly improves availability over a long period of time. It) 72 248.67 P
0.26 (is conceivable that we \336nd permanent hardware failures occur frequently enough that only redun-) 72 235.67 P
0.45 (dant hardware can signi\336cantly improve availability) 72 222.67 P
0.45 (. For this reason we cannot yet be sure of the) 302.69 222.67 P
-0.13 (range of environments that will \336nd fast crash recovery preferable to traditional fault tolerant tech-) 72 209.67 P
(niques.) 72 196.67 T
0 12 Q
(8.2.4. Evaluation of Complexity) 72 165 T
1 11 Q
0.73 (This thesis also has not addressed the issue of how to evaluate the relative complexity of sys-) 82.8 139.67 P
-0.07 (tems using the dif) 72 126.67 P
-0.07 (ferent recovery techniques. Intuitively) 150.02 126.67 P
-0.07 (, I believe the recovery box is simple com-) 316.91 126.67 P
-0 (pared to distributed systems that use a high level of redundancy to mask failures. But I have found) 72 113.67 P
0.65 (no good metrics to prove this. Measuring lines of code is not satisfactory) 72 100.67 P
0.65 (, and other metrics I\325ve) 399.19 100.67 P
FMENDPAGE
%%EndPage: "119" 131
%%Page: "120" 131
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(120) 315.01 55 T
1 11 Q
0.3 (found do not account for the complexity of shared state and control paths between software mod-) 108 712.67 P
(ules.) 108 699.67 T
0 12 Q
(8.2.5. Side-Effects of Fast Recovery) 108 668 T
1 11 Q
0.79 (Another question about fast recovery is whether it has any negative side-ef) 118.8 642.67 P
0.79 (fects. It is possible) 455.86 642.67 P
-0.23 (that very fast recovery could result in gradually buggier code. If recovery is fast enough, then users) 108 629.67 P
1.1 (may be more likely to tolerate software bugs that cause infrequent failures. These are often the) 108 616.67 P
-0.17 (most dif) 108 603.67 P
-0.17 (\336cult bugs to \336nd and \336x, so fast recovery from these failures may be the most economical) 143.95 603.67 P
1.3 (solution. However) 108 590.67 P
1.3 (, it is unnerving to consider the acceptance of buggier code. Certainly) 190.03 590.67 P
1.3 (, if the) 509.02 590.67 P
0.25 (number of bugs increases to the point where failures are frequent, even fast recovery will not suf-) 108 577.67 P
0.13 (\336ce. The bugs will have to be found and \336xed. It would be interesting to investigate the range and) 108 564.67 P
(frequency of failures that users will tolerate if the system recovers very quickly) 108 551.67 T
(.) 455.72 551.67 T
0 12 Q
(8.2.6. Impr) 108 520 T
(oved Crash Diagnostics) 164.42 520 T
1 11 Q
0.52 (A similar issue concerns crash diagnostics for systems with fast recovery) 118.8 494.67 P
0.52 (. If a system recovers) 444.27 494.67 P
0.81 (quickly and automatically from crashes, it may be hard to debug the problem and determine the) 108 481.67 P
0.69 (cause of the failures. It is possible to set a parameter in the running system that prevents it from) 108 468.67 P
0.55 (doing a fast reboot after the next failure. This provides an opportunity after the crash to examine) 108 455.67 P
0.54 (the system. However) 108 442.67 P
0.54 (, this approach will not signi\336cantly reduce downtime. If the system instead) 201.1 442.67 P
-0.02 (records detailed crash diagnostics automatically) 108 429.67 P
-0.02 (, it might be possible to debug it without making it) 317.73 429.67 P
1.54 (unavailable for long periods of time. Future work in this area should help provide diagnostics) 108 416.67 P
(beyond just the type of fault and the location in the code where it occurred.) 108 403.67 T
0 12 Q
(8.2.7. Using the Recovery Box for Applications) 108 372 T
1 11 Q
0.9 ( While this thesis concentrates on fast restart of operating systems, the fast restart of applica-) 118.8 346.67 P
0.36 (tions is also important. This is particularly true for those applications that act as servers and must) 108 333.67 P
-0.14 (be started up soon after system reboot. It would be interesting to investigate the recovery box\325) 108 320.67 P
-0.14 (s use) 518.47 320.67 P
0.05 (for a variety of applications. This thesis describes Mark Sullivan\325) 108 307.67 P
0.05 (s use of the recovery box for fast) 395.32 307.67 P
0.15 (restart of the POSTGRES database, but I have not explored its use for any other applications. The) 108 294.67 P
0.22 (most obvious applications that might bene\336t are those providing network services. These applica-) 108 281.67 P
0.37 (tions could use the recovery box in the same way that \336le servers do to avoid disk I/Os and com-) 108 268.67 P
(munication with clients during recovery) 108 255.67 T
(.) 283.05 255.67 T
1.54 (An example of such an application is a network name server) 118.8 230.67 P
1.54 (, such as the Berkeley Internet) 399.25 230.67 P
0.85 (Name Domain Server [Dunlap86]. A name server is a distributed database that allows clients to) 108 217.67 P
-0.17 (name objects in a distributed system. The server is a daemon called) 108 204.67 P
2 F
-0.17 (named) 404.61 204.67 P
1 F
-0.17 ( that responds to queries) 433.9 204.67 P
0.06 (on a network port. Given the name of an object, such as a host on the Internet, the server responds) 108 191.67 P
-0.02 (with an address at which one can access the object. Some of the servers store this name-to-address) 108 178.67 P
0.58 (translation information on disk and read it in during start-up. Others obtain the information from) 108 165.67 P
-0.04 (another server and recheck with that server periodically to see if their data is still correct. Either of) 108 152.67 P
0.02 (these types of servers could store the name-to-address translation data in the recovery box. During) 108 139.67 P
1.45 (start-up, the daemon could then retrieve the information from the kernel\325) 108 126.67 P
1.45 (s memory rather than) 441.98 126.67 P
1.02 (from disk or another server) 108 113.67 P
1.02 (. T) 231.09 113.67 P
1.02 (o add, delete or change an address translation, the daemon would) 243.55 113.67 P
(update the kernel\325) 108 100.67 T
(s main memory through the recovery box system call interface.) 186.72 100.67 T
FMENDPAGE
%%EndPage: "120" 132
%%Page: "121" 132
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(121) 279.01 55 T
0 F
(8.2.8. Fast Application Page-In) 72 712 T
1 11 Q
0.54 (Another fast restart issue for applications is optimizing their initial page-in. Some applications) 82.8 686.67 P
0.01 (must page in a lar) 72 673.67 P
0.01 (ge amount of text and initialized data before continuing with their normal opera-) 149.95 673.67 P
1.9 (tions. The problem is particularly severe for some applications written in object-oriented lan-) 72 660.67 P
0.09 (guages such as C++. In these applications many data structures have start-up code associated with) 72 647.67 P
0.7 (them. The code and the data are not necessarily located contiguously in the disk image and may) 72 634.67 P
-0.05 (require many disk seeks to be loaded into the application\325) 72 621.67 P
-0.05 (s in-memory image. It would be interest-) 324.55 621.67 P
-0.07 (ing to investigate compiler enhancements that lay out the application\325) 72 608.67 P
-0.07 (s code and data with the goal) 376.86 608.67 P
(of reducing start-up times.) 72 595.67 T
0 14 Q
(8.3. Final Comments) 72 562.67 T
1 11 Q
0.6 (I am very fortunate to have had the Sprite operating system available for this work. Sprite has) 82.8 536.67 P
0.76 (proven to be more \337exible, robust, and well-documented than I could have expected. And while) 72 523.67 P
-0.14 (there have been many frustrations associated with modifying Sprite to behave in ways not contem-) 72 510.67 P
0.36 (plated by its original designers, I would never have \336nished this work without an existing system) 72 497.67 P
(as a foundation.) 72 484.67 T
0.99 (As part of modifying Sprite, I\325ve learned the value of real implementations for judging one\325) 82.8 459.67 P
0.99 (s) 499.73 459.67 P
0.87 (research ideas. Nothing is as simple as it seems. This is why paper designs and simulations fre-) 72 446.67 P
1.85 (quently overlook some feature that is required in a real implementation and that qualitatively) 72 433.67 P
0.83 (changes the results. An example from this thesis is the implementation of the recovery box. My) 72 420.67 P
(original design entirely overlooked the problem of asynchronous directory modi\336cations.) 72 407.67 T
0.08 (Finally) 82.8 382.67 P
0.08 (, I hope that future systems will consider recovery as an important part of system design.) 113.22 382.67 P
1.47 (File server technology has moved beyond stateless servers and now requires more attention to) 72 369.67 P
1.08 (recovery) 72 356.67 P
1.08 (. Unfortunately) 109.72 356.67 P
1.08 (, relatively few systems have paid much attention to recovering quickly) 177.21 356.67 P
1.08 (,) 501.25 356.67 P
0.79 (and fast recovery is harder to implement if it is not designed in from the beginning. It is human) 72 343.67 P
0.03 (nature to believe that the system you design will not fail often, but it is also human nature to make) 72 330.67 P
(mistakes. Fast failure recovery may make these mistakes more tolerable in the long term.) 72 317.67 T
FMENDPAGE
%%EndPage: "121" 133
%%Page: "122" 133
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(122) 315.01 55 T
108 666 540 720 C
108 666 540 720 R
7 X
0 K
V
108 693 540 693 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
108 594 540 648 C
108 594 540 648 R
7 X
0 K
V
108 603 540 603 2 L
V
0.5 H
2 Z
0 X
N
0 0 612 792 C
0 18 Q
0 X
0 K
(Bibliography) 180 654 T
1 11 Q
([Accett86]) 108 519.67 T
0.15 (Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid,) 194.4 520.67 P
0.45 (Avadis Tevanian, and Michael Young. \322Mach: A New Kernel Foundation for) 194.4 507.67 P
0.51 (UNIX Development.\323) 194.4 494.67 P
2 F
0.51 (Pr) 295.18 494.67 P
0.51 (oceedings of the Summer 1986 USENIX Confer) 305.76 494.67 P
0.51 (ence) 517.13 494.67 P
1 F
0.51 (,) 537.25 494.67 P
(pages 93-112, June, 1986.) 194.4 481.67 T
([Anonym88]) 108 458.67 T
5.57 (Anonymous. \322A Measure of Transaction Processing Power.\323 Tandem) 194.4 459.67 P
-0.62 (Corporation Technical Report 85.1. In) 194.4 446.67 P
2 F
-0.62 (Readings in Database Systems) 362.46 446.67 P
1 F
-0.62 (, edited by) 495.17 446.67 P
3.43 (Michael Stonebraker, pages 300-312. Morgan Kaufmann Publishers, San) 194.4 433.67 P
(Mateo, California, 1988.) 194.4 420.67 T
([Babaog90]) 108 397.67 T
-0.51 (Ozalp Babaoglu. \322Fault-Tolerant Computing Based on Mach.\323) 194.4 398.67 P
2 F
-0.51 (ACM Operating) 469.41 398.67 P
(Systems Review) 194.4 385.67 T
1 F
(, pages 27-39, January, 1990.) 263.66 385.67 T
([Baker91a]) 108 362.67 T
0.78 (Mary Baker and John Ousterhout. \322Availability in the Sprite Distributed File) 194.4 363.67 P
(System.\323) 194.4 350.67 T
2 F
(ACM Operating Systems Review) 237.13 350.67 T
1 F
(, pages 95-98, April, 1991.) 380.23 350.67 T
([Baker91b]) 108 327.67 T
-0.53 (Mary Baker, John Hartman, Michael Kupfer, Ken Shirriff and John Ousterhout.) 194.4 328.67 P
1.01 (\322Measurements of a Distributed File System.\323) 194.4 315.67 P
2 F
1.01 (Pr) 406.45 315.67 P
1.01 (oceedings of the Thirteenth) 417.03 315.67 P
(Symposium on Operating Systems Principles) 194.4 302.67 T
1 F
(, pages 198-212, October, 1991.) 391.53 302.67 T
([Baker92a]) 108 279.67 T
0.52 (Mary Baker and Mark Sullivan. \322The Recovery Box: Using Fast Recovery to) 194.4 280.67 P
2.37 (Provide High Availability in the UNIX Environment.\323) 194.4 267.67 P
2 F
2.37 (Pr) 453.28 267.67 P
2.37 (oceedings of the) 463.86 267.67 P
(Summer 1992 USENIX Confer) 194.4 254.67 T
(ence) 328.57 254.67 T
1 F
(, pages 31-43, June, 1992.) 348.69 254.67 T
([Baker92b]) 108 231.67 T
2.49 (Mary Baker, Satoshi Asami, Etienne Deprit, John Ousterhout, and Margo) 194.4 232.67 P
0.42 (Seltzer. \322Non-Volatile Memory for Fast, Reliable File Systems.\323) 194.4 219.67 P
2 F
0.42 (Pr) 485.48 219.67 P
0.42 (oceedings) 496.07 219.67 P
6.91 (of the Fifth International Confer) 194.4 206.67 P
6.91 (ence on Ar) 364.46 206.67 P
6.91 (chitectural Support for) 425.47 206.67 P
-0.16 (Pr) 194.4 193.67 P
-0.16 (ogramming Languages and Operating Systems) 204.98 193.67 P
1 F
-0.16 (, pages 10-22, October, 1992.) 410.64 193.67 P
([Banatr89]) 108 170.67 T
4.77 (J. P. Banatre, M. Banatre, G. Muller. \322Architecture of Fault-Tolerant) 194.4 171.67 P
4.41 (Multiprocessor Workstations.\323) 194.4 158.67 P
2 F
4.41 (Pr) 341.46 158.67 P
4.41 (oceedings of the Second W) 352.04 158.67 P
4.41 (orkshop on) 486.45 158.67 P
(W) 194.4 145.67 T
(orkstation Operating Systems) 202.54 145.67 T
1 F
(, pages 20-24, September, 1989.) 332.54 145.67 T
([Bartle81]) 108 122.67 T
1.92 (J. Bartlett. \322A NonStop Kernel.\323) 194.4 123.67 P
2 F
1.92 (Pr) 349.85 123.67 P
1.92 (oceedings of the Eighth Symposium on) 360.43 123.67 P
(Operating Systems Principles) 194.4 110.67 T
1 F
(, December, 1981.) 325.01 110.67 T
([Bartle90]) 108 87.67 T
1.09 (Wendy Bartlett, Richard Carr, Dave Garcia, Jim Gray, Robert Horst, Robert) 194.4 88.67 P
FMENDPAGE
%%EndPage: "122" 134
%%Page: "123" 134
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(123) 279.01 55 T
1 11 Q
1.91 (Jardine, Dan Lenoski, Dix McGuire, and Joel Bartlett. \322Fault Tolerance in) 158.4 712.67 P
1.82 (Tandem Computer Systems.\323 Tandem Technical Report 90.5, Tandem Part) 158.4 699.67 P
(Number 40666, March, 1990.) 158.4 686.67 T
([Birman84]) 72 663.67 T
2.18 (Kenneth P. Birman, Amr El Abbadi, Wally Dietrich, Thomas Joseph, and) 158.4 664.67 P
-0.59 (Thomas Raeuchle. \322An Overview of the Isis Project.\323 Technical Report number) 158.4 651.67 P
2.05 (TR 84-642, Department of Computer Science, Cornell University, October) 158.4 638.67 P
(1984.) 158.4 625.67 T
([Birman89]) 72 602.67 T
2.35 (Kenneth Birman and Keith Marzullo. \322The ISIS Distributed Programming) 158.4 603.67 P
-0.38 (Toolkit and the Meta Distributed Operating System.\323) 158.4 590.67 P
2 F
-0.38 (SUN T) 392.55 590.67 P
-0.38 (echnology) 420.77 590.67 P
1 F
-0.38 (, volume) 465.93 590.67 P
(2, number 1, pages 90-104, Summer 1989.) 158.4 577.67 T
([Birman91]) 72 554.67 T
1.43 (Kenneth Birman, Andre\325 Schiper, and Pat Stephenson. \322Lightweight Causal) 158.4 555.67 P
3.15 (and Atomic Group Multicast.\323) 158.4 542.67 P
2 F
3.15 (ACM T) 308 542.67 P
3.15 (ransactions on Computer Systems) 342.59 542.67 P
1 F
3.15 (,) 501.25 542.67 P
(volume 9, number 3, pages 272-314, August, 1991.) 158.4 529.67 T
([Birrel82]) 72 506.67 T
-0.26 (Andrew D. Birrell, Roy Levin, Roger M. Needham, and Michael D. Schroeder.) 158.4 507.67 P
0.9 (\322Grapevine: An Exercise in Distributed Computing.\323) 158.4 494.67 P
2 F
0.9 (Communications of the) 400.27 494.67 P
(ACM) 158.4 481.67 T
1 F
(, volume 25, number 4, pages 260-274, April, 1982.) 181.59 481.67 T
([Birrel87]) 72 458.67 T
0.12 ([Andrew D. Birrell, Michael B. Jones, and Edward P. Wobber. \322A Simple and) 158.4 459.67 P
1.26 (Efficient Implementation for Small Databases.\323) 158.4 446.67 P
2 F
1.26 (Pr) 377.06 446.67 P
1.26 (oceedings of the Eleventh) 387.64 446.67 P
(ACM Symposium on Operating Systems Principles) 158.4 433.67 T
1 F
(, pages 149-154, 1987.) 381.47 433.67 T
([Blasge79]) 72 410.67 T
0.96 (M. Blasgen, J. Gray, M. Mitoma, and T. Price. \322The Convoy Phenomenon.\323) 158.4 411.67 P
(Operating Systems Review, volume 13, number 2, April, 1979.) 158.4 398.67 T
([Borg83]) 72 375.67 T
0.35 (Anita Borg, Jim Baumbach, and Sam Glazer. \322A Message System Supporting) 158.4 376.67 P
0.54 (Fault Tolerance.\323) 158.4 363.67 P
2 F
0.54 (Pr) 239.11 363.67 P
0.54 (oceedings of the Ninth Symposium on Operating Systems) 249.69 363.67 P
(Principles) 158.4 350.67 T
1 F
(, pages 90-99, November 1983.) 203.57 350.67 T
([Borg89]) 72 327.67 T
0.28 (A. Borg and W. Blau and W. Graetsch and F. Herrman and W. Oberle. \322Fault) 158.4 328.67 P
0.09 (Tolerance Under UNIX.\323) 158.4 315.67 P
2 F
0.09 (ACM T) 273.36 315.67 P
0.09 (ransactions on Computer Systems) 304.89 315.67 P
1 F
0.09 (, volume 7,) 454.39 315.67 P
(number 1, February, 1989.) 158.4 302.67 T
([Bruell88]) 72 279.67 T
3.89 (G. Bruell, A. Z. Spector, R. Pausch. \322Camelot, a Flexible, Distributed) 158.4 280.67 P
6.45 (Transaction Processing System.\323) 158.4 267.67 P
2 F
6.45 (Thirty-thir) 325.45 267.67 P
6.45 (d IEEE Computer Society) 371.44 267.67 P
(International Confer) 158.4 254.67 T
(ence) 249.25 254.67 T
1 F
(\050COMPCON\051, pages 432-437, March 1988.) 272.12 254.67 T
([Cherit84]) 72 231.67 T
1.65 (D. R. Cheriton. \322The V Kernel: a Software Base for Distributed Systems.\323) 158.4 232.67 P
2 F
(IEEE Softwar) 158.4 219.67 T
(e) 218.73 219.67 T
1 F
(, volume 1, number 2, pages 19-42, April 1984.) 223.6 219.67 T
([Cherit93]) 72 196.67 T
-0.47 (David R. Cheriton and Dale Skeen. \322Understanding the Limitations of Causally) 158.4 197.67 P
5.58 (and Totally Ordered Communication.\323) 158.4 184.67 P
2 F
5.58 (Pr) 353.72 184.67 P
5.58 (oceedings of the Fourteenth) 364.3 184.67 P
(Symposium on Operating Systems Principles) 158.4 171.67 T
1 F
(, December, 1993.) 355.53 171.67 T
([Dasgup88]) 72 148.67 T
2.02 (P. Dasgupta, R. LeBlanc, W. Appelbe. \322The Clouds Distributed Operating) 158.4 149.67 P
1.03 (System: Functional Description, Implementation Details and Related Work.\323) 158.4 136.67 P
2 F
0.07 (Eighth International Confer) 158.4 123.67 P
0.07 (ence on Distributed Computing Systems) 281.43 123.67 P
1 F
0.07 (, San Jose,) 457.48 123.67 P
(CA, pages 13-17, June 1988.) 158.4 110.67 T
([DeWitt84]) 72 87.67 T
-0.39 (David J. DeWitt, Randy H. Katz, Frank Olken, Leonard D. Shapiro, Michael R.) 158.4 88.67 P
FMENDPAGE
%%EndPage: "123" 135
%%Page: "124" 135
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(124) 315.01 55 T
1 11 Q
2.16 (Stonebraker, David Wood. \322Implementation Techniques for Main Memory) 194.4 712.67 P
0.24 (Database Systems.\323) 194.4 699.67 P
2 F
0.24 (Pr) 284.88 699.67 P
0.24 (oceedings of the 1984 ACM SIGMOD Annual Meeting) 295.46 699.67 P
1 F
0.24 (,) 537.25 699.67 P
(Boston, MA, June 1984.) 194.4 686.67 T
([Dougli91]) 108 663.67 T
4.56 (F. Douglis and J. Ousterhout. \322Transparent Process Migration: Design) 194.4 664.67 P
4.85 (Alternatives and the Sprite Implementation.\323) 194.4 651.67 P
2 F
4.85 (Softwar) 418.82 651.67 P
4.85 (e) 452.6 651.67 P
3 F
4.85 (-) 465.08 651.67 P
2 F
4.85 ( Practice and) 471.11 651.67 P
(Experience) 194.4 638.67 T
1 F
(, volume 21, number 8, August, 1991.) 243.82 638.67 T
([Dunlap86]) 108 615.67 T
1.64 (Kevin J. Dunlap. \322Name Server Operations Guide for BIND.\323 Release 4.3,) 194.4 616.67 P
0.7 (Unix System Manager\325s Manual. Printed by the USENIX Association. April,) 194.4 603.67 P
(1986.) 194.4 590.67 T
([Gait90]) 108 567.67 T
0.96 (Jason Gait. \322A Safe In-Memory File System.\323) 194.4 568.67 P
2 F
0.96 (Communications of the ACM) 406.49 568.67 P
1 F
0.96 (,) 537.25 568.67 P
(volume 33, number 1, pages 81-86, January, 1990.) 194.4 555.67 T
([Garcia92]) 108 532.67 T
-0.01 (Hector Garcia-Molina and Kenneth Salem. \322Main Memory Database Systems:) 194.4 533.67 P
2.84 (An Overview.\323) 194.4 520.67 P
2 F
2.84 (IEEE T) 269.95 520.67 P
2.84 (ransactions on Knowledge and Data Engineering) 304.84 520.67 P
1 F
2.84 (,) 537.25 520.67 P
(volume 4, number 6, December, 1992.) 194.4 507.67 T
([Giffor88]) 108 484.67 T
-0.01 (David K. Gifford, Roger M. Needham, and Michael D. Schroeder. \322The Cedar) 194.4 485.67 P
0.21 (File System.\323) 194.4 472.67 P
2 F
0.21 (Communications of the ACM) 257.38 472.67 P
1 F
0.21 (, volume 31, number 3, pages 288-) 385.88 472.67 P
(298, March 1988.) 194.4 459.67 T
([Gray89]) 108 436.67 T
1.7 (Cary G. Gray and David R. Cheriton. \322Leases: An Efficient Fault-Tolerant) 194.4 437.67 P
3.47 (Mechanism for Distributed File Cache Consistency.\323) 194.4 424.67 P
2 F
3.47 (Pr) 451.08 424.67 P
3.47 (oceedings of the) 461.66 424.67 P
5.85 (T) 194.4 411.67 P
5.85 (welfth Symposium on Operating Systems Principles) 199.7 411.67 P
1 F
5.85 (, pages 202-210,) 455.68 411.67 P
(December, 1989.) 194.4 398.67 T
([Gray88]) 108 375.67 T
0.23 (Jim Gray. \322The Transaction Concept: Virtues and Limitations.\323) 194.4 376.67 P
2 F
0.23 (Lectur) 478.83 376.67 P
0.23 (e Notes) 507.11 376.67 P
-0.35 (in Computer Science) 194.4 363.67 P
1 F
-0.35 (, Conference Proceedings, Netherlands, 1981. In) 285.23 363.67 P
2 F
-0.35 (Readings) 499.11 363.67 P
0.43 (in Database Systems) 194.4 350.67 P
1 F
0.43 (, edited by Michael Stonebraker, pages 140-150. Morgan) 286.19 350.67 P
(Kaufmann Publishers, San Mateo, California, 1988.) 194.4 337.67 T
([Gray90]) 108 314.67 T
-0.51 (Jim Gray. \322A Census of Tandem System Availability Between 1985 and 1990.\323) 194.4 315.67 P
(Tandem Technical Report 90.1. Part number 33579,) 194.4 302.67 T
(January, 1990.) 426.3 302.67 T
([Gray93]) 108 279.67 T
4.3 (Jim Gray, and Andreas Reuter. \322Transaction Processing: Concepts and) 194.4 280.67 P
(Techniques.\323 Morgan Kaufmann Publishers, 1993.) 194.4 267.67 T
([Hagman86]) 108 244.67 T
2.5 (Robert B. Hagmann. \322A Crash Recovery Scheme for a Memory-Resident) 194.4 245.67 P
1.07 (Database System.\323) 194.4 232.67 P
2 F
1.07 (IEEE T) 282.27 232.67 P
1.07 (ransactions on Computers) 315.39 232.67 P
1 F
1.07 (, volume 35, number 9,) 433.5 232.67 P
(September 1986.) 194.4 219.67 T
([Hartma93]) 108 196.67 T
1.07 (John H. Hartman and John K. Ousterhout. \322The Zebra Striped Network File) 194.4 197.67 P
2.17 (System.\323) 194.4 184.67 P
2 F
2.17 (Pr) 239.3 184.67 P
2.17 (oceedings of the Fourteenth Symposium on Operating Systems) 249.88 184.67 P
(Principles) 194.4 171.67 T
1 F
(, December, 1993.) 239.57 171.67 T
([Haskin88]) 108 148.67 T
0.53 (Roger Haskin, Yoni Malachi, Wayne Sawdon, and Gregory Chan. \322Recovery) 194.4 149.67 P
3.9 (Management in QuickSilver.\323) 194.4 136.67 P
2 F
3.9 (ACM T) 340.98 136.67 P
3.9 (ransactions on Computer Systems) 376.32 136.67 P
1 F
3.9 (,) 537.25 136.67 P
(volume 6, number 1, pages 82-108, February, 1988.) 194.4 123.67 T
([Hisgen89]) 108 100.67 T
0.57 (Andy Hisgen, Andrew Birrell, Timothy Mann, Michael Schroeder and Garret) 194.4 101.67 P
1.31 (Swart. \322Availability and Consistency Tradeoffs in the Echo Distributed File) 194.4 88.67 P
FMENDPAGE
%%EndPage: "124" 136
%%Page: "125" 136
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(125) 279.01 55 T
1 11 Q
2.88 (System.\323) 158.4 712.67 P
2 F
2.88 (Pr) 204.01 712.67 P
2.88 (oceedings of the Second W) 214.59 712.67 P
2.88 (orkshop on W) 342.87 712.67 P
2.88 (orkstation Operating) 408.65 712.67 P
(Systems) 158.4 699.67 T
1 F
(, September, 1989.) 193.18 699.67 T
([Howard88]) 72 676.67 T
0.28 (J. H. Howard, M. L. Kazar, S. G. Menees, D. A. Nichols, M. Satyanarayanan,) 158.4 677.67 P
-0.57 (R. N. Sidebotham, and M. J. West. \322Scale and Performance in a Distributed File) 158.4 664.67 P
-0.23 (System.\323) 158.4 651.67 P
2 F
-0.23 (ACM T) 200.9 651.67 P
-0.23 (ransactions on Computer Systems) 232.11 651.67 P
1 F
-0.23 (, volume 6, number 1, pages) 380.65 651.67 P
(51-81, February, 1988.) 158.4 638.67 T
([Jewett91]) 72 615.67 T
3.34 (D. Jewett. \322Integrity S2: A Fault-Tolerant UNIX Platform.\323) 158.4 616.67 P
2 F
3.34 (Digest 21st) 450.91 616.67 P
(International Symposium on Fault-T) 158.4 603.67 T
(olerant Computing) 318.22 603.67 T
1 F
(, June,1991.) 401.54 603.67 T
([Johnso93]) 72 580.67 T
(Paul Johnson. Personal Communication. June 18, 1993.) 158.4 581.67 T
([Juszcz89]) 72 558.67 T
3.35 (Chet Juszczak. \322Improving the Performance and Correctness of an NFS) 158.4 559.67 P
1.4 (Server.\323) 158.4 546.67 P
2 F
1.4 (Pr) 198.85 546.67 P
1.4 (oceedings of the W) 209.43 546.67 P
1.4 (inter 1989 USENIX Confer) 296.32 546.67 P
1.4 (ence) 419.44 546.67 P
1 F
1.4 (, pages 56-63,) 439.57 546.67 P
(February, 1989.) 158.4 533.67 T
([Kazar90]) 72 510.67 T
-0.19 (Michael L. Kazar, Bruce W. Leverett, Owen T. Anderson, Vasilis Apostolides,) 158.4 511.67 P
0.4 (Beth A. Bottos, Sailesh Chutani, Craig F. Everhart, W. Anthony Mason, Shu-) 158.4 498.67 P
5.01 (Tsui Tu and Edward R. Zayas. \322DEcorum File System Architectural) 158.4 485.67 P
-0.06 (Overview.\323) 158.4 472.67 P
2 F
-0.06 (Pr) 212.03 472.67 P
-0.06 (oceedings of the Summer 1990 USENIX Confer) 222.61 472.67 P
-0.06 (ence) 430.59 472.67 P
1 F
-0.06 (, pages 151-) 450.72 472.67 P
(163, June, 1990.) 158.4 459.67 T
([Kazar93]) 72 436.67 T
(Michael L. Kazar. Personal Communication, June, 1993.) 158.4 437.67 T
([Kistle91]) 72 414.67 T
-0.28 (James J. Kistler, and M. Satyanarayanan. \322Disconnected Operation in the Coda) 158.4 415.67 P
0.06 (File System.\323) 158.4 402.67 P
2 F
0.06 (Pr) 221.09 402.67 P
0.06 (oceedings of the Thirteenth Symposium on Operating Systems) 231.67 402.67 P
(Principles) 158.4 389.67 T
1 F
(, pages 213-225, October, 1991.) 203.57 389.67 T
([Kleima86]) 72 366.67 T
0.96 (S. R. Kleiman, \322Vnodes: An Architecture for Multiple File System Types in) 158.4 367.67 P
-0.45 (Sun UNIX.\323) 158.4 354.67 P
2 F
-0.45 (Pr) 215.17 354.67 P
-0.45 (oceedings of the Summer 1986 USENIX Confer) 225.75 354.67 P
-0.45 (ence) 431.38 354.67 P
1 F
-0.45 (, pages 238-) 451.5 354.67 P
(247, June, 1986.) 158.4 341.67 T
([Lai89]) 72 318.67 T
(Nick Lai. Personal Communication, Fall, 1989.) 158.4 319.67 T
([Lin90]) 72 296.67 T
1.51 (Ting-Ting Y. Lin and Daniel P. Siewiorek. \322Error Log Analysis: Statistical) 158.4 297.67 P
1.54 (Modeling and Heuristic Trend Analysis.\323) 158.4 284.67 P
2 F
1.54 (IEEE T) 351.04 284.67 P
1.54 (ransactions on Reliability) 384.63 284.67 P
1 F
1.54 (,) 501.25 284.67 P
(volume 39, number 4, October, 1990.) 158.4 271.67 T
([Liskov88]) 72 248.67 T
0.17 (Barbara Liskov. \322Distributed Programming in Argus.\323) 158.4 249.67 P
2 F
0.17 (Communications of the) 401.72 249.67 P
(ACM) 158.4 236.67 T
1 F
(, pages 300-312, March 1988.) 181.59 236.67 T
([Liskov91]) 72 213.67 T
-0.52 (Barbara Liskov, Sanjay Ghemawat, Robert Gruber, Paul Johnson, Liuba Shrira,) 158.4 214.67 P
0.42 (and Michael Williams. \322Replication in the Harp File System.\323 P) 158.4 201.67 P
2 F
0.42 (r) 444.48 201.67 P
0.42 (oceedings of) 448.35 201.67 P
(the Thirteenth Symposium on Operating Systems Principles) 158.4 188.67 T
1 F
(, October, 1991.) 420.23 188.67 T
([Long91]) 72 165.67 T
0.27 (D. Long, J. Carroll and C. Park. \322A Study of the Reliability of Internet Sites.\323) 158.4 166.67 P
2 F
4.74 (Pr) 158.4 153.67 P
4.74 (oceedings of the T) 168.98 153.67 P
4.74 (enth Symposium on Reliable Distributed Systems) 262.43 153.67 P
1 F
4.74 (,) 501.25 153.67 P
(September, 1991.) 158.4 140.67 T
([Mackle91]) 72 117.67 T
-0.53 (Rick Macklem. \322Lessons Learned Tuning the 4.3 BSD Reno Implementation of) 158.4 118.67 P
-0.39 (the NFS Protocol.\323) 158.4 105.67 P
2 F
-0.39 (Pr) 243.9 105.67 P
-0.39 (oceedings of the W) 254.48 105.67 P
-0.39 (inter 1991 USENIX Confer) 336.01 105.67 P
-0.39 (ence) 453.75 105.67 P
1 F
-0.39 (, pages) 473.88 105.67 P
(53-64, January, 1991.) 158.4 92.67 T
FMENDPAGE
%%EndPage: "125" 137
%%Page: "126" 137
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(126) 315.01 55 T
1 11 Q
([Mann93]) 108 712.67 T
2.57 (Timothy Mann, Andrew Birrell, Andy Hisgen, Charles Jerian, and Garret) 194.4 713.67 P
2.54 (Swart. \322A Coherent Distributed File Cache with Directory Write-behind.\323) 194.4 700.67 P
(Digital SRC Research Report Number 103, June, 1993.) 194.4 687.67 T
([McKusi84]) 108 664.67 T
2.15 (M. McKusick, W. Joy, S. Leffler, and R. Fabry. \322A Fast File System for) 194.4 665.67 P
0.26 (UNIX.\323) 194.4 652.67 P
2 F
0.26 (ACM T) 232.49 652.67 P
0.26 (ransactions on Computer Systems) 264.19 652.67 P
1 F
0.26 (, volume 2, number 3. pages) 414.2 652.67 P
(181-197, August, 1984.) 194.4 639.67 T
([Mogul92]) 108 616.67 T
2.25 (Jeffrey C. Mogul. \322A Recovery Protocol for Spritely NFS.\323) 194.4 617.67 P
2 F
2.25 (USENIX File) 479.47 617.67 P
(Systems W) 194.4 604.67 T
(orkshop Pr) 240.07 604.67 T
(oceedings) 288.8 604.67 T
1 F
(, pages 93-109, May, 1992.) 332.73 604.67 T
([Mogul93]) 108 581.67 T
2.53 (Jeffrey C. Mogul. \322Recovery in Spritely NFS.\323 Digital Western Research) 194.4 582.67 P
(Laboratory Research Report 93/2, June, 1993.) 194.4 569.67 T
([Muelle83]) 108 546.67 T
-0.49 (E. Mueller, et al. \322A Nested Transaction Mechanism for LOCUS.\323) 194.4 547.67 P
2 F
-0.49 (Pr) 485.49 547.67 P
-0.49 (oceedings) 496.07 547.67 P
(of the Ninth Symposium on Operating System Principles) 194.4 534.67 T
1 F
(, October, 1983.) 441.89 534.67 T
([Nelson88]) 108 511.67 T
0.42 (M. Nelson, B. Welch, and J. Ousterhout, \322Caching in the Sprite Network File) 194.4 512.67 P
-0.05 (System.\323 Transactions on Computer Systems, volume 6, number 1, pages 134-) 194.4 499.67 P
(154, February, 1988.) 194.4 486.67 T
([Ouster88]) 108 463.67 T
-0.39 (J. Ousterhout, A. Cherenson, F. Douglis, M. Nelson, and B. Welch. \322The Sprite) 194.4 464.67 P
0.26 (Network Operating System.\323) 194.4 451.67 P
2 F
0.26 (IEEE Computer) 325.78 451.67 P
1 F
0.26 (, volume 6, number 1, pages 23-) 396.53 451.67 P
(36, February, 1988.) 194.4 438.67 T
([Ouste90a]) 108 415.67 T
0.04 (John K. Ousterhout. \322Why Aren\325t Operating Systems Getting Faster as Fast as) 194.4 416.67 P
-0.29 (Hardware?\323) 194.4 403.67 P
2 F
-0.29 (Pr) 249.92 403.67 P
-0.29 (oceedings of the Summer 1990 USENIX Confer) 260.5 403.67 P
-0.29 (ence) 467.06 403.67 P
1 F
-0.29 (, pages 247-) 487.19 403.67 P
(256, June, 1990.) 194.4 390.67 T
([Ouste90b]) 108 367.67 T
0.5 (John K. Ousterhout. \322The Role of Distributed State.\323) 194.4 368.67 P
2 F
0.5 (Pr) 434.25 368.67 P
0.5 (oceedings of the 25th) 444.83 368.67 P
4.26 (Anniversary Symposium, School of Computer Science) 194.4 355.67 P
1 F
4.26 (, Carnegie Mellon) 451.85 355.67 P
(University, September, 1990.) 194.4 342.67 T
([Patter88]) 108 319.67 T
0.12 (David A. Patterson, Garth Gibson and Randy H. Katz. \322A Case for Redundant) 194.4 320.67 P
4.47 (Arrays of Inexpensive Disks \050RAID\051.\323) 194.4 307.67 P
2 F
4.47 (Pr) 389.46 307.67 P
4.47 (oceedings of the 1988 ACM) 400.04 307.67 P
(SIGMOD) 194.4 294.67 T
1 F
(, pages 109-116, June, 1988.) 236.5 294.67 T
([Popek85]) 108 271.67 T
-0.51 (Gerald J. Popek and Bruce J. Walker, editors. \322The LOCUS Distributed System) 194.4 272.67 P
(Architecture.\323 The MIT Press, Cambridge, Massachusetts, 1985.) 194.4 259.67 T
([Pu86]) 108 236.67 T
1.01 (C. Pu, J. D. Noe, and A. Proudfoot. \322Regeneration of Replicated Objects: A) 194.4 237.67 P
5.38 (Technique and its Eden Implementation.\323) 194.4 224.67 P
2 F
5.38 (Pr) 407.41 224.67 P
5.38 (oceedings of the Second) 417.99 224.67 P
-0.42 (International Confer) 194.4 211.67 P
-0.42 (ence on Data Engineering) 284.82 211.67 P
1 F
-0.42 (, pages 175-187, February 1986.) 399.2 211.67 P
([Reed81]) 108 188.67 T
-0.07 (D. Reed and L. Svobodova. \322SWALLOW: A Distributed Data Storage System) 194.4 189.67 P
-0.04 (for a Local Network.\323 In) 194.4 176.67 P
2 F
-0.04 (Networks for Computer Communications) 305.84 176.67 P
1 F
-0.04 (, pages 355-) 486.69 176.67 P
(373, North-Holland, Amsterdam, 1981.) 194.4 163.67 T
([Reuter84]) 108 140.67 T
3.65 (Andreas Reuter. \322Performance Analysis of Recovery Techniques.\323) 194.4 141.67 P
2 F
3.65 (ACM) 516.81 141.67 P
2.9 (T) 194.4 128.67 P
2.9 (ransactions on Database Systems) 199.9 128.67 P
1 F
2.9 (, volume 9, number 4, pages 526-559,) 355.99 128.67 P
(December, 1984.) 194.4 115.67 T
([Rodehe91]) 108 92.67 T
0.22 (Thomas L. Rodeheffer and Michael D. Schroeder. Automatic Reconfiguration) 194.4 93.67 P
FMENDPAGE
%%EndPage: "126" 138
%%Page: "127" 138
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(127) 279.01 55 T
1 11 Q
0.67 (in Autonet.\323) 158.4 712.67 P
2 F
0.67 (Pr) 216.81 712.67 P
0.67 (oceedings of the Thirteenth Symposium on Operating Systems) 227.39 712.67 P
(Principles) 158.4 699.67 T
1 F
(, pages 183-197, October, 1991.) 203.57 699.67 T
([Rosenb91]) 72 676.67 T
1.38 (M. Rosenblum and J. K. Ousterhout. \322The Design and Implementation of a) 158.4 677.67 P
2.02 (Log-Structured File System.\323) 158.4 664.67 P
2 F
2.02 (Pr) 296.89 664.67 P
2.02 (oceedings of the Thirteenth Symposium on) 307.47 664.67 P
1.07 (Operating Systems Principles) 158.4 651.67 P
1 F
1.07 (, pages 1-15, October, 1991. Also published as) 291.15 651.67 P
2 F
3.31 (T) 158.4 638.67 P
3.31 (ransactions on Computer Systems) 163.9 638.67 P
1 F
3.31 (, volume 10, number 1, pages 26-52,) 323.05 638.67 P
(February, 1992.) 158.4 625.67 T
([Rosenb92]) 72 602.67 T
(Mendel Rosenblum. Personal Communication. 1992.) 158.4 603.67 T
([Salem86]) 72 580.67 T
0.6 (Kenneth Salem and Hector Garcia-Molina. \322Crash Recovery Mechanisms for) 158.4 581.67 P
4.66 (Main Storage Database Systems.\323 CS-TR-034-86, Princeton University,) 158.4 568.67 P
(Princeton, NJ, 1986.) 158.4 555.67 T
([Sandbe85]) 72 532.67 T
0.73 (R. Sandberg, D. Goldberg, S. Kleiman, D. Walsh, and B. Lyon. \322Design and) 158.4 533.67 P
0.61 (Implementation of the Sun Network Filesystem.\323) 158.4 520.67 P
2 F
0.61 (Pr) 381.45 520.67 P
0.61 (oceedings of the Summer) 392.03 520.67 P
(1985 USENIX Confer) 158.4 507.67 T
(ence) 253.82 507.67 T
1 F
(, pages 119-130, June, 1985.) 273.94 507.67 T
([Satyan90]) 72 484.67 T
0.71 (M. Satyanarayanan. \322Scalable, Secure, and Highly Available Distributed File) 158.4 485.67 P
(Access.\323) 158.4 472.67 T
2 F
(IEEE Computer) 199.88 472.67 T
1 F
(, volume 23, number 5, May, 1990.) 270.37 472.67 T
([Satyan93]) 72 449.67 T
0.17 (M. Satyanarayanan, Henry H. Mashburn, Puneet Kumar, David C. Steere, and) 158.4 450.67 P
0.5 (James J. Kistler. \322Lightweight Recoverable Virtual Memory.\323) 158.4 437.67 P
2 F
0.5 (Pr) 437.7 437.67 P
0.5 (oceedings of) 448.28 437.67 P
1.01 (the Fourteenth Symposium on Operating Systems Principles) 158.4 424.67 P
1 F
1.01 (, pages 146-160,) 429.35 424.67 P
(December, 1993.) 158.4 411.67 T
([Seltz93a]) 72 388.67 T
1.93 (Margo Seltzer. \322File System Performance and Transaction Support.\323 Ph.D.) 158.4 389.67 P
0.7 (Thesis, Computer Science Division, U. C. Berkeley. Available as Electronics) 158.4 376.67 P
3 (Research Laboratory, College of Engineering, University of California at) 158.4 363.67 P
(Berkeley Memorandum No. UCB/ERL M93/1, January, 1993.) 158.4 350.67 T
([Seltz93b]) 72 327.67 T
0.63 (Margo Seltzer, Keith Bostic, Marshall Kirk McKusick, and Carl Staelin. \322An) 158.4 328.67 P
-0.64 (Implementation of a Log-Structured File System for UNIX.\323) 158.4 315.67 P
2 F
-0.64 (Pr) 423.3 315.67 P
-0.64 (oceedings of the) 433.88 315.67 P
(W) 158.4 302.67 T
(inter 1993 USENIX Confer) 166.95 302.67 T
(ence) 285.86 302.67 T
1 F
(, pages 307-326, January, 1993.) 305.99 302.67 T
([Siegel89]) 72 279.67 T
3.62 (Alex Siegel, Kenneth Birman, and Keith Marzullo. \322Deceit: A Flexible) 158.4 280.67 P
0.4 (Distributed File System.\323 Technical report 89-1042. Department of Computer) 158.4 267.67 P
(Science, Cornell University, 1989.) 158.4 254.67 T
([Siewio92]) 72 231.67 T
1.05 (Daniel P. Siewiorek and Robert S. Swarz.) 158.4 232.67 P
2 F
1.05 (Reliable Computer Systems) 352.53 232.67 P
1 F
1.05 (. DEC) 475.48 232.67 P
(Press, 2nd edition, 1992.) 158.4 219.67 T
([Smith81]) 72 196.67 T
1.14 (W. B. Smith and F. T. Andrews. \322No. 5ESS Overview.\323) 158.4 197.67 P
2 F
1.14 (Pr) 419.74 197.67 P
1.14 (oceedings of the) 430.32 197.67 P
3.76 (T) 158.4 184.67 P
3.76 (enth International Switching Symposium) 163.5 184.67 P
1 F
3.76 (, Montreal, Canada, September,) 353.29 184.67 P
(1981.) 158.4 171.67 T
([Specto85]) 72 148.67 T
0.36 (A. Z. Spector, J. Butcher, D. S. Daniels, D. J. Duchamp, J. L. Eppinger, C. E.) 158.4 149.67 P
5.28 (Fineman, A. Heddaya, and P. M. Schwarz. \322Support for Distributed) 158.4 136.67 P
4.61 (Transactions in the TABS Prototype.\323) 158.4 123.67 P
2 F
4.61 (IEEE T) 351.72 123.67 P
4.61 (ransactions on Softwar) 388.37 123.67 P
4.61 (e) 499.12 123.67 P
(Engineering) 158.4 110.67 T
1 F
(, volume 11, number 6, pages 520-530, June 1985.) 212.72 110.67 T
([Sriniv89]) 72 87.67 T
0.35 (V. Srinivasan and Jeffrey C. Mogul. \322Spritely NFS: Experiments with Cache-) 158.4 88.67 P
FMENDPAGE
%%EndPage: "127" 139
%%Page: "128" 139
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(128) 315.01 55 T
1 11 Q
0.74 (Consistency Protocols.\323) 194.4 712.67 P
2 F
0.74 (Pr) 304.22 712.67 P
0.74 (oceedings of the T) 314.8 712.67 P
0.74 (welfth Symposium on Operating) 396.48 712.67 P
(Systems Principles) 194.4 699.67 T
1 F
(, pages 45-57, December, 1989.) 277.09 699.67 T
([Stoneb86]) 108 676.67 T
-0.47 (M. Stonebraker and L. Rowe. \322The Design of POSTGRES.\323) 194.4 677.67 P
2 F
-0.47 (Pr) 458.97 677.67 P
-0.47 (oceedings of the) 469.55 677.67 P
(Fifth ACM SIGMOD Confer) 194.4 664.67 T
(ence) 319.41 664.67 T
1 F
(, June, 1986.) 339.54 664.67 T
([Stoneb87]) 108 641.67 T
0.83 (M. Stonebraker. \322The Design of the POSTGRES Storage System.\323) 194.4 642.67 P
2 F
0.83 (Readings) 499.11 642.67 P
1.15 (13th International Confer) 194.4 629.67 P
1.15 (ence on V) 309.83 629.67 P
1.15 (ery Lar) 354.23 629.67 P
1.15 (ge Databases) 387.63 629.67 P
1 F
1.15 (, Brighton, England,) 448.28 629.67 P
(September, 1987.) 194.4 616.67 T
([Stratu89]) 108 593.67 T
2.2 (Stratus Computer, Inc. \322VOS Transaction Processing Facility Guide.\323 Part) 194.4 594.67 P
(Number R215-00, November, 1989.) 194.4 581.67 T
([Sulliv90]) 108 558.67 T
0.52 (Mark Sullivan. Unpublished survey of software errors reported in 4.1 and 4.2) 194.4 559.67 P
(BSD UNIX. 1990.) 194.4 546.67 T
([Sulliv91]) 108 523.67 T
1.33 (Mark Sullivan and Ram Chillarege. \322Software Defects and Their Impact on) 194.4 524.67 P
0.07 (System Availability - A Study of Field Failures in Operating Systems.\323) 194.4 511.67 P
2 F
0.07 (Digest) 511.31 511.67 P
(21st International Symposium on Fault T) 194.4 498.67 T
(olerant Computing) 374.37 498.67 T
1 F
(, June 1991.) 457.69 498.67 T
([Sulli93a]) 108 475.67 T
3.07 (Mark Sullivan. \322System Support for Software Fault Tolerance in Highly) 194.4 476.67 P
1.03 (Available Database Management Systems.\323 Ph.D. Thesis, Computer Science) 194.4 463.67 P
3.91 (Division, University of California at Berkeley. Available as Electronics) 194.4 450.67 P
1.17 (Research Laboratory, College of Engineering, U. C. Berkeley Memorandum) 194.4 437.67 P
(No. UCB/ERL M93/5, January, 1993) 194.4 424.67 T
([Sulli93b]) 108 401.67 T
(Mark Sullivan. Personal Communication, July 21, 1993.) 194.4 402.67 T
([Tandem90]) 108 379.67 T
(Tandem. Sales brochures and price lists, October, 1990.) 194.4 380.67 T
([Thomps87]) 108 357.67 T
2.8 (J. G. Thompson. \322Efficient Analysis of Caching Systems.\323 Ph.D. Thesis,) 194.4 358.67 P
-0.01 (Computer Science Division, University of California at Berkeley. Available as) 194.4 345.67 P
(EECS technical report number UCB/CSD 87/374, October, 1987.) 194.4 332.67 T
([Thomps89]) 108 309.67 T
1.48 (James G. Thompson and Alan Jay Smith. \322Efficient \050Stack\051 Algorithms for) 194.4 310.67 P
4.71 (Analysis of Write-Back and Sector Memories.\323) 194.4 297.67 P
2 F
4.71 (ACM T) 434.12 297.67 P
4.71 (ransactions on) 470.28 297.67 P
(Computer Systems) 194.4 284.67 T
1 F
(, volume 7, number 1, pages 78-116, February 1989.) 275.88 284.67 T
([Toy92a]) 108 261.67 T
0.54 (L. C. Toy. \322Part II: Large-Scale Real-Time Program Retrofit Methodology in) 194.4 262.67 P
-0.01 (AT&T 5ESS Switch.\323 In) 194.4 249.67 P
2 F
-0.01 (Reliable Computer Systems) 306.95 249.67 P
1 F
-0.01 (, Daniel P. Siewiorek and) 427.76 249.67 P
(Robert S. Swarz, pages 574-586, DEC Press, 2nd edition, 1992.) 194.4 236.67 T
([Toy92b]) 108 213.67 T
2 (W. N. Toy. \322Part I: Fault-Tolerant Design of AT&T Telephone Switching) 194.4 214.67 P
0.9 (System Processors.\323 In) 194.4 201.67 P
2 F
0.9 (Reliable Computer Systems) 301.46 201.67 P
1 F
0.9 (, Daniel P. Siewiorek and) 424.1 201.67 P
(Robert S. Swarz, pages 533-574, DEC Press, 2nd edition, 1992.) 194.4 188.67 T
([Walker83]) 108 165.67 T
0.53 (Walker, Popek, English, Kline and Thie. \322The LOCUS Distributed Operating) 194.4 166.67 P
5.22 (System.\323) 194.4 153.67 P
2 F
5.22 (Pr) 242.35 153.67 P
5.22 (oceedings of the Ninth Symposium on Operating Systems) 252.93 153.67 P
(Principles) 194.4 140.67 T
1 F
(, pages 49-70, October, 1983.) 239.57 140.67 T
([Webber92]) 108 117.67 T
1.74 (Steven Webber. \322The Stratus Architecture.\323 In) 194.4 118.67 P
2 F
1.74 (Reliable Computer Systems) 412.93 118.67 P
1 F
1.74 (,) 537.25 118.67 P
1.74 (Daniel P. Siewiorek and Robert S. Swarz, pages 648-670, DEC Press, 2nd) 194.4 105.67 P
(edition, 1992.) 194.4 92.67 T
FMENDPAGE
%%EndPage: "128" 140
%%Page: "129" 140
612 792 0 FMBEGINPAGE
1 12 Q
0 X
0 K
(129) 279.01 55 T
1 11 Q
([Welch86]) 72 712.67 T
0.73 (Brent Welch. \322The Sprite Remote Procedure Call System.\323 Technical Report) 158.4 713.67 P
-0.02 (Number UCB/CSD 86/302, Computer Science Division, U. C. Berkeley, June,) 158.4 700.67 P
(1986.) 158.4 687.67 T
([Welch88]) 72 664.67 T
3.82 (Brent B. Welch and John K. Ousterhout. \322Pseudo Devices: User-Level) 158.4 665.67 P
3.02 (Extensions to the Sprite File System.\323) 158.4 652.67 P
2 F
3.02 (Pr) 346.49 652.67 P
3.02 (oceedings of the Summer 1988) 357.07 652.67 P
(USENIX Confer) 158.4 639.67 T
(ence) 229.1 639.67 T
1 F
(, pages 37-49, June, 1988.) 249.22 639.67 T
([Welch90]) 72 616.67 T
5.61 (Brent Ballinger Welch. \322Naming, State Management, and User-Level) 158.4 617.67 P
1.95 (Extensions in the Sprite Distributed File System.\323 Ph.D. Thesis, Computer) 158.4 604.67 P
1.88 (Science Division, University of California at Berkeley. Available as EECS) 158.4 591.67 P
(technical report number UCB/CSD 90/567, April, 1990.) 158.4 578.67 T
FMENDPAGE
%%EndPage: "129" 141
%%Trailer
%%BoundingBox: 0 0 612 792
%%Pages: 140 1
%%DocumentFonts: Times-Bold
%%+ Times-Roman
%%+ Times-Italic
%%+ Symbol
%%+ Courier-Bold
